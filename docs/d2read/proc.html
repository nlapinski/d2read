<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>d2read.proc API documentation</title>
<meta name="description" content="proc - handles reading memory from the d2r process." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link id="hljs" rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/a11y-dark.min.css" crossorigin>
<style id="css-theme">
:root[data-theme='theme-light']{--bg-highlight-color:#FFEE99;--bg-default:#FFFFFF;--bg-code:#EEEEEE;--bg-code-hover:#e0e0e0;--fc-default:#0F1A20;--fc-muted:#666666;--link-primary:#005588;--link-hover:#ee8822;--ident-primary:#990000;--hr-default:#666666;--bd-default:#DDDDDD;--bd-pre:#DDDDDD;--bd-primary:#666666;--adm-note:#abeeff;--adm-todo:#ddffdd;--adm-warning:#ffdd44;--adm-error:#feb6c1;--adm-bd-note:#abeeff;--adm-bd-todo:#ddffdd;--adm-bd-warning:#ffdd44;--adm-bd-error:#feb6c1}:root[data-theme='theme-dark']{--bg-highlight-color:#3e4951;--bg-default:#22282D;--bg-code:#3e4951;--bg-code-hover:#313b42;--fc-default:#ACBAC7;--fc-muted:#ACBAC7;--link-primary:#539bf5;--link-hover:#abcdf9;--ident-primary:#539bf5;--hr-default:#444d56;--bd-default:#444d56;--bd-pre:#3e4951;--bd-primary:#539bf5;--adm-note:rgba(65,132,288,0.1);--adm-todo:rgba(165,255,169,0.1);--adm-warning:rgba(255,221,68,0.2);--adm-error:rgba(254,182,193,0.2);--adm-bd-note:#539bf5;--adm-bd-todo:#a5ffa9;--adm-bd-warning:#ffdd44;--adm-bd-error:#feb6c1}@media (prefers-color-scheme:light){:root[data-theme='theme-light']{--bg-highlight-color:#FFEE99;--bg-default:#FFFFFF;--bg-code:#EEEEEE;--bg-code-hover:#e0e0e0;--fc-default:#0F1A20;--fc-muted:#666666;--link-primary:#005588;--link-hover:#ee8822;--ident-primary:#990000;--hr-default:#666666;--bd-default:#DDDDDD;--bd-pre:#DDDDDD;--bd-primary:#666666;--adm-note:#abeeff;--adm-todo:#ddffdd;--adm-warning:#ffdd44;--adm-error:#feb6c1;--adm-bd-note:#abeeff;--adm-bd-todo:#ddffdd;--adm-bd-warning:#ffdd44;--adm-bd-error:#feb6c1}}@media (prefers-color-scheme:dark){:root[data-theme='theme-dark']{--bg-highlight-color:#3e4951;--bg-default:#22282D;--bg-code:#3e4951;--bg-code-hover:#313b42;--fc-default:#ACBAC7;--fc-muted:#ACBAC7;--link-primary:#539bf5;--link-hover:#abcdf9;--ident-primary:#539bf5;--hr-default:#444d56;--bd-default:#444d56;--bd-pre:#3e4951;--bd-primary:#539bf5;--adm-note:rgba(65,132,288,0.1);--adm-todo:rgba(165,255,169,0.1);--adm-warning:rgba(255,221,68,0.2);--adm-error:rgba(254,182,193,0.2);--adm-bd-note:#539bf5;--adm-bd-todo:#a5ffa9;--adm-bd-warning:#ffdd44;--adm-bd-error:#feb6c1}}
html {
background-color: var(--bg-default);
cursor: auto;
}
#dark-mode-toggle {
display: none;
border: 1px solid;
border-color: var(--bd-primary);
color: var(--bd-primary);
border-radius: 20px;
padding-left: 6px;
padding-right: 6px;
cursor: pointer;
}
.hidden {
visibility: hidden;
}
.dm-icon-off, .dm-icon-on {
display: inline;
width: 14px;
height: 14px;
margin-bottom: 4px;
}
h1:target,
h2:target,
h3:target,
h4:target,
h5:target,
h6:target {
background: var(--bg-highlight-color);
padding: .2em 0;
}
.flex {
display: flex;
}
body {
line-height: 1.5em;
color: var(--fc-default);
}
hr {
border-color: var(--hr-default);
}
#sidebar {
padding: 30px;
overflow: hidden;
}
#sidebar > *:last-child {
margin-bottom: 2cm;
}
.http-server-breadcrumbs {
font-size: 130%;
margin: 0 0 15px 0;
}
h1, h2, h3, h4, h5, h6 {
font-weight: 300;
color: var(--fc-default);
}
h1 {
font-size: 2.5em;
line-height: 1.1em;
}
h2 {
font-size: 1.75em;
margin: 1em 0 .50em 0;
}
h3 {
font-size: 1.4em;
margin: 25px 0 10px 0;
}
h4 {
margin: 0;
font-size: 105%;
}
#footer {
font-size: .75em;
padding: 5px 30px;
border-top: 1px solid;
border-color: var(--bd-default);
text-align: right;
}
#footer p {
margin: 0 0 0 1em;
display: inline-block;
}
#footer p:last-child {
margin-right: 30px;
}
a {
color: var(--link-primary);
text-decoration: none;
transition: color .3s ease-in-out;
}
a:hover {
color: var(--link-hover);
}
.title code {
font-weight: bold;
}
h2[id^="header-"] {
margin-top: 2em;
}
.ident {
color: var(--ident-primary);
}
pre code {
background: var(--bg-code);
font-size: .8em;
line-height: 1.4em;
}
code {
background: var(--bg-code);
padding: 1px 4px;
overflow-wrap: break-word;
}
h1 code { background: transparent }
pre {
border-top: 1px solid;
border-bottom: 1px solid;
border-color: var(--bd-pre);
}
#http-server-module-list {
display: flex;
flex-flow: column;
}
#http-server-module-list div {
display: flex;
}
#http-server-module-list dt {
min-width: 10%;
}
#http-server-module-list p {
margin-top: 0;
}
.toc ul, #index {
list-style-type: none;
margin: 0;
padding: 0;
}
#index code {
background: transparent;
}
#index h3 {
border-bottom: 1px solid;
border-color: var(--bd-default);
}
#index ul {
padding: 0;
}
#index h4 {
margin-top: .6em;
font-weight: bold;
}
/*
Make TOC lists have 2+ columns when viewport is wide enough.
Assuming ~20-character identifiers and ~30% wide sidebar.
*/
@media (min-width: 200ex) { #index .two-column { column-count: 2 } }
@media (min-width: 300ex) { #index .two-column { column-count: 3 } }
dl {
margin-bottom: 2em;
}
dl dl:last-child {
margin-bottom: 4em;
}
dd {
margin: 0 0 1em 3em;
}
#header-classes + dl > dd {
margin-bottom: 3em;
}
dd dd {
margin-left: 2em;
}
dd p {
margin: 10px 0;
}
.name {
background: var(--bg-code);
font-weight: bold;
font-size: .85em;
padding: 5px 10px;
display: inline-block;
min-width: 40%;
}
.name:hover {
background: var(--bg-code-hover);
}
dt:target .name {
background: var(--highlight-color);
}
.name > span:first-child {
white-space: nowrap;
}
.name.class > span:nth-child(2) {
margin-left: .4em;
}
.inherited {
color: #999; /* NOTE: Not entirely sure how to check this one.. Seems ok already?? */
border-left: 5px solid #eee;
padding-left: 1em;
}
.inheritance em {
font-style: normal;
font-weight: bold;
}
/* Docstrings titles, e.g. in numpydoc format */
.desc h2 {
font-weight: 400;
font-size: 1.25em;
}
.desc h3 {
font-size: 1em;
}
.desc dt code {
background: inherit;
/* Don't grey-back parameters */
}
.source summary, .git-link-div {
outline: none;
color: var(--fc-muted);
text-align: right;
font-weight: 400;
font-size: .8em;
text-transform: uppercase;
}
.source summary > * {
white-space: nowrap;
cursor: pointer;
}
.git-link {
color: inherit;
margin-left: 1em;
}
.source pre {
max-height: 500px;
overflow: auto;
margin: 0;
}
.source pre code {
font-size: 12px;
overflow: visible;
}
.hlist {
list-style: none;
}
.hlist li {
display: inline;
}
.hlist li:after {
content: ',\2002';
}
.hlist li:last-child:after {
content: none;
}
.hlist .hlist {
display: inline;
padding-left: 1em;
}
img {
max-width: 100%;
}
td {
padding: 0 .5em;
}
.admonition {
padding: .1em .5em;
margin-bottom: 1em;
border-radius: 8px;
border: 1px solid;
}
.admonition-title {
font-weight: bold;
}
.admonition.note,
.admonition.info,
.admonition.important {
background: var(--adm-note);
border-color: var(--adm-bd-note);
}
.admonition.todo,
.admonition.versionadded,
.admonition.tip,
.admonition.hint {
background: var(--adm-todo);
border-color: var(--adm-bd-todo);
}
.admonition.warning,
.admonition.versionchanged,
.admonition.deprecated {
background: var(--adm-warning);
border-color: var(--adm-bd-warning);
}
.admonition.error,
.admonition.danger,
.admonition.caution {
background: var(--adm-error);
border-color: var(--adm-bd-error);
}
/*
Desktop MQuery
* Standard desktop breakpoint is 1024, below are tablets and portables.
* No need to limit the max-width of #content, otherwise space is being wasted.
*/
@media screen and (min-width: 1024px) {
#dark-mode-toggle {
display: block;
position: absolute;
top: 5px;
right: 5px;
}
#sidebar {
width: 30%;
height: 100vh;
overflow: auto;
position: sticky;
top: 0;
}
#content {
width: 100%;
padding: 3em 4em;
border-left: 1px solid var(--bd-default);
}
pre code {
font-size: 1em;
}
.item .name {
font-size: 1em;
}
main {
display: flex;
flex-direction: row-reverse;
justify-content: flex-end;
}
.toc ul ul, #index ul {
padding-left: 1.5em;
}
.toc > ul > li {
margin-top: .5em;
}
}
@media print {
* {
background: transparent !important;
color: #000 !important; /* Black prints faster: h5bp.com/s */
box-shadow: none !important;
text-shadow: none !important;
}
#sidebar h1 {
page-break-before: always;
}
.source {
display: none;
}
a[href]:after {
content: " (" attr(href) ")";
font-size: 90%;
}
/* Internal, documentation links, recognized by having a title, don't need the URL explicity stated. */
a[href][title]:after {
content: none;
}
abbr[title]:after {
content: " (" attr(title) ")";
}
/* Don't show links for images, or javascript/internal links */
.ir a:after,
a[href^="javascript:"]:after,
a[href^="#"]:after {
content: "";
}
pre, blockquote {
border: 1px solid #999;
page-break-inside: avoid;
}
thead {
display: table-header-group; /* h5bp.com/t */
}
tr, img {
page-break-inside: avoid;
}
img {
max-width: 100% !important;
}
@page {
margin: 0.5cm;
}
p, h2, h3 {
orphans: 3;
widows: 3;
}
h1, h2, h3, h4, h5, h6 {
page-break-after: avoid;
}
}
</style>
<script>
const html = document.querySelector("html");
const isDarkQuery = window.matchMedia("(prefers-color-scheme: dark)");
const changeHLJS = (style) => {
const hljsStyle = document.querySelector("#hljs");
const styleURL = "https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/" + style + ".min.css";
hljsStyle.href = styleURL;
}
const loadedTheme = window.localStorage.getItem("theme");
if (loadedTheme) {
html.dataset.theme = loadedTheme;
if (loadedTheme == "theme-dark") {
changeHLJS(`atom-one-dark`);
} else {
changeHLJS(`a11y-dark`);
}
}
const onSystemThemeChange = (event) => {
const iconOff = document.querySelector(".dm-icon-off");
const iconOn = document.querySelector(".dm-icon-on");
if (event.matches) {
html.dataset.theme = "theme-dark";
iconOff.classList.add("hidden");
iconOn.classList.remove("hidden");
changeHLJS(`atom-one-dark`);
window.localStorage.setItem("theme", "theme-dark");
} else {
html.dataset.theme = "theme-light";
iconOff.classList.remove("hidden");
iconOn.classList.add("hidden");
changeHLJS(`a11y-dark`);
window.localStorage.setItem("theme", "theme-light");
}
};
isDarkQuery.addEventListener("change", onSystemThemeChange);
window.addEventListener("DOMContentLoaded", () => {
const iconOff = document.querySelector(".dm-icon-off");
const iconOn = document.querySelector(".dm-icon-on");
if (isDarkQuery.matches || loadedTheme == "theme-dark") {
iconOff.classList.add("hidden");
iconOn.classList.remove("hidden");
changeHLJS(`atom-one-dark`);
}
if ((!isDarkQuery.matches || loadedTheme == "theme-light") || !loadedTheme) {
iconOff.classList.remove("hidden");
iconOn.classList.add("hidden");
changeHLJS(`a11y-dark`);
}
});
const toggleDarkMode = () => {
const iconOff = document.querySelector(".dm-icon-off");
const iconOn = document.querySelector(".dm-icon-on");
if (html.dataset.theme == "theme-dark") {
html.dataset.theme = "theme-light";
iconOff.classList.remove("hidden");
iconOn.classList.add("hidden");
changeHLJS(`a11y-dark`);
window.localStorage.setItem("theme", "theme-light");
} else {
html.dataset.theme = "theme-dark";
iconOff.classList.add("hidden");
iconOn.classList.remove("hidden");
changeHLJS(`atom-one-dark`);
window.localStorage.setItem("theme", "theme-dark");
}
};
</script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>d2read.proc</code></h1>
</header>
<section id="section-intro">
<p>proc - handles reading memory from the d2r process.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#39;&#39;&#39;proc - handles reading memory from the d2r process.&#39;&#39;&#39;
import sys
import os
from bitstring import BitArray
import requests
import math
import pymem
import pymem.pattern
import os
os.system(&#39;color&#39;)
#from utils.misc import log_color
import numpy as np
import time
from subprocess import PIPE, Popen
import json
import yaml

#import re
import pymem.memory
import pymem.ressources.kernel32
import pymem.ressources.structure
from .enums import *
#COLORS
status=242
warn=202
good=123
purp=99

#color globals
combat_color = 160
loot_color = 208
traverse_color = 53
manager_color = 240
traverse_color = 125
sensing_color = 117



class proc:

    def __init__(self):

        &#39;&#39;&#39;Some doc string
        Args:
            c (str): some a.
            b (str): some b.
            a (str): some c.
        Returns:
            something I hope
        &#39;&#39;&#39;

        self.pm = None
        self.pm = pymem.Pymem(&#34;D2R.exe&#34;)
        self.process = self.pm
        self.player_unit = 0
        self.handle = self.pm.process_handle
        self.module = pymem.process.module_from_name(self.handle,&#34;D2R.exe&#34;)
        self.base = self.pm.base_address
        self.exp_offset = self.get_exp_offset()
        self.starting_offset = self.get_unit_offset()
        self.game_info_offset = self.get_game_info_offset()
        self.ui_settings_offset = self.get_ui_settings_offset()
        self.menu_vis_offset = self.get_menu_vis_offset()
        self.menu_data_offset = self.get_menu_data_offset()
        self.hoverd_offset = self.get_hover_object_offset()
        self.responseList = []
        self.map_offset = None
        self.grid=[]
        self.level = 1
        self.player_world_pos = np.array([0,0])
        self.area_origin = np.array([0,0])

        self.in_game = 0
        self.loaded = 0

        #data to include
        self.monsters = []
        self.poi = []
        self.items = []
        self.map = []
        self.current_area = None
        self.used_skill = None
        self.right_skill = None
        self.left_skill = None

        self.belt_health_pots = None
        self.belt_mana_pots = None

        self.menus =    {&#39;InGame&#39;: False,
                        &#39;Inventory&#39;: False,
                        &#39;Character&#39;: False,
                        &#39;SkillSelect&#39;: False,
                        &#39;SkillTree&#39;: False,
                        &#39;Chat&#39;: False,
                        &#39;NpcInteract&#39;: False,
                        &#39;EscMenu&#39;: False,
                        &#39;Map&#39;: False,
                        &#39;NpcShop&#39;: False,
                        &#39;QuestLog&#39;: False,
                        &#39;Waypoint&#39;: False,
                        &#39;Party&#39;: False,
                        &#39;Stash&#39;: False,
                        &#39;Cube&#39;: False,
                        &#39;AltPick&#39;:False,
                        &#39;Potions&#39;:False
                        }

        self.maps = []
        self._loot_data = []

        self.botty_data = {&#34;monsters&#34;: [],&#34;poi&#34;: [],
            &#34;objects&#34;: [],&#34;items&#34;: [],
            &#34;map&#34;: None,
            &#34;player_pos_world&#34;: None,
            &#34;player_pos_area&#34;: None,
            &#34;area_origin&#34;: None,
            &#34;current_area&#34;: None,
            &#34;used_skill&#34;: None,
            &#34;right_skill&#34;: None,
            &#34;left_skill&#34;: None,
            &#34;menus&#34;:None,
            &#34;belt_health_pots&#34;:None,
            &#34;belt_mana_pots&#34;:None,
            &#34;player_pos&#34;:None,       
            &#34;player_offset&#34;:np.array([0,0]),
            &#34;necroSkel&#34;: 0,
            &#34;necroMage&#34;: 0,
            &#34;necroGol&#34;: &#39;none&#39;,
            &#34;features&#34;: [],}


        
        log_color(&#34;:: Base address            -&gt; {}&#34;.format(hex(self.base)),fg_color=0,bg_color=traverse_color)

    def read_loot_cfg(self):
        with open(&#34;Z:/botty-r-latest/src/read_mem/item_filter.yaml&#34;, &#34;r&#34;) as stream:
            try:
                loot_filter = yaml.safe_load(stream)
                #print(loot_filter)
                &#39;&#39;&#39;
                for category in loot_filter:
                    print(str(category))
                    #for item in loot_filter.get(category):
                    print(loot_filter.get(category))
                &#39;&#39;&#39;
                    #for value in key:
                    #   print(str(value))
                self._loot_data = loot_filter
            except yaml.YAMLError as exc:
                print(exc)


    def get_map_d2api(self,seed):
        &#34;&#34;&#34;Get map values for input seed, using the piped api
        
        Args:
            seed (uint): current map seed
        &#34;&#34;&#34;

        p = Popen([&#34;d2mapapi_piped.exe&#34;, &#34;C:/Program Files/Diablo II&#34;], stdin=PIPE, stdout=PIPE)
        #seed
        s = (seed).to_bytes(4,&#39;little&#39;)
        #difficulty
        d = (2).to_bytes(4,&#39;little&#39;)
        #map id
        m = (79).to_bytes(4,&#39;little&#39;)
        
        p.stdin.write(s)
        p.stdin.write(d)
        p.stdin.write(m)
        data,err = p.communicate()
        sd = data.decode(&#39;ascii&#39;,&#39;ignore&#39;)
        #nasty 
        sd = sd[sd.find(&#39;{&#39;):]
        j = json.loads(sd,strict=False) 
        obj = j[&#39;objects&#39;]
        #get chests....
        chests = obj[&#39;580&#39;]
        #print(sd)
        map_offset_x = j[&#39;offset&#39;][&#39;x&#39;]
        map_offset_y = j[&#39;offset&#39;][&#39;y&#39;]
        self.chests = chests
        self.map_ox = map_offset_x
        self.map_oy = map_offset_y


    def get_map_json(self,seed, mapid:int, objectIDs:list=None):
        &#34;&#34;&#34;Summary
        
        Args:
            seed (TYPE): current map seed read from memory
            mapid (int): current in game map number
            objectIDs (list, optional): Description
        
        Returns:
            TYPE: Description
        &#34;&#34;&#34;

        #url for map api
        base_url=&#39;http://34.69.54.92:8000&#39;    
        url=base_url+&#39;/&#39;+str(seed)+f&#39;/2/{str(mapid)}/1&#39;

        log = (&#34;:: Got data from           -&gt; {}&#34;.format(url))
        log_color(log,fg_color=0,bg_color=traverse_color)
        resp = requests.get(url=url)
        j = resp.json()

        obj = j[&#39;objects&#39;]
        if objectIDs is not None:
            for objectID in objectIDs:
                self.responseList.append (obj[objectID])
        map_offset_x = j[&#39;offset&#39;][&#39;x&#39;]
        map_offset_y = j[&#39;offset&#39;][&#39;y&#39;]

        map_offset =np.array([map_offset_x,map_offset_y])


        self.map_offset = map_offset
        row = []
        for point in j[&#39;mapData&#39;]:
            if point != -1:
                row.append (point)
            else:
                self.grid.append (row)
                row = []              
        
        

        def split(a, sep):
            &#34;&#34;&#34;Summary
            
            Args:
                a (TYPE): Description
                sep (TYPE): Description
            
            Yields:
                TYPE: Description
            &#34;&#34;&#34;
            pos = i = 0
            while i &lt;len(a):
                if a[i:i+len(sep)] == sep:
                    yield a[pos:i]
                    pos = i = i+len(sep)
                else:
                    i += 1
            yield a[pos:i]

        points_of_interest = []
        map_objects = []

        if j != None:
            map_crop = j[&#39;crop&#39;]
            obj_str = &#34;|&#34;
            poi_str = &#34;|&#34;
            #these are mostly garbage and not useful, its map decorator stuff
            for key in j[&#39;objects&#39;]:
                value = j[&#39;objects&#39;][key]
                name = objects[int(key)]
                obj_str+=name+&#34;|&#34;
                #print(int(key),name)
                for instance in value:
                    offset_x =instance[&#39;x&#39;]
                    offset_y=instance[&#39;y&#39;]
                    pos =np.array([offset_x,offset_y])
                    pos_area = pos-map_offset
                    flag = 0
                    new_obj = {&#34;position&#34;:pos,&#34;flag&#34;:1,&#34;name&#34;:name,&#34;pos_area&#34;:pos_area}
                    map_objects.append(new_obj)
                    break

            #filter ut way points from the objects list
            for key in j[&#39;objects&#39;]:
                value = j[&#39;objects&#39;][key]
                name = objects[int(key)]
                if &#39;waypoint&#39; in name or &#39;Waypoint&#39; in name:
                    poi_str+=name+&#34;|&#34;
                    #print(int(key),name)
                    for instance in value:
                        offset_x =instance[&#39;x&#39;]
                        offset_y=instance[&#39;y&#39;]
                        pos =np.array([offset_x,offset_y])
                        pos_area = pos-map_offset
                        flag = 0
                        new_obj = {&#34;position&#34;:pos,&#34;flag&#34;:1,&#34;label&#34;:name,&#34;pos_area&#34;:pos_area}
                        points_of_interest.append(new_obj)
                        break

            #convert exits to a uniform format in poi
            for key in j[&#39;exits&#39;]:
                value = j[&#39;exits&#39;][key]
                name = areas[int(key)]
                poi_str+=name+&#34;|&#34;
                is_portal = value[&#39;isPortal&#39;]
                offset_x = value[&#39;offsets&#39;][0][&#39;x&#39;]
                offset_y = value[&#39;offsets&#39;][0][&#39;y&#39;]
                pos =np.array([offset_x,offset_y])
                pos_area = pos-map_offset
                new_poi = {&#34;position&#34;:pos,&#34;type&#34;:1,&#34;label&#34;:name,&#34;pos_area&#34;:pos_area}
                points_of_interest.append(new_poi)
            #convert npcs to a uniform format
            if j[&#39;npcs&#39;] is not None:
                for key in j[&#39;npcs&#39;]:
                    if int(key)&lt;738:
                        value = j[&#39;npcs&#39;][key]
                        name = get_mob_name[int(key)]
                        poi_str+=name+&#34;|&#34;
                        is_portal=False
                        is_npc=True
                        offset_x = value[0][&#39;x&#39;]
                        offset_y = value[0][&#39;y&#39;]
                        pos = np.array([offset_x,offset_y])
                        pos_area = pos-map_offset
                        new_poi = {&#34;position&#34;:pos,&#34;type&#34;:1,&#34;label&#34;:name,&#34;pos_area&#34;:pos_area}
                        points_of_interest.append(new_poi)

            map_id = j[&#39;id&#39;]
            map_data = j[&#39;mapData&#39;]
            #map_offset = j[&#39;offset&#39;]
            map_size = j[&#39;size&#39;]
            map_decode = list(split(map_data,sep=[-1]))

            self.area_origin = map_offset
            self.botty_data[&#39;area_origin&#39;] = map_offset

            nodes = []
            col_grid = []

            #map_decode.pop(-1)

            collision_grid = np.empty([int(map_size[&#39;height&#39;]),int(map_size[&#39;width&#39;])], dtype=np.uint8)
            
            if map_data != None:
                mini_map_w=int(map_size[&#39;width&#39;])
                mini_map_h=int(map_size[&#39;height&#39;])
                walkable = True
                y = 0
                for ele in map_decode:
                    x = 0
                    row = []
                    for i in range(len(ele)):
                        if walkable:
                            for j in range(ele[i]):
                                nodes.append([x,y,walkable])
                                row.append(0)
                                collision_grid[y][x] = 0
                                x+=1
                        if not walkable:
                            for j in range(ele[i]):
                                nodes.append([x,y,walkable])
                                row.append(-1)
                                collision_grid[y][x] = -1
                                x+=1

                        walkable = not walkable
                    y+=1
                    col_grid.append(row)
                    x=0
                    walkable = True
            

            new_map = {&#34;crop&#34;: map_crop,&#34;id&#34;: map_id,&#39;poi&#39;: points_of_interest,&#34;objects&#34;: map_objects,&#34;size&#34;: map_size,&#34;nodes&#34;:nodes,&#34;data&#34;:col_grid}

            log = (&#34;:: Loaded map              -&gt; {}&#34;.format(area_list[new_map[&#39;id&#39;]]))
            self.current_area=area_list[new_map[&#39;id&#39;]]
            self.botty_data[&#39;current_area&#39;]=area_list[new_map[&#39;id&#39;]]


            log_color(log,fg_color=0,bg_color=traverse_color)
            log = (&#34;:: Number of POI           -&gt; {}&#34;.format(len(points_of_interest)))
            log_color(log,fg_color=0,bg_color=traverse_color)
            log = (&#34;:: {}&#34;.format(poi_str))
            log_color(log,fg_color=0,bg_color=traverse_color)
            log = (&#34;:: Number of OBJ           -&gt; {}&#34;.format(len(map_objects)))
            log_color(log,fg_color=0,bg_color=traverse_color)
            log = (&#34;:: {}&#34;.format(obj_str))
            log_color(log,fg_color=0,bg_color=traverse_color)

            self.maps.append(new_map)
            self.botty_data[&#39;poi&#39;] = points_of_interest
            self.botty_data[&#39;objects&#39;] = map_objects
            self.botty_data[&#39;map&#39;]= collision_grid #np.array(collision_grid, dtype=np.uint8)
            return self.responseList

    def get_map_json_exit(self,seed, mapid:int, objectIDs:list=None):
        &#34;&#34;&#34;Summary
        
        Args:
            seed (TYPE): Description
            mapid (int): Description
            objectIDs (list, optional): Description
        
        Returns:
            TYPE: Description
        &#34;&#34;&#34;
        #map hosting
        base_url=&#39;http://34.69.54.92:8000&#39;
        url=base_url+&#39;/&#39;+str(seed)+f&#39;/2/{str(mapid)}/1&#39;
        #
        print(url)
        resp = requests.get(url=url)
        j = resp.json()
        #data = json.loads(data,strict=False)   
        with open(&#39;data.json&#39;, &#39;w&#39;) as f:
            json.dump(j, f)
        obj = j[&#39;exits&#39;]
        obj = obj [str(objectIDs)]
        
        #print(sd)
        map_offset_x = j[&#39;offset&#39;][&#39;x&#39;]
        map_offset_y = j[&#39;offset&#39;][&#39;y&#39;]
        #self.chests = chests
        self.map_ox = map_offset_x
        self.map_oy = map_offset_y
        return obj[&#39;offsets&#39;]

    def get_game_info_offset(self):
        &#34;&#34;&#34;Summary
        
        Returns:
            TYPE: Description
        &#34;&#34;&#34;
        #get game info offset
        pat = b&#39;\xE8....\x48\x8D\x0D....\x44\x88\x2D....&#39;
        pat_addr = pymem.pattern.pattern_scan_module(self.handle, self.module, pat)
        offset_buffer = self.process.read_int(pat_addr+8)
        game_info_offset = ((pat_addr - self.base)  + 7 -256 + 5 + offset_buffer)
        log = (&#34;:: Found game info offset  -&gt; {}&#34;.format(hex(game_info_offset)))
        log_color(log,fg_color=0,bg_color=traverse_color)
        return game_info_offset

    def get_hover_object_offset(self):
        &#34;&#34;&#34;Summary
        
        Returns:
            TYPE: Description
        &#34;&#34;&#34;
        pat = b&#39;\xc6\x84\xc2.....\x48\x8b\x74.&#39;
        pat_addr = pymem.pattern.pattern_scan_module(self.handle, self.module, pat, return_multiple=False)
        offset_buffer = self.process.read_bytes(pat_addr+3,4)
        offset_buffer_int = int.from_bytes(offset_buffer,&#39;little&#39;)
        hover_offset = (offset_buffer_int)-1
        log = (&#34;:: Found hover offset        -&gt; {}&#34;.format(hex(hover_offset)))
        log_color(log,fg_color=0,bg_color=traverse_color)
        return hover_offset

    def get_exp_offset(self):
        &#34;&#34;&#34;Summary
        
        Returns:
            TYPE: Description
        &#34;&#34;&#34;
        #expansion offset
        pat = b&#39;\xC7\x05........\x48\x85\xC0\x0F\x84....\x83\x78\x5C.\x0F\x84....\x33\xD2\x41&#39;
        #this works fine, shorter pattern
        pat = b&#39;\xC7\x05........\x48\x85\xC0\x0F\x84....&#39;
        pat_addr = pymem.pattern.pattern_scan_module(self.handle, self.module, pat)
        offset_buffer = self.process.read_int(pat_addr-4)
        exp_offset = ((pat_addr - self.base) + offset_buffer)
        log = (&#34;:: Found exp offset        -&gt; {}&#34;.format(hex(exp_offset)))
        log_color(log,fg_color=0,bg_color=traverse_color)
        return exp_offset

    def get_unit_offset(self):
        &#39;&#39;&#39;doc string
        
        Returns:
            TYPE: Description
        &#39;&#39;&#39;
        #unit table offset
        pat = b&#34;\x48\x8d.....\x8b\xd1&#34;
        pat_addr = pymem.pattern.pattern_scan_module(self.handle, self.module, pat)
        offset_buffer = self.process.read_int(pat_addr+3)
        player_offset = ((pat_addr - self.base) + 7 + offset_buffer)
        log = (&#34;:: Found player offset     -&gt; {}&#34;.format(hex(player_offset)))
        log_color(log,fg_color=0,bg_color=traverse_color)
        return player_offset


    def get_menu_data_offset(self):
        &#34;&#34;&#34;Summary
        
        Returns:
            TYPE: Description
        &#34;&#34;&#34;
        #unit table offset
        pat = b&#34;\x41\x0f\xb6\xac\x3f....&#34;
        pat_addr = pymem.pattern.pattern_scan_module(self.handle, self.module, pat)
        offset_buffer = self.process.read_int(pat_addr-5)
        ui_offset = ((pat_addr - self.base) + offset_buffer)
        log = (&#34;:: Found menu data offset  -&gt; {}&#34;.format(hex(ui_offset)))
        log_color(log,fg_color=0,bg_color=traverse_color)
        #ui_offset =  0x21F89AA
        return ui_offset

    def get_ui_settings_offset(self):
        &#34;&#34;&#34;Summary
        
        Returns:
            TYPE: Description
        &#34;&#34;&#34;
        #unit table offset
        pat = b&#34;\x40\x84\xed\x0f\x94\x05&#34;
        pat_addr = pymem.pattern.pattern_scan_module(self.handle, self.module, pat)
        offset_buffer = self.process.read_int(pat_addr+6)
        ui_offset = ((pat_addr - self.base) + 10 + offset_buffer)
        log = (&#34;:: Found ui offset         -&gt; {}&#34;.format(hex(ui_offset)))
        log_color(log,fg_color=0,bg_color=traverse_color)
        #ui_offset =  0x21F89AA
        return ui_offset

    def get_menu_vis_offset(self):
        &#34;&#34;&#34;Summary
        
        Returns:
            TYPE: Description
        &#34;&#34;&#34;
        #menu vis offset
        #pat = b&#39;\x8B\x05....\x89\x44\x24\x20\x74\x07&#39;
        #?? search less direct matches?
        pat = b&#39;\x8B\x05....\x89\x44.\x20\x74\x07&#39;
        pat_addr = pymem.pattern.pattern_scan_module(self.handle, self.module, pat)
        offset_buffer = self.process.read_int(pat_addr+2)
        #maybe dont need +6 here?
        menu_offset = ((pat_addr - self.base) + 6 + offset_buffer)
        log = (&#34;:: Found menu offset       -&gt; {}&#34;.format(hex(menu_offset)))
        log_color(log,fg_color=0,bg_color=traverse_color)
        return menu_offset

    def get_last_hovered(self):
        &#34;&#34;&#34;Summary
        &#34;&#34;&#34;
        offset = self.hoverd_offset
        is_hovered = self.process.read_int(offset+self.base+0x00)
        is_tooltip = self.process.read_int(offset+self.base+0x01)
        hovered_unit_type = self.process.read_int(offset+self.base+0x03)
        hoverd_id = self.process.read_uint(offset+self.base+0x08)

        for m in self.monsters:
            if hoverd_id == m[&#39;id&#39;] and is_hovered:
                print(m[&#39;name&#39;])
                break


    def get_player_offset(self,loops):
        &#34;&#34;&#34;Summary
        
        Args:
            loops (TYPE): Description
        
        Returns:
            TYPE: Description
        &#34;&#34;&#34;
        found = False
        #ui_offset = 0x21F89AA
        attempts=0
        name = &#34;&#34;
        new_offset=0

        for i in range(loops):
            attempts=i+0
            new_offset = (self.starting_offset)+(attempts-1)*8

            start_addr = self.base + new_offset

            player_unit = self.process.read_longlong(start_addr)
            #print (player_unit)
            while player_unit&gt;0:
                p_inventory = player_unit+0x90
                inventory = self.process.read_longlong(p_inventory)
                if(inventory):
                    log = (&#34;:: Found inventory offset  -&gt; {}&#34;.format(hex(self.base-inventory)))
                    log_color(log,fg_color=0,bg_color=traverse_color)
                    exp_char = self.process.read_ushort(self.base+self.exp_offset)
                    base_check = self.process.read_ushort(inventory+0x30) !=1
                    if(exp_char):
                        log = (&#34;:: Expansion char          -&gt; True&#34;)
                        log_color(log,fg_color=0,bg_color=traverse_color)
                        base_check = self.process.read_ushort(inventory+0x70) !=0

                if(base_check):
                    #print(&#34;base checks&#34;)
                    p_act = player_unit+0x20
                    act_addr = self.process.read_ulonglong(p_act)
                    map_seed_addr = act_addr +0x14
                    map_seed = self.process.read_uint(map_seed_addr)
                    self.map_seed = map_seed
                    #print(map_seed)
                    p_path = player_unit+0x38
                    path_addr = self.process.read_longlong(p_path)

                    x_pos = self.process.read_ushort(path_addr+0x02)
                    #print (x_pos)
                    y_pos = self.process.read_ushort(path_addr+0x06)
                    #print (y_pos)
                    p_unit_data = player_unit +0x10
                    try:
                        player_name_addr = self.process.read_longlong(p_unit_data)
                    except:
                        pass
                    p_name = &#34;&#34;
                    #
                    for i in range(16):
                        name = name + str(chr(self.process.read_uchar(player_name_addr+i-1)))

                    if(x_pos&gt; 0 and y_pos &gt;0 and len(str(map_seed))&gt;6):
                        if loops &gt; 1:
                            log = (&#34;:: Found player name       -&gt; {}&#34;.format(name))
                            log_color(log,fg_color=0,bg_color=traverse_color)
                            log = (&#34;:: Found map seed          -&gt; {}&#34;.format(map_seed))
                            log_color(log,fg_color=0,bg_color=traverse_color)
                        new_offset = new_offset+0
                        found = True
                        self.player_unit = new_offset
                        self.path_addr = path_addr
                        return True

                new_offset = (player_unit+0x150)-self.base
                try:
                    player_unit = self.process.read_longlong(player_unit +0x150)
                except:
                    pass


    def get_current_level(self):
        &#34;&#34;&#34;Summary
        &#34;&#34;&#34;
        startingAddress = self.base + self.player_unit
        playerUnit = self.process.read_ulonglong(startingAddress)
        pUnitData = playerUnit + 0x10
        #get the level number
        pPathAddress = playerUnit + 0x38
        pPath = self.process.read_ulonglong(pPathAddress)
        pRoom1 = pPath + 0x20
        pRoom1Address = self.process.read_ulonglong(pRoom1)
        pRoom2 = pRoom1Address + 0x18
        pRoom2Address = self.process.read_ulonglong(pRoom2)
        pLevel = pRoom2Address + 0x90
        pLevelAddress = self.process.read_ulonglong(pLevel)
        dwLevelNo = pLevelAddress + 0x1F8
        levelNo = self.process.read_uint(dwLevelNo)
        self._level_addr = dwLevelNo
        self.level = levelNo

    def find_info(self):
        &#34;&#34;&#34;Summary
        
        Returns:
            TYPE: Description
        &#34;&#34;&#34;
        startingAddress = self.base + self.player_unit
        playerUnit = self.process.read_ulonglong(startingAddress)

        pUnitData = playerUnit + 0x10
        try:
            playerNameAddress = self.process.read_ulonglong(pUnitData)
        except:
            print(&#34;FAILED&#34;)
            print(&#34;FAILED&#34;)
            print(&#34;FAILED&#34;)
            print(&#34;FAILED&#34;)
            print(&#34;FAILED&#34;)
            print(&#34;FAILED&#34;)
            return False
            pass
        if(playerNameAddress):
            playerName = self.process.read_string(playerNameAddress)
        
        pStatsListEx = self.process.read_ulonglong(playerUnit+0x88)
        statPtr = self.process.read_ulonglong(pStatsListEx+0x30)
        statCount = self.process.read_ulonglong(pStatsListEx+0x38)

        for i in range(statCount):

            statOffset = (i-1) * 8
            statEnum = self.process.read_ushort(statPtr + 0x2 + statOffset)
            if (statEnum == 12):
                self.player_level = self.process.read_uint(statPtr + 0x4 + statOffset)
            if (statEnum == 13):
                self.experience = self.process.read_uint(statPtr + 0x4 + statOffset)
            if (statEnum == 6):
                hp = self.process.read_uint(statPtr + 0x4 + statOffset)
                self.hp = hp &gt;&gt; 8
            if (statEnum == 7):
                maxhp = self.process.read_uint(statPtr + 0x4 + statOffset)
                self.max_hp = maxhp &gt;&gt; 8
        log = &#34;:: LVL:&#34; +str(self.player_level)+&#34;, HP:&#34;+str(self.max_hp)+&#34;, EXP:&#34;+str(self.experience)
        log_color(log,fg_color=0,bg_color=traverse_color)

        #get the level number
        pPathAddress = playerUnit + 0x38
        pPath = self.process.read_ulonglong(pPathAddress)
        pRoom1 = pPath + 0x20
        pRoom1Address = self.process.read_ulonglong(pRoom1)
        pRoom2 = pRoom1Address + 0x18
        pRoom2Address = self.process.read_ulonglong(pRoom2)
        pLevel = pRoom2Address + 0x90
        pLevelAddress = self.process.read_ulonglong(pLevel)
        dwLevelNo = pLevelAddress + 0x1F8
        levelNo = self.process.read_uint(dwLevelNo)
        self._level_addr = dwLevelNo
        
        
        self.level = levelNo
        log = (&#34;:: current level      -&gt; &#34;+str(area_list[levelNo]))
        log_color(log,fg_color=0,bg_color=traverse_color)

        if not levelNo:
            log = &#34;!! Did not find level num using player offset&#34; +str(playerOffset)
            log_color(log,fg_color=0,bg_color=traverse_color)


        #get the map seed
        pAct = playerUnit + 0x20
        actAddress = self.process.read_ulonglong(pAct)


        if actAddress:
            mapSeedAddress = actAddress + 0x14
            if mapSeedAddress:
                mapSeed = self.process.read_uint(mapSeedAddress)
                self.map_seed = mapSeed
                #print(&#34;Found seed&#34;+str(mapSeed)+ &#34;at address&#34; +str(mapSeedAddress))
            else:
                log = (&#34;!! Did not find map seed at address&#34;+(mapSeedAddress))
                log_color(log,fg_color=0,bg_color=traverse_color)

        #get the level number
        actAddress = self.process.read_ulonglong(pAct)

        pActUnk1 = actAddress + 0x70
        aActUnk2 = self.process.read_ulonglong(pActUnk1)
        aDifficulty = aActUnk2 + 0x830
        difficulty = self.process.read_ushort(aDifficulty)
        self.difficulty=difficulty

        if difficulty==0:
            log = (&#34;:: current difficulty      -&gt; Normal&#34;)
            log_color(log,fg_color=0,bg_color=traverse_color)
        if difficulty==1:
            log = (&#34;:: current difficulty      -&gt; Nightmare&#34;)
            log_color(log,fg_color=0,bg_color=traverse_color)
        if difficulty==2:
            log = (&#34;:: current difficulty      -&gt; Hell&#34;)
            log_color(log,fg_color=0,bg_color=traverse_color)

    def normalized_p(self):
        &#34;&#34;&#34;Summary
        &#34;&#34;&#34;
        self.np_x = float(self.map_ox)/float(self.process.read_ushort(self.path_addr+0x02))
        self.np_y = float(self.map_oy)/float(self.process.read_ushort(self.path_addr+0x06))

    def get_ppos(self):
        &#34;&#34;&#34;Summary
        &#34;&#34;&#34;
        x = self.process.read_ushort(self.path_addr+0x02)
        y = self.process.read_ushort(self.path_addr+0x06)
        self.player_world_pos = np.array([x,y])
        self.botty_data[&#39;player_pos_area&#39;] =self.player_world_pos -self.area_origin
        self.botty_data[&#39;player_pos_world&#39;] = self.player_world_pos

    def chest_dist(self):
        &#39;&#39;&#39;doc string&#39;&#39;&#39;
        self.x_pos = self.process.read_ushort(self.path_addr+0x02)-self.map_ox
        self.y_pos = self.process.read_ushort(self.path_addr+0x06)-self.map_oy

        for chest in self.chests:
            chest_loc_x = chest[&#39;x&#39;]
            chest_loc_y = chest[&#39;y&#39;]
            odist = math.dist([chest_loc_x,chest_loc_y],[self.x_pos,self.y_pos])
            #print(&#39;dist -&gt; &#39;+ str(odist))
            #print(&#39;current pos -&gt;  &#39;+str(self.x_pos)+&#39;,&#39;+str(self.y_pos))

    def find_objects(self, file_number:int):
        &#34;&#34;&#34;Summary
        
        Args:
            file_number (int): Description
        
        Returns:
            TYPE: Description
        &#34;&#34;&#34;
        self.super_chests =[]
        object_offset = self.starting_offset + (2 * 1024)
        attempts=0


        for i in range(256):
            attempts=i+0
            new_offset = object_offset + (8 * (i-1))
            item_addr = self.base + new_offset
            object_unit = self.process.read_longlong(item_addr)

            #print(i)
            while (object_unit&gt;0):
                item_type = self.process.read_int(object_unit+0x00)
                pRoomnext = self.process.read_ulonglong(object_unit+0x158)
                #pRoomEx = self.process.read_ulonglong (pRoomnext+0x18)
                if(item_type==2):
                    file_no = self.process.read_int(object_unit+0x04)
                    if file_no == file_number:
                        print (&#34;Object found&#34;)
                        p_unit_data = self.process.read_ulonglong(object_unit + 0x10)
                        mode = self.process.read_uint (object_unit + 0x0C)
                        #pObjectTxt = self.process.read_ulonglong(p_unit_data)
                        #print(str(pObjectTxt))
                        #sObjectTxt = self.process.read_string(p_unit_data, 16)
                        #shrineTxt = self.process.read_string(p_unit_data + 0x0c, 16)
                        pPath = self.process.read_ulonglong(object_unit + 0x38)  
                        objectx = self.process.read_ushort(pPath + 0x10)
                        objecty = self.process.read_ushort(pPath + 0x14)
                        self.x_pos = self.process.read_ushort(self.path_addr+0x02)
                        self.y_pos = self.process.read_ushort(self.path_addr+0x06)
                        odist = math.dist([objectx,objecty],[self.x_pos,self.y_pos])
                        #print(self.y_pos)
                        #print(self.x_pos)
                        print(txt_obj_name[file_no-1] + &#34;&#34;+ str(str(file_no)))    
                        print(&#39;dist -&gt; &#39;+ str(odist))
                        obj = Object (objectx, objecty, mode)
                        return obj



                object_unit = self.process.read_longlong(object_unit + 0x150)
    




    def ui_status(self):
        &#34;&#34;&#34;Summary
        &#34;&#34;&#34;
        InGame = False
        Inventory =  False
        Character =  False
        SkillSelect = False
        SkillTree = False
        Chat = False
        NpcInteract =  False
        EscMenu = False
        Map = False
        NpcShop = False
        QuestLog = False
        Waypoint = False
        Party = False
        Stash = False
        Cube = False
        AltPick = False
        Potions=False

        offset = self.ui_settings_offset
        ui = self.base + offset
        item_pick = self.process.read_ushort(ui+2)
        quit_menu = self.process.read_bytes(ui-0x01,1)
        quit_menu_int = int.from_bytes(quit_menu,&#34;little&#34;)
        quest_menu = self.process.read_bytes(ui+0x04,1)
        quest_menu_int = int.from_bytes(quest_menu,&#34;little&#34;)
        skill_menu = self.process.read_bytes(ui-0x06,1)
        skill_menu_int = int.from_bytes(skill_menu,&#34;little&#34;)
        char_menu = self.process.read_bytes(ui-0x08,1)
        char_menu_int = int.from_bytes(char_menu,&#34;little&#34;)
        stash_menu = self.process.read_bytes(ui-0x19+0x28-1,1)
        stash_menu_int = int.from_bytes(stash_menu,&#34;little&#34;)
        npc_menu = self.process.read_bytes(ui+1,1)
        npc_menu_int = int.from_bytes(npc_menu,&#34;little&#34;)
        inv_menu = self.process.read_bytes(ui-0x09,1)
        inv_menu_int = int.from_bytes(inv_menu,&#34;little&#34;)
        merc_menu = self.process.read_ushort(ui+0x14)
        party_menu = self.process.read_bytes(ui+0x0b,1)
        party_menu_int = int.from_bytes(party_menu,&#34;little&#34;)
        waypoint_menu = self.process.read_bytes(ui+0x09,1)
        #ugh why
        waypoint_menu_int = int.from_bytes(waypoint_menu,&#34;little&#34;)
        in_game = self.process.read_bytes(ui+0x08,1)
        in_game_int = int.from_bytes(in_game,&#34;little&#34;)

        cube_menu = self.process.read_bytes(ui-0x19+0x28,1)
        cube_menu_int = int.from_bytes(cube_menu,&#34;little&#34;)
        
        map_menu = self.process.read_bytes(ui-0x19+0x28-15,1)
        map_menu_int = int.from_bytes(map_menu,&#34;little&#34;)

        potion_menu = self.process.read_bytes(ui-0x19+0x28+1,1)
        potion_menu_int = int.from_bytes(potion_menu,&#34;little&#34;)

        npc_interact = self.process.read_bytes(ui-0x19+0x28-0x11,1)
        npc_interact_int = int.from_bytes(npc_interact,&#34;little&#34;)
        

        chat = self.process.read_bytes(ui-0x19+0x28-0x11-3,1)
        chat_int = int.from_bytes(chat,&#34;little&#34;)

        if chat_int:
            Chat=True
            #print(&#34;chattings&#34;)
        if npc_interact_int:
            NpcInteract=True
            #print(&#39;talkign to npc&#39;)
        if potion_menu_int:
            Potions=True
            #print(&#39;pOtioOn is active&#39;)
        if map_menu_int:
            Map=True
            #print(&#39;Map is active&#39;)
        if cube_menu_int:
            Cube=True
            #print(&#39;Cube is active&#39;)
        if in_game_int:
            #print(&#39;in game&#39;) #works
            InGame=True
        if stash_menu_int:
            #print(&#39;stash menu is  active&#39;)
            Stash=True
        if npc_menu_int:
            #print(&#39;npc menu is  active&#39;)
            NpcShop=True
        if party_menu_int:
            #print(&#39;party menu is  active&#39;)
            Party=True
        if inv_menu_int:
            #print(&#39;inv menu is  active&#39;)
            Inventory=True
        if waypoint_menu_int:
            #print(&#39;waypoint menu is  active&#39;)
            Waypoint=True
        if quit_menu_int:
            EscMenu=True
            #print(&#39;!!!quit menu is  active&#39;)
        if item_pick:
            AltPick=True
            #print(&#39;item pick is active&#39;)
        if quest_menu_int:
            QuestLog=True
            #print(&#39;Quest log is active&#39;)
        if char_menu_int:
            Character=True
            #print(&#39;Char menu is active&#39;)
        if skill_menu_int:
            SkillTree=True
            #print(&#39;Skill tree is active&#39;)

        self.menus =    {&#39;InGame&#39;: InGame,
                        &#39;Inventory&#39;: Inventory,
                        &#39;Character&#39;: Character,
                        &#39;SkillSelect&#39;: SkillSelect,
                        &#39;SkillTree&#39;: SkillTree,
                        &#39;Chat&#39;: Chat,
                        &#39;NpcInteract&#39;: NpcInteract,
                        &#39;EscMenu&#39;: EscMenu,
                        &#39;Map&#39;: Map,
                        &#39;NpcShop&#39;: NpcShop,
                        &#39;QuestLog&#39;: QuestLog,
                        &#39;Waypoint&#39;: Waypoint,
                        &#39;Party&#39;: Party,
                        &#39;Stash&#39;: Stash,
                        &#39;Cube&#39;: Cube,
                        &#39;AltPick&#39;:AltPick,
                        &#39;Potions&#39;:Potions
                        }


    def find_items(self):
        &#34;&#34;&#34;Summary
        &#34;&#34;&#34;
        items = []
        item_offset = self.starting_offset + (4*1024)

        for i in range(256):


            new_offset = item_offset +(8 *(i))
            item_addr = self.base + new_offset
            item_unit = self.process.read_longlong(item_addr)

            while (item_unit&gt;0):
                item_type = self.process.read_uint(item_unit+0x00)
                if item_type == 4:
                    txt_file_no = self.process.read_uint(item_unit+0x04)
                    item_loc = self.process.read_uint(item_unit+0x0C)

                    # item loc 0 = inventory, 1 = equipped, 2 in belt, 3 on ground, 4 cursor, 5 dropping ,6 socketed
                    if item_loc == 3 or item_loc == 5:
                        #print(&#34;item on ground&#34;)
                        p_unit_data = self.process.read_longlong(item_unit + 0x10)
                        #itemQuality - 5 is set, 7 is unique (6 rare, 4, magic)
                        item_quality = self.process.read_uint(p_unit_data)
                        p_path = self.process.read_longlong(item_unit+0x38)
                        item_x = self.process.read_ushort(p_path+0x10)
                        item_y = self.process.read_ushort(p_path+0x14)

                        p_stat_list_ex = self.process.read_longlong(item_unit + 0x88)
                        stat_ptr = self.process.read_longlong(p_stat_list_ex + 0x30)
                        stat_count = self.process.read_longlong(p_stat_list_ex + 0x38)
                        num_sockets = 0

                        for j in range(stat_count):
                            #print(&#34;checking for sockets&#34;)
                            stat_offset = (j)*8
                            stat_enum = self.process.read_ushort(stat_ptr+0x2+stat_offset)
                            if stat_enum == 194:
                                num_sockets = self.process.read_uint(stat_ptr+0x4+stat_offset)
                                #print(&#39;number of sockets -&gt;&#39;+str(num_sockets))
                                break

                        flags = self.process.read_uint(p_unit_data+0x18)


                        identified = False
                        if(0x00000010 &amp; flags):
                            identified = True
                            #print(&#34;id&#39;d&#34;)
                        ethereal = False
                        if(0x00400000 &amp; flags):
                            ethereal = True

                        quality=&#39;Any&#39;
                        if item_quality == 1:
                            quality = &#39;Inferior&#39;
                        if item_quality == 2:
                            quality = &#39;Normal&#39;
                        if item_quality == 3:
                            quality = &#39;Superior&#39;
                        if item_quality == 4:
                            quality = &#39;Magic&#39;
                        if item_quality == 5:
                            quality = &#39;Set&#39;
                        if item_quality == 6:
                            quality = &#39;Rare&#39;
                        if item_quality == 7:
                            quality = &#39;Unique&#39;
                        if item_quality == 8:
                            quality = &#39;Crafted&#39;
                        if item_quality == 9:
                            quality = &#39;Tempered&#39;

                        #print(txt_file_no)
                        if txt_file_no &gt;= 557 and txt_file_no &lt;= 586 or txt_file_no&gt;= 597 and txt_file_no&lt;= 601:
                            quality = &#39;Gem&#39;
                        if txt_file_no &gt;= 610 and txt_file_no &lt;= 642:
                            quality = &#39;Rune&#39;

                        item = (txt_file_no,quality,item_name[txt_file_no],item_quality,item_loc,item_x,item_y,num_sockets)


                        for category in self._loot_data:
                            q_match = 0
                            i_match = 0
                            loot_check = 0

                            data = self._loot_data.get(category)
                            quality_match = [&#39;Any&#39;]
                            item_match = [&#39;Any&#39;]
                            try:
                                quality_match = data[&#39;quality&#39;]
                            except:
                                quality_match = [&#39;Inferior&#39;,&#39;Normal&#39;,&#39;Superior&#39;,&#39;Magic&#39;,&#39;Set&#39;,&#39;Rare&#39;,&#39;Unique&#39;,&#39;Crafted&#39;,&#39;Tempered&#39;,&#39;Gem&#39;,&#39;Rune&#39;]
                                pass
                            try:
                                item_match = data[&#39;items&#39;]
                            except:
                                item_match = [&#39;Any&#39;]
                                pass

                            for q in quality_match:
                                if quality in q:
                                    q_match=1

                            for i in item_match:
                                item_to_check = str(item_name[txt_file_no])
                                if num_sockets&gt;0:
                                    item_to_check = str(item_name[txt_file_no])+&#39;,&#39;+str(num_sockets)
                                if item_to_check in i or item_match[0] is &#39;Any&#39;:
                                    i_match=1

                            if q_match and i_match:
                                loot_check =1

                            try:
                                if data[&#39;ignoreidentified&#39;] is True and identified:
                                    loot_check=0
                            except:
                                pass

                            if loot_check:
                                print(&#34;good to loot&#34;)
                                #self._move_to_mem(item_x,item_y)
                                print(item_name[txt_file_no])


                        #hard coded test for thul and ist
                        #if txt_file_no == 619 or txt_file_no == 620 or txt_file_no == 633:
                        #   self._move_to_mem(item_x,item_y)
                        #   print(items_list.item_name[txt_file_no])

                    if item_loc == 4:
                        #print(&#34;item on cursor&#34;)
                        p_unit_data = self.process.read_longlong(item_unit + 0x10)
                        item_quality = self.process.read_longlong(p_unit_data)
                        p_path = self.process.read_longlong(item_unit+0x38)
                        item_x = self.process.read_ushort(p_path+0x10)
                        item_y = self.process.read_ushort(p_path+0x14)
                        #print(item_loc,item_type,txt_file_no)
                        #print(item_x,item_y)
                        

                item_unit = self.process.read_longlong(item_unit + 0x150)


    def find_mobs(self):
        &#34;&#34;&#34;Summary
        &#34;&#34;&#34;
        monstersOffset = self.starting_offset + 1024
        mobs = []
        loc_monsters = []
        skel_count =0
        mage_count =0
        golem_count = &#39;none&#39;

        for i in range(128):
            newOffset = monstersOffset + (8 * (i - 1))
            mobAddress = self.base + newOffset
            mobUnit = self.process.read_longlong(mobAddress)
            
            while (mobUnit&gt; 0):

                txtFileNo = self.process.read_uint(mobUnit + 0x04)
                hide_check = 0
                try:
                    hide_npc[txtFileNo]
                except:
                    #no key 
                    pass

                if not hide_check:

                    mobTypeString = &#34;&#34;
                    #
                    unit_data = self.process.read_ulonglong(mobUnit + 0x10)
                    mob_type = self.process.read_bytes(unit_data+0x1a,1)
                    mob_type_int = int.from_bytes(mob_type,&#34;little&#34;)

                    if mob_type_int == 0:
                        mobTypeString = &#39;None&#39;
                    if mob_type_int == 1:
                        mobTypeString = &#39;Other&#39;
                    if mob_type_int  == 10:
                        mobTypeString = &#39;SuperUnique&#39;
                    if mob_type_int == 8:
                        mobTypeString = &#39;Unique&#39;
                    if mob_type_int == 12:
                        mobTypeString = &#39;Champion&#39;                        
                    if mob_type_int == 16:
                        mobTypeString = &#39;Minion&#39;
                    if mob_type_int == 32:
                        mobTypeString = &#39;Possessed?&#39;
                    if mob_type_int == 76:
                        mobTypeString = &#39;Ghostly&#39;
                    if mob_type_int == 64:
                        mobTypeString = &#39;Multishot?&#39;
                        
                    

                    unitId = self.process.read_uint(mobUnit + 0x08)
                    mode = self.process.read_uint(mobUnit + 0x0c)
                    iscorpse = self.process.read_uchar (mobUnit + 0x1A6)
                    interactable = self.process.read_uchar (mobUnit + 0x1A6+4)
                    pUnitData = self.process.read_longlong(mobUnit + 0x10)
                    pPath = self.process.read_longlong(mobUnit + 0x38)
                
                    isUnique = self.process.read_ushort(pUnitData + 0x18)
                    #????
                    uniqueNo = self.process.read_ushort(pUnitData + 42)

                    monx = self.process.read_ushort(pPath + 0x02)
                    mony = self.process.read_ushort(pPath + 0x06)
                    xPosOffset = self.process.read_ushort(pPath + 0x00) 
                    yPosOffset = self.process.read_ushort(pPath + 0x04)
                    xPosOffset = xPosOffset / 65536
                    yPosOffset = yPosOffset / 65536
                    monx = monx + xPosOffset
                    mony = mony + yPosOffset

                    #+026?
                    #+017 - eLastMode
                    #+018 - dwDuriel - set only for duriel
                    #+01C - MonUModList[9] - nine bytes holding the Ids for each MonUMod assigned to the unit
                    #+026 - bossNo - hcIdx from superuniques.txt for superuniques (word)
                    #+028 - pAiGeneral
                    BossLineID = self.process.read_ushort(unit_data + 0x2A) 

                    isBoss = 0
                    textTitle = None

                    textTitle = get_mob_name[txtFileNo]

                    if mob_type_int == 10:
                        try:
                            textTitle = super_unique_names[uniqueNo]
                        except:
                            pass
                    if mob_type_int == 8:
                        try:
                            textTitle = get_mob_name[txtFileNo]
                        except:
                            pass
                        isBoss= 1
    

                    #get immunities
                    pStatsListEx = self.process.read_longlong(mobUnit + 0x88)
                    ownerType = self.process.read_uint(pStatsListEx + 0x08)
                    ownerId = self.process.read_uint(pStatsListEx + 0x0C)

                    statPtr = self.process.read_longlong(pStatsListEx + 0x30)
                    statCount = self.process.read_longlong(pStatsListEx + 0x38)

                    #if(isUnique):
                        #print(textTitle,mobTypeString, mob_type_int)

                    &#39;&#39;&#39;
                    #these need to be added

                    loadEncText(auraStrings[33], cfg-&gt;MightAura);
                    loadEncText(auraStrings[35], cfg-&gt;HolyFireAura);
                    loadEncText(auraStrings[40], cfg-&gt;BlessedAimAura);
                    loadEncText(auraStrings[43], cfg-&gt;HolyFreezeAura);
                    loadEncText(auraStrings[46], cfg-&gt;HolyShockAura);
                    loadEncText(auraStrings[28], cfg-&gt;ConvictionAura);
                    loadEncText(auraStrings[49], cfg-&gt;FanaticismAura);

                    loadEncText(enchantStrings[5], cfg-&gt;encTxtExtraStrong);
                    loadEncText(enchantStrings[6], cfg-&gt;encTxtExtraFast);
                    loadEncText(enchantStrings[7], cfg-&gt;encTxtCursed);
                    loadEncText(enchantStrings[8], cfg-&gt;encTxtMagicResistant);
                    loadEncText(enchantStrings[9], cfg-&gt;encTxtFireEnchanted);
                    loadEncText(enchantStrings[17], cfg-&gt;encTxtLigntningEnchanted);
                    loadEncText(enchantStrings[18], cfg-&gt;encTxtColdEnchanted);
                    loadEncText(enchantStrings[25], cfg-&gt;encTxtManaBurn);
                    loadEncText(enchantStrings[26], cfg-&gt;encTxtTeleportation);
                    loadEncText(enchantStrings[27], cfg-&gt;encTxtSpectralHit);
                    loadEncText(enchantStrings[28], cfg-&gt;encTxtStoneSkin);
                    loadEncText(enchantStrings[29], cfg-&gt;encTxtMultipleShots);
                    loadEncText(enchantStrings[37], cfg-&gt;encTxtFanatic);
                    loadEncText(enchantStrings[39], cfg-&gt;encTxtBerserker);

                    &#39;&#39;&#39;
                    #
                    immunities = {&#39;physical&#39;: 0,&#39;magic&#39;: 0,&#39;fire&#39;: 0,&#39;light&#39;: 0,&#39;cold&#39;: 0,&#39;poison&#39;: 0}
                    auras = {&#39;MightAura&#39;: 0,&#39;HolyFireAura&#39;: 0, &#39;BlessedAimAura&#39;: 0, &#39;HolyFreezeAura&#39;: 0, &#39;HolyShockAura&#39;: 0,&#39;ConvictionAura&#39;: 0,&#39;FanaticismAura&#39;:0}
                    enchants = {&#39;ExtraStrong&#39;: 0,&#39;ExtraFast&#39;: 0, &#39;Cursed&#39;: 0, &#39;MagicResistant&#39;: 0, &#39;FireEnchanted&#39;: 0,&#39;LigntningEnchanted&#39;: 0,&#39;ColdEnchanted&#39;:0,&#39;ManaBurn&#39;:0,&#39;Teleportation&#39;:0,&#39;SpectralHit&#39;:0,&#39;StoneSkin&#39;:0,&#39;MultipleShots&#39;:0,&#39;Berserker&#39;:0}

                    for s in range(statCount):
                        offset = (s -1) * 8
                        statParam = self.process.read_ushort(statPtr + offset)
                        statEnum = self.process.read_ushort(statPtr + 0x2 + offset)
                        statValue = self.process.read_uint(statPtr + 0x4 + offset)
                        if (statValue&gt;= 100):
                            if statEnum == 36:
                                immunities[&#34;physical&#34;] = 1 #physical immune      
                            if statEnum == 37:
                                immunities[&#34;magic&#34;] = 1    
                            if statEnum == 39:
                                immunities[&#34;fire&#34;] = 1
                            if statEnum == 41:
                                immunities[&#34;light&#34;] = 1  
                            if statEnum == 43:
                                immunities[&#34;cold&#34;] = 1
                            if statEnum == 45:
                                immunities[&#34;poison&#34;] = 1 
                    self.get_ppos()
                    dist = math.dist(self.player_world_pos,np.array([int(monx),int(mony)]))

                    abs_screen_position = world_to_abs(np.array([monx,mony]), self.player_world_pos)
                    mob = {&#39;position&#39;: np.array([int(monx),int(mony)]),&#39;dist&#39;: dist, &#39;abs_screen_position&#39;: abs_screen_position, &#39;immunities&#39;: immunities, &#39;unit_type&#39;: &#39;Monster&#39;, &#39;type&#39;: mobTypeString, &#39;id&#39;: unitId, &#39;name&#39;: textTitle, &#39;mode&#39;: mode, &#39;number&#39;: txtFileNo, &#39;super_unique&#39;:isUnique,&#39;boss&#39;:isBoss,&#39;is_corpse&#39;:iscorpse, &#39;interactable&#39;:interactable }
                    
                    # filter out some stuff and calculate summon count
                    if textTitle is not None:
                        if &#39;ClayGolem&#39; in mob[&#39;name&#39;]:
                            if mob[&#39;mode&#39;] != 12:
                                golem_count = &#34;ClayGolem&#34;

                        elif &#39;FireGolem&#39; in mob[&#39;name&#39;]:
                            if mob[&#39;mode&#39;] != 12:
                                golem_count = &#34;FireGolem&#34;

                        elif &#39;BloodGolem&#39; in mob[&#39;name&#39;]:
                            if mob[&#39;mode&#39;] != 12:
                                golem_count = &#34;BloodGolem&#34;

                        elif &#39;IronGolem&#39; in mob[&#39;name&#39;]:
                            if mob[&#39;mode&#39;] != 12:
                                golem_count = &#34;IronGolem&#34;

                        elif &#39;NecroMage&#39; == mob[&#39;name&#39;]:
                            if mob[&#39;mode&#39;] != 12:
                                mage_count +=1

                        elif &#39;NecroSkeleton&#39; == mob[&#39;name&#39;]:
                            if mob[&#39;mode&#39;] != 12:
                                skel_count +=1
                        elif &#39;Rouge&#39; in mob[&#39;name&#39;]:
                            pass
                        elif &#39;Gaurd&#39; in mob[&#39;name&#39;]:
                            pass
                        elif &#39;Alkor&#39; in mob[&#39;name&#39;]:
                            pass
                        elif &#39;a trap&#39; in mob[&#39;name&#39;]:
                            pass
                        elif &#39;IronWolf&#39; in mob[&#39;name&#39;]:
                            pass
                        elif &#39;Malachai&#39; in mob[&#39;name&#39;]:
                            pass
                        elif mob[&#39;name&#39;] == &#39;&#39;:
                            pass
                        elif &#39;?&#39; in mob[&#39;name&#39;]:
                            pass
                        elif &#39;Barricade&#39; in mob[&#39;name&#39;]:
                            pass
                        else:
                            loc_monsters.append(mob)

                            #if dist&lt;5:
                            #    print(mob[&#39;name&#39;])

                            #    print(mob[&#39;id&#39;])
                            #    print(mob[&#39;number&#39;])

                #get next mob
                mobUnit = self.process.read_longlong(mobUnit + 0x150)
        self.monsters = loc_monsters
        self.botty_data[&#39;monsters&#39;] = loc_monsters
        if self.botty_data[&#39;necroSkel&#39;] != skel_count:
            self.botty_data[&#39;necroSkel&#39;]=skel_count
        if self.botty_data[&#39;necroMage&#39;] != mage_count:
            self.botty_data[&#39;necroMage&#39;]=mage_count
        if self.botty_data[&#39;necroGol&#39;]!=golem_count:
            self.botty_data[&#39;necroGol&#39;] = golem_count



if __name__ == &#34;__main__&#34;:
    
    #get new starting offsets
    d2 = d2r_proc()

    #check if we are in game
    ui = d2.base + d2.ui_settings_offset
    igo =0x08
    in_game = d2.process.read_bytes(ui+igo,1)
    in_game = int.from_bytes(in_game,&#34;little&#34;)
    current_level = -1

    new_session = 1
    #constant update
    while 1:
        if new_session==1 and in_game==1:

            d2.get_player_offset(128)
            d2.find_info()
            d2.get_ppos()

            d2.get_map_json(str(d2.map_seed), d2.level)
            d2.read_loot_cfg()
            new_session=0
            current_level = d2.level

        if in_game==1:
            try:
                d2.get_current_level()
            except:
                pass
            if current_level != d2.level:
                d2.get_map_json(str(d2.map_seed), d2.level)
                current_level = d2.level
            d2.get_ppos()
            d2.find_mobs()
            d2.ui_status()
            d2.find_items()
            d2.botty_data[&#39;menus&#39;] = d2.menus

            d2.get_last_hovered()
        if in_game == 0:
            new_session=1
        in_game = d2.process.read_bytes(ui+igo,1)
        in_game = int.from_bytes(in_game,&#34;little&#34;)
        time.sleep(.02)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="d2read.proc.proc"><code class="flex name class">
<span>class <span class="ident">proc</span></span>
</code></dt>
<dd>
<div class="desc"><p>Some doc string</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>c</code></strong> :&ensp;<code>str</code></dt>
<dd>some a.</dd>
<dt><strong><code>b</code></strong> :&ensp;<code>str</code></dt>
<dd>some b.</dd>
<dt><strong><code>a</code></strong> :&ensp;<code>str</code></dt>
<dd>some c.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>something I hope</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class proc:

    def __init__(self):

        &#39;&#39;&#39;Some doc string
        Args:
            c (str): some a.
            b (str): some b.
            a (str): some c.
        Returns:
            something I hope
        &#39;&#39;&#39;

        self.pm = None
        self.pm = pymem.Pymem(&#34;D2R.exe&#34;)
        self.process = self.pm
        self.player_unit = 0
        self.handle = self.pm.process_handle
        self.module = pymem.process.module_from_name(self.handle,&#34;D2R.exe&#34;)
        self.base = self.pm.base_address
        self.exp_offset = self.get_exp_offset()
        self.starting_offset = self.get_unit_offset()
        self.game_info_offset = self.get_game_info_offset()
        self.ui_settings_offset = self.get_ui_settings_offset()
        self.menu_vis_offset = self.get_menu_vis_offset()
        self.menu_data_offset = self.get_menu_data_offset()
        self.hoverd_offset = self.get_hover_object_offset()
        self.responseList = []
        self.map_offset = None
        self.grid=[]
        self.level = 1
        self.player_world_pos = np.array([0,0])
        self.area_origin = np.array([0,0])

        self.in_game = 0
        self.loaded = 0

        #data to include
        self.monsters = []
        self.poi = []
        self.items = []
        self.map = []
        self.current_area = None
        self.used_skill = None
        self.right_skill = None
        self.left_skill = None

        self.belt_health_pots = None
        self.belt_mana_pots = None

        self.menus =    {&#39;InGame&#39;: False,
                        &#39;Inventory&#39;: False,
                        &#39;Character&#39;: False,
                        &#39;SkillSelect&#39;: False,
                        &#39;SkillTree&#39;: False,
                        &#39;Chat&#39;: False,
                        &#39;NpcInteract&#39;: False,
                        &#39;EscMenu&#39;: False,
                        &#39;Map&#39;: False,
                        &#39;NpcShop&#39;: False,
                        &#39;QuestLog&#39;: False,
                        &#39;Waypoint&#39;: False,
                        &#39;Party&#39;: False,
                        &#39;Stash&#39;: False,
                        &#39;Cube&#39;: False,
                        &#39;AltPick&#39;:False,
                        &#39;Potions&#39;:False
                        }

        self.maps = []
        self._loot_data = []

        self.botty_data = {&#34;monsters&#34;: [],&#34;poi&#34;: [],
            &#34;objects&#34;: [],&#34;items&#34;: [],
            &#34;map&#34;: None,
            &#34;player_pos_world&#34;: None,
            &#34;player_pos_area&#34;: None,
            &#34;area_origin&#34;: None,
            &#34;current_area&#34;: None,
            &#34;used_skill&#34;: None,
            &#34;right_skill&#34;: None,
            &#34;left_skill&#34;: None,
            &#34;menus&#34;:None,
            &#34;belt_health_pots&#34;:None,
            &#34;belt_mana_pots&#34;:None,
            &#34;player_pos&#34;:None,       
            &#34;player_offset&#34;:np.array([0,0]),
            &#34;necroSkel&#34;: 0,
            &#34;necroMage&#34;: 0,
            &#34;necroGol&#34;: &#39;none&#39;,
            &#34;features&#34;: [],}


        
        log_color(&#34;:: Base address            -&gt; {}&#34;.format(hex(self.base)),fg_color=0,bg_color=traverse_color)

    def read_loot_cfg(self):
        with open(&#34;Z:/botty-r-latest/src/read_mem/item_filter.yaml&#34;, &#34;r&#34;) as stream:
            try:
                loot_filter = yaml.safe_load(stream)
                #print(loot_filter)
                &#39;&#39;&#39;
                for category in loot_filter:
                    print(str(category))
                    #for item in loot_filter.get(category):
                    print(loot_filter.get(category))
                &#39;&#39;&#39;
                    #for value in key:
                    #   print(str(value))
                self._loot_data = loot_filter
            except yaml.YAMLError as exc:
                print(exc)


    def get_map_d2api(self,seed):
        &#34;&#34;&#34;Get map values for input seed, using the piped api
        
        Args:
            seed (uint): current map seed
        &#34;&#34;&#34;

        p = Popen([&#34;d2mapapi_piped.exe&#34;, &#34;C:/Program Files/Diablo II&#34;], stdin=PIPE, stdout=PIPE)
        #seed
        s = (seed).to_bytes(4,&#39;little&#39;)
        #difficulty
        d = (2).to_bytes(4,&#39;little&#39;)
        #map id
        m = (79).to_bytes(4,&#39;little&#39;)
        
        p.stdin.write(s)
        p.stdin.write(d)
        p.stdin.write(m)
        data,err = p.communicate()
        sd = data.decode(&#39;ascii&#39;,&#39;ignore&#39;)
        #nasty 
        sd = sd[sd.find(&#39;{&#39;):]
        j = json.loads(sd,strict=False) 
        obj = j[&#39;objects&#39;]
        #get chests....
        chests = obj[&#39;580&#39;]
        #print(sd)
        map_offset_x = j[&#39;offset&#39;][&#39;x&#39;]
        map_offset_y = j[&#39;offset&#39;][&#39;y&#39;]
        self.chests = chests
        self.map_ox = map_offset_x
        self.map_oy = map_offset_y


    def get_map_json(self,seed, mapid:int, objectIDs:list=None):
        &#34;&#34;&#34;Summary
        
        Args:
            seed (TYPE): current map seed read from memory
            mapid (int): current in game map number
            objectIDs (list, optional): Description
        
        Returns:
            TYPE: Description
        &#34;&#34;&#34;

        #url for map api
        base_url=&#39;http://34.69.54.92:8000&#39;    
        url=base_url+&#39;/&#39;+str(seed)+f&#39;/2/{str(mapid)}/1&#39;

        log = (&#34;:: Got data from           -&gt; {}&#34;.format(url))
        log_color(log,fg_color=0,bg_color=traverse_color)
        resp = requests.get(url=url)
        j = resp.json()

        obj = j[&#39;objects&#39;]
        if objectIDs is not None:
            for objectID in objectIDs:
                self.responseList.append (obj[objectID])
        map_offset_x = j[&#39;offset&#39;][&#39;x&#39;]
        map_offset_y = j[&#39;offset&#39;][&#39;y&#39;]

        map_offset =np.array([map_offset_x,map_offset_y])


        self.map_offset = map_offset
        row = []
        for point in j[&#39;mapData&#39;]:
            if point != -1:
                row.append (point)
            else:
                self.grid.append (row)
                row = []              
        
        

        def split(a, sep):
            &#34;&#34;&#34;Summary
            
            Args:
                a (TYPE): Description
                sep (TYPE): Description
            
            Yields:
                TYPE: Description
            &#34;&#34;&#34;
            pos = i = 0
            while i &lt;len(a):
                if a[i:i+len(sep)] == sep:
                    yield a[pos:i]
                    pos = i = i+len(sep)
                else:
                    i += 1
            yield a[pos:i]

        points_of_interest = []
        map_objects = []

        if j != None:
            map_crop = j[&#39;crop&#39;]
            obj_str = &#34;|&#34;
            poi_str = &#34;|&#34;
            #these are mostly garbage and not useful, its map decorator stuff
            for key in j[&#39;objects&#39;]:
                value = j[&#39;objects&#39;][key]
                name = objects[int(key)]
                obj_str+=name+&#34;|&#34;
                #print(int(key),name)
                for instance in value:
                    offset_x =instance[&#39;x&#39;]
                    offset_y=instance[&#39;y&#39;]
                    pos =np.array([offset_x,offset_y])
                    pos_area = pos-map_offset
                    flag = 0
                    new_obj = {&#34;position&#34;:pos,&#34;flag&#34;:1,&#34;name&#34;:name,&#34;pos_area&#34;:pos_area}
                    map_objects.append(new_obj)
                    break

            #filter ut way points from the objects list
            for key in j[&#39;objects&#39;]:
                value = j[&#39;objects&#39;][key]
                name = objects[int(key)]
                if &#39;waypoint&#39; in name or &#39;Waypoint&#39; in name:
                    poi_str+=name+&#34;|&#34;
                    #print(int(key),name)
                    for instance in value:
                        offset_x =instance[&#39;x&#39;]
                        offset_y=instance[&#39;y&#39;]
                        pos =np.array([offset_x,offset_y])
                        pos_area = pos-map_offset
                        flag = 0
                        new_obj = {&#34;position&#34;:pos,&#34;flag&#34;:1,&#34;label&#34;:name,&#34;pos_area&#34;:pos_area}
                        points_of_interest.append(new_obj)
                        break

            #convert exits to a uniform format in poi
            for key in j[&#39;exits&#39;]:
                value = j[&#39;exits&#39;][key]
                name = areas[int(key)]
                poi_str+=name+&#34;|&#34;
                is_portal = value[&#39;isPortal&#39;]
                offset_x = value[&#39;offsets&#39;][0][&#39;x&#39;]
                offset_y = value[&#39;offsets&#39;][0][&#39;y&#39;]
                pos =np.array([offset_x,offset_y])
                pos_area = pos-map_offset
                new_poi = {&#34;position&#34;:pos,&#34;type&#34;:1,&#34;label&#34;:name,&#34;pos_area&#34;:pos_area}
                points_of_interest.append(new_poi)
            #convert npcs to a uniform format
            if j[&#39;npcs&#39;] is not None:
                for key in j[&#39;npcs&#39;]:
                    if int(key)&lt;738:
                        value = j[&#39;npcs&#39;][key]
                        name = get_mob_name[int(key)]
                        poi_str+=name+&#34;|&#34;
                        is_portal=False
                        is_npc=True
                        offset_x = value[0][&#39;x&#39;]
                        offset_y = value[0][&#39;y&#39;]
                        pos = np.array([offset_x,offset_y])
                        pos_area = pos-map_offset
                        new_poi = {&#34;position&#34;:pos,&#34;type&#34;:1,&#34;label&#34;:name,&#34;pos_area&#34;:pos_area}
                        points_of_interest.append(new_poi)

            map_id = j[&#39;id&#39;]
            map_data = j[&#39;mapData&#39;]
            #map_offset = j[&#39;offset&#39;]
            map_size = j[&#39;size&#39;]
            map_decode = list(split(map_data,sep=[-1]))

            self.area_origin = map_offset
            self.botty_data[&#39;area_origin&#39;] = map_offset

            nodes = []
            col_grid = []

            #map_decode.pop(-1)

            collision_grid = np.empty([int(map_size[&#39;height&#39;]),int(map_size[&#39;width&#39;])], dtype=np.uint8)
            
            if map_data != None:
                mini_map_w=int(map_size[&#39;width&#39;])
                mini_map_h=int(map_size[&#39;height&#39;])
                walkable = True
                y = 0
                for ele in map_decode:
                    x = 0
                    row = []
                    for i in range(len(ele)):
                        if walkable:
                            for j in range(ele[i]):
                                nodes.append([x,y,walkable])
                                row.append(0)
                                collision_grid[y][x] = 0
                                x+=1
                        if not walkable:
                            for j in range(ele[i]):
                                nodes.append([x,y,walkable])
                                row.append(-1)
                                collision_grid[y][x] = -1
                                x+=1

                        walkable = not walkable
                    y+=1
                    col_grid.append(row)
                    x=0
                    walkable = True
            

            new_map = {&#34;crop&#34;: map_crop,&#34;id&#34;: map_id,&#39;poi&#39;: points_of_interest,&#34;objects&#34;: map_objects,&#34;size&#34;: map_size,&#34;nodes&#34;:nodes,&#34;data&#34;:col_grid}

            log = (&#34;:: Loaded map              -&gt; {}&#34;.format(area_list[new_map[&#39;id&#39;]]))
            self.current_area=area_list[new_map[&#39;id&#39;]]
            self.botty_data[&#39;current_area&#39;]=area_list[new_map[&#39;id&#39;]]


            log_color(log,fg_color=0,bg_color=traverse_color)
            log = (&#34;:: Number of POI           -&gt; {}&#34;.format(len(points_of_interest)))
            log_color(log,fg_color=0,bg_color=traverse_color)
            log = (&#34;:: {}&#34;.format(poi_str))
            log_color(log,fg_color=0,bg_color=traverse_color)
            log = (&#34;:: Number of OBJ           -&gt; {}&#34;.format(len(map_objects)))
            log_color(log,fg_color=0,bg_color=traverse_color)
            log = (&#34;:: {}&#34;.format(obj_str))
            log_color(log,fg_color=0,bg_color=traverse_color)

            self.maps.append(new_map)
            self.botty_data[&#39;poi&#39;] = points_of_interest
            self.botty_data[&#39;objects&#39;] = map_objects
            self.botty_data[&#39;map&#39;]= collision_grid #np.array(collision_grid, dtype=np.uint8)
            return self.responseList

    def get_map_json_exit(self,seed, mapid:int, objectIDs:list=None):
        &#34;&#34;&#34;Summary
        
        Args:
            seed (TYPE): Description
            mapid (int): Description
            objectIDs (list, optional): Description
        
        Returns:
            TYPE: Description
        &#34;&#34;&#34;
        #map hosting
        base_url=&#39;http://34.69.54.92:8000&#39;
        url=base_url+&#39;/&#39;+str(seed)+f&#39;/2/{str(mapid)}/1&#39;
        #
        print(url)
        resp = requests.get(url=url)
        j = resp.json()
        #data = json.loads(data,strict=False)   
        with open(&#39;data.json&#39;, &#39;w&#39;) as f:
            json.dump(j, f)
        obj = j[&#39;exits&#39;]
        obj = obj [str(objectIDs)]
        
        #print(sd)
        map_offset_x = j[&#39;offset&#39;][&#39;x&#39;]
        map_offset_y = j[&#39;offset&#39;][&#39;y&#39;]
        #self.chests = chests
        self.map_ox = map_offset_x
        self.map_oy = map_offset_y
        return obj[&#39;offsets&#39;]

    def get_game_info_offset(self):
        &#34;&#34;&#34;Summary
        
        Returns:
            TYPE: Description
        &#34;&#34;&#34;
        #get game info offset
        pat = b&#39;\xE8....\x48\x8D\x0D....\x44\x88\x2D....&#39;
        pat_addr = pymem.pattern.pattern_scan_module(self.handle, self.module, pat)
        offset_buffer = self.process.read_int(pat_addr+8)
        game_info_offset = ((pat_addr - self.base)  + 7 -256 + 5 + offset_buffer)
        log = (&#34;:: Found game info offset  -&gt; {}&#34;.format(hex(game_info_offset)))
        log_color(log,fg_color=0,bg_color=traverse_color)
        return game_info_offset

    def get_hover_object_offset(self):
        &#34;&#34;&#34;Summary
        
        Returns:
            TYPE: Description
        &#34;&#34;&#34;
        pat = b&#39;\xc6\x84\xc2.....\x48\x8b\x74.&#39;
        pat_addr = pymem.pattern.pattern_scan_module(self.handle, self.module, pat, return_multiple=False)
        offset_buffer = self.process.read_bytes(pat_addr+3,4)
        offset_buffer_int = int.from_bytes(offset_buffer,&#39;little&#39;)
        hover_offset = (offset_buffer_int)-1
        log = (&#34;:: Found hover offset        -&gt; {}&#34;.format(hex(hover_offset)))
        log_color(log,fg_color=0,bg_color=traverse_color)
        return hover_offset

    def get_exp_offset(self):
        &#34;&#34;&#34;Summary
        
        Returns:
            TYPE: Description
        &#34;&#34;&#34;
        #expansion offset
        pat = b&#39;\xC7\x05........\x48\x85\xC0\x0F\x84....\x83\x78\x5C.\x0F\x84....\x33\xD2\x41&#39;
        #this works fine, shorter pattern
        pat = b&#39;\xC7\x05........\x48\x85\xC0\x0F\x84....&#39;
        pat_addr = pymem.pattern.pattern_scan_module(self.handle, self.module, pat)
        offset_buffer = self.process.read_int(pat_addr-4)
        exp_offset = ((pat_addr - self.base) + offset_buffer)
        log = (&#34;:: Found exp offset        -&gt; {}&#34;.format(hex(exp_offset)))
        log_color(log,fg_color=0,bg_color=traverse_color)
        return exp_offset

    def get_unit_offset(self):
        &#39;&#39;&#39;doc string
        
        Returns:
            TYPE: Description
        &#39;&#39;&#39;
        #unit table offset
        pat = b&#34;\x48\x8d.....\x8b\xd1&#34;
        pat_addr = pymem.pattern.pattern_scan_module(self.handle, self.module, pat)
        offset_buffer = self.process.read_int(pat_addr+3)
        player_offset = ((pat_addr - self.base) + 7 + offset_buffer)
        log = (&#34;:: Found player offset     -&gt; {}&#34;.format(hex(player_offset)))
        log_color(log,fg_color=0,bg_color=traverse_color)
        return player_offset


    def get_menu_data_offset(self):
        &#34;&#34;&#34;Summary
        
        Returns:
            TYPE: Description
        &#34;&#34;&#34;
        #unit table offset
        pat = b&#34;\x41\x0f\xb6\xac\x3f....&#34;
        pat_addr = pymem.pattern.pattern_scan_module(self.handle, self.module, pat)
        offset_buffer = self.process.read_int(pat_addr-5)
        ui_offset = ((pat_addr - self.base) + offset_buffer)
        log = (&#34;:: Found menu data offset  -&gt; {}&#34;.format(hex(ui_offset)))
        log_color(log,fg_color=0,bg_color=traverse_color)
        #ui_offset =  0x21F89AA
        return ui_offset

    def get_ui_settings_offset(self):
        &#34;&#34;&#34;Summary
        
        Returns:
            TYPE: Description
        &#34;&#34;&#34;
        #unit table offset
        pat = b&#34;\x40\x84\xed\x0f\x94\x05&#34;
        pat_addr = pymem.pattern.pattern_scan_module(self.handle, self.module, pat)
        offset_buffer = self.process.read_int(pat_addr+6)
        ui_offset = ((pat_addr - self.base) + 10 + offset_buffer)
        log = (&#34;:: Found ui offset         -&gt; {}&#34;.format(hex(ui_offset)))
        log_color(log,fg_color=0,bg_color=traverse_color)
        #ui_offset =  0x21F89AA
        return ui_offset

    def get_menu_vis_offset(self):
        &#34;&#34;&#34;Summary
        
        Returns:
            TYPE: Description
        &#34;&#34;&#34;
        #menu vis offset
        #pat = b&#39;\x8B\x05....\x89\x44\x24\x20\x74\x07&#39;
        #?? search less direct matches?
        pat = b&#39;\x8B\x05....\x89\x44.\x20\x74\x07&#39;
        pat_addr = pymem.pattern.pattern_scan_module(self.handle, self.module, pat)
        offset_buffer = self.process.read_int(pat_addr+2)
        #maybe dont need +6 here?
        menu_offset = ((pat_addr - self.base) + 6 + offset_buffer)
        log = (&#34;:: Found menu offset       -&gt; {}&#34;.format(hex(menu_offset)))
        log_color(log,fg_color=0,bg_color=traverse_color)
        return menu_offset

    def get_last_hovered(self):
        &#34;&#34;&#34;Summary
        &#34;&#34;&#34;
        offset = self.hoverd_offset
        is_hovered = self.process.read_int(offset+self.base+0x00)
        is_tooltip = self.process.read_int(offset+self.base+0x01)
        hovered_unit_type = self.process.read_int(offset+self.base+0x03)
        hoverd_id = self.process.read_uint(offset+self.base+0x08)

        for m in self.monsters:
            if hoverd_id == m[&#39;id&#39;] and is_hovered:
                print(m[&#39;name&#39;])
                break


    def get_player_offset(self,loops):
        &#34;&#34;&#34;Summary
        
        Args:
            loops (TYPE): Description
        
        Returns:
            TYPE: Description
        &#34;&#34;&#34;
        found = False
        #ui_offset = 0x21F89AA
        attempts=0
        name = &#34;&#34;
        new_offset=0

        for i in range(loops):
            attempts=i+0
            new_offset = (self.starting_offset)+(attempts-1)*8

            start_addr = self.base + new_offset

            player_unit = self.process.read_longlong(start_addr)
            #print (player_unit)
            while player_unit&gt;0:
                p_inventory = player_unit+0x90
                inventory = self.process.read_longlong(p_inventory)
                if(inventory):
                    log = (&#34;:: Found inventory offset  -&gt; {}&#34;.format(hex(self.base-inventory)))
                    log_color(log,fg_color=0,bg_color=traverse_color)
                    exp_char = self.process.read_ushort(self.base+self.exp_offset)
                    base_check = self.process.read_ushort(inventory+0x30) !=1
                    if(exp_char):
                        log = (&#34;:: Expansion char          -&gt; True&#34;)
                        log_color(log,fg_color=0,bg_color=traverse_color)
                        base_check = self.process.read_ushort(inventory+0x70) !=0

                if(base_check):
                    #print(&#34;base checks&#34;)
                    p_act = player_unit+0x20
                    act_addr = self.process.read_ulonglong(p_act)
                    map_seed_addr = act_addr +0x14
                    map_seed = self.process.read_uint(map_seed_addr)
                    self.map_seed = map_seed
                    #print(map_seed)
                    p_path = player_unit+0x38
                    path_addr = self.process.read_longlong(p_path)

                    x_pos = self.process.read_ushort(path_addr+0x02)
                    #print (x_pos)
                    y_pos = self.process.read_ushort(path_addr+0x06)
                    #print (y_pos)
                    p_unit_data = player_unit +0x10
                    try:
                        player_name_addr = self.process.read_longlong(p_unit_data)
                    except:
                        pass
                    p_name = &#34;&#34;
                    #
                    for i in range(16):
                        name = name + str(chr(self.process.read_uchar(player_name_addr+i-1)))

                    if(x_pos&gt; 0 and y_pos &gt;0 and len(str(map_seed))&gt;6):
                        if loops &gt; 1:
                            log = (&#34;:: Found player name       -&gt; {}&#34;.format(name))
                            log_color(log,fg_color=0,bg_color=traverse_color)
                            log = (&#34;:: Found map seed          -&gt; {}&#34;.format(map_seed))
                            log_color(log,fg_color=0,bg_color=traverse_color)
                        new_offset = new_offset+0
                        found = True
                        self.player_unit = new_offset
                        self.path_addr = path_addr
                        return True

                new_offset = (player_unit+0x150)-self.base
                try:
                    player_unit = self.process.read_longlong(player_unit +0x150)
                except:
                    pass


    def get_current_level(self):
        &#34;&#34;&#34;Summary
        &#34;&#34;&#34;
        startingAddress = self.base + self.player_unit
        playerUnit = self.process.read_ulonglong(startingAddress)
        pUnitData = playerUnit + 0x10
        #get the level number
        pPathAddress = playerUnit + 0x38
        pPath = self.process.read_ulonglong(pPathAddress)
        pRoom1 = pPath + 0x20
        pRoom1Address = self.process.read_ulonglong(pRoom1)
        pRoom2 = pRoom1Address + 0x18
        pRoom2Address = self.process.read_ulonglong(pRoom2)
        pLevel = pRoom2Address + 0x90
        pLevelAddress = self.process.read_ulonglong(pLevel)
        dwLevelNo = pLevelAddress + 0x1F8
        levelNo = self.process.read_uint(dwLevelNo)
        self._level_addr = dwLevelNo
        self.level = levelNo

    def find_info(self):
        &#34;&#34;&#34;Summary
        
        Returns:
            TYPE: Description
        &#34;&#34;&#34;
        startingAddress = self.base + self.player_unit
        playerUnit = self.process.read_ulonglong(startingAddress)

        pUnitData = playerUnit + 0x10
        try:
            playerNameAddress = self.process.read_ulonglong(pUnitData)
        except:
            print(&#34;FAILED&#34;)
            print(&#34;FAILED&#34;)
            print(&#34;FAILED&#34;)
            print(&#34;FAILED&#34;)
            print(&#34;FAILED&#34;)
            print(&#34;FAILED&#34;)
            return False
            pass
        if(playerNameAddress):
            playerName = self.process.read_string(playerNameAddress)
        
        pStatsListEx = self.process.read_ulonglong(playerUnit+0x88)
        statPtr = self.process.read_ulonglong(pStatsListEx+0x30)
        statCount = self.process.read_ulonglong(pStatsListEx+0x38)

        for i in range(statCount):

            statOffset = (i-1) * 8
            statEnum = self.process.read_ushort(statPtr + 0x2 + statOffset)
            if (statEnum == 12):
                self.player_level = self.process.read_uint(statPtr + 0x4 + statOffset)
            if (statEnum == 13):
                self.experience = self.process.read_uint(statPtr + 0x4 + statOffset)
            if (statEnum == 6):
                hp = self.process.read_uint(statPtr + 0x4 + statOffset)
                self.hp = hp &gt;&gt; 8
            if (statEnum == 7):
                maxhp = self.process.read_uint(statPtr + 0x4 + statOffset)
                self.max_hp = maxhp &gt;&gt; 8
        log = &#34;:: LVL:&#34; +str(self.player_level)+&#34;, HP:&#34;+str(self.max_hp)+&#34;, EXP:&#34;+str(self.experience)
        log_color(log,fg_color=0,bg_color=traverse_color)

        #get the level number
        pPathAddress = playerUnit + 0x38
        pPath = self.process.read_ulonglong(pPathAddress)
        pRoom1 = pPath + 0x20
        pRoom1Address = self.process.read_ulonglong(pRoom1)
        pRoom2 = pRoom1Address + 0x18
        pRoom2Address = self.process.read_ulonglong(pRoom2)
        pLevel = pRoom2Address + 0x90
        pLevelAddress = self.process.read_ulonglong(pLevel)
        dwLevelNo = pLevelAddress + 0x1F8
        levelNo = self.process.read_uint(dwLevelNo)
        self._level_addr = dwLevelNo
        
        
        self.level = levelNo
        log = (&#34;:: current level      -&gt; &#34;+str(area_list[levelNo]))
        log_color(log,fg_color=0,bg_color=traverse_color)

        if not levelNo:
            log = &#34;!! Did not find level num using player offset&#34; +str(playerOffset)
            log_color(log,fg_color=0,bg_color=traverse_color)


        #get the map seed
        pAct = playerUnit + 0x20
        actAddress = self.process.read_ulonglong(pAct)


        if actAddress:
            mapSeedAddress = actAddress + 0x14
            if mapSeedAddress:
                mapSeed = self.process.read_uint(mapSeedAddress)
                self.map_seed = mapSeed
                #print(&#34;Found seed&#34;+str(mapSeed)+ &#34;at address&#34; +str(mapSeedAddress))
            else:
                log = (&#34;!! Did not find map seed at address&#34;+(mapSeedAddress))
                log_color(log,fg_color=0,bg_color=traverse_color)

        #get the level number
        actAddress = self.process.read_ulonglong(pAct)

        pActUnk1 = actAddress + 0x70
        aActUnk2 = self.process.read_ulonglong(pActUnk1)
        aDifficulty = aActUnk2 + 0x830
        difficulty = self.process.read_ushort(aDifficulty)
        self.difficulty=difficulty

        if difficulty==0:
            log = (&#34;:: current difficulty      -&gt; Normal&#34;)
            log_color(log,fg_color=0,bg_color=traverse_color)
        if difficulty==1:
            log = (&#34;:: current difficulty      -&gt; Nightmare&#34;)
            log_color(log,fg_color=0,bg_color=traverse_color)
        if difficulty==2:
            log = (&#34;:: current difficulty      -&gt; Hell&#34;)
            log_color(log,fg_color=0,bg_color=traverse_color)

    def normalized_p(self):
        &#34;&#34;&#34;Summary
        &#34;&#34;&#34;
        self.np_x = float(self.map_ox)/float(self.process.read_ushort(self.path_addr+0x02))
        self.np_y = float(self.map_oy)/float(self.process.read_ushort(self.path_addr+0x06))

    def get_ppos(self):
        &#34;&#34;&#34;Summary
        &#34;&#34;&#34;
        x = self.process.read_ushort(self.path_addr+0x02)
        y = self.process.read_ushort(self.path_addr+0x06)
        self.player_world_pos = np.array([x,y])
        self.botty_data[&#39;player_pos_area&#39;] =self.player_world_pos -self.area_origin
        self.botty_data[&#39;player_pos_world&#39;] = self.player_world_pos

    def chest_dist(self):
        &#39;&#39;&#39;doc string&#39;&#39;&#39;
        self.x_pos = self.process.read_ushort(self.path_addr+0x02)-self.map_ox
        self.y_pos = self.process.read_ushort(self.path_addr+0x06)-self.map_oy

        for chest in self.chests:
            chest_loc_x = chest[&#39;x&#39;]
            chest_loc_y = chest[&#39;y&#39;]
            odist = math.dist([chest_loc_x,chest_loc_y],[self.x_pos,self.y_pos])
            #print(&#39;dist -&gt; &#39;+ str(odist))
            #print(&#39;current pos -&gt;  &#39;+str(self.x_pos)+&#39;,&#39;+str(self.y_pos))

    def find_objects(self, file_number:int):
        &#34;&#34;&#34;Summary
        
        Args:
            file_number (int): Description
        
        Returns:
            TYPE: Description
        &#34;&#34;&#34;
        self.super_chests =[]
        object_offset = self.starting_offset + (2 * 1024)
        attempts=0


        for i in range(256):
            attempts=i+0
            new_offset = object_offset + (8 * (i-1))
            item_addr = self.base + new_offset
            object_unit = self.process.read_longlong(item_addr)

            #print(i)
            while (object_unit&gt;0):
                item_type = self.process.read_int(object_unit+0x00)
                pRoomnext = self.process.read_ulonglong(object_unit+0x158)
                #pRoomEx = self.process.read_ulonglong (pRoomnext+0x18)
                if(item_type==2):
                    file_no = self.process.read_int(object_unit+0x04)
                    if file_no == file_number:
                        print (&#34;Object found&#34;)
                        p_unit_data = self.process.read_ulonglong(object_unit + 0x10)
                        mode = self.process.read_uint (object_unit + 0x0C)
                        #pObjectTxt = self.process.read_ulonglong(p_unit_data)
                        #print(str(pObjectTxt))
                        #sObjectTxt = self.process.read_string(p_unit_data, 16)
                        #shrineTxt = self.process.read_string(p_unit_data + 0x0c, 16)
                        pPath = self.process.read_ulonglong(object_unit + 0x38)  
                        objectx = self.process.read_ushort(pPath + 0x10)
                        objecty = self.process.read_ushort(pPath + 0x14)
                        self.x_pos = self.process.read_ushort(self.path_addr+0x02)
                        self.y_pos = self.process.read_ushort(self.path_addr+0x06)
                        odist = math.dist([objectx,objecty],[self.x_pos,self.y_pos])
                        #print(self.y_pos)
                        #print(self.x_pos)
                        print(txt_obj_name[file_no-1] + &#34;&#34;+ str(str(file_no)))    
                        print(&#39;dist -&gt; &#39;+ str(odist))
                        obj = Object (objectx, objecty, mode)
                        return obj



                object_unit = self.process.read_longlong(object_unit + 0x150)
    




    def ui_status(self):
        &#34;&#34;&#34;Summary
        &#34;&#34;&#34;
        InGame = False
        Inventory =  False
        Character =  False
        SkillSelect = False
        SkillTree = False
        Chat = False
        NpcInteract =  False
        EscMenu = False
        Map = False
        NpcShop = False
        QuestLog = False
        Waypoint = False
        Party = False
        Stash = False
        Cube = False
        AltPick = False
        Potions=False

        offset = self.ui_settings_offset
        ui = self.base + offset
        item_pick = self.process.read_ushort(ui+2)
        quit_menu = self.process.read_bytes(ui-0x01,1)
        quit_menu_int = int.from_bytes(quit_menu,&#34;little&#34;)
        quest_menu = self.process.read_bytes(ui+0x04,1)
        quest_menu_int = int.from_bytes(quest_menu,&#34;little&#34;)
        skill_menu = self.process.read_bytes(ui-0x06,1)
        skill_menu_int = int.from_bytes(skill_menu,&#34;little&#34;)
        char_menu = self.process.read_bytes(ui-0x08,1)
        char_menu_int = int.from_bytes(char_menu,&#34;little&#34;)
        stash_menu = self.process.read_bytes(ui-0x19+0x28-1,1)
        stash_menu_int = int.from_bytes(stash_menu,&#34;little&#34;)
        npc_menu = self.process.read_bytes(ui+1,1)
        npc_menu_int = int.from_bytes(npc_menu,&#34;little&#34;)
        inv_menu = self.process.read_bytes(ui-0x09,1)
        inv_menu_int = int.from_bytes(inv_menu,&#34;little&#34;)
        merc_menu = self.process.read_ushort(ui+0x14)
        party_menu = self.process.read_bytes(ui+0x0b,1)
        party_menu_int = int.from_bytes(party_menu,&#34;little&#34;)
        waypoint_menu = self.process.read_bytes(ui+0x09,1)
        #ugh why
        waypoint_menu_int = int.from_bytes(waypoint_menu,&#34;little&#34;)
        in_game = self.process.read_bytes(ui+0x08,1)
        in_game_int = int.from_bytes(in_game,&#34;little&#34;)

        cube_menu = self.process.read_bytes(ui-0x19+0x28,1)
        cube_menu_int = int.from_bytes(cube_menu,&#34;little&#34;)
        
        map_menu = self.process.read_bytes(ui-0x19+0x28-15,1)
        map_menu_int = int.from_bytes(map_menu,&#34;little&#34;)

        potion_menu = self.process.read_bytes(ui-0x19+0x28+1,1)
        potion_menu_int = int.from_bytes(potion_menu,&#34;little&#34;)

        npc_interact = self.process.read_bytes(ui-0x19+0x28-0x11,1)
        npc_interact_int = int.from_bytes(npc_interact,&#34;little&#34;)
        

        chat = self.process.read_bytes(ui-0x19+0x28-0x11-3,1)
        chat_int = int.from_bytes(chat,&#34;little&#34;)

        if chat_int:
            Chat=True
            #print(&#34;chattings&#34;)
        if npc_interact_int:
            NpcInteract=True
            #print(&#39;talkign to npc&#39;)
        if potion_menu_int:
            Potions=True
            #print(&#39;pOtioOn is active&#39;)
        if map_menu_int:
            Map=True
            #print(&#39;Map is active&#39;)
        if cube_menu_int:
            Cube=True
            #print(&#39;Cube is active&#39;)
        if in_game_int:
            #print(&#39;in game&#39;) #works
            InGame=True
        if stash_menu_int:
            #print(&#39;stash menu is  active&#39;)
            Stash=True
        if npc_menu_int:
            #print(&#39;npc menu is  active&#39;)
            NpcShop=True
        if party_menu_int:
            #print(&#39;party menu is  active&#39;)
            Party=True
        if inv_menu_int:
            #print(&#39;inv menu is  active&#39;)
            Inventory=True
        if waypoint_menu_int:
            #print(&#39;waypoint menu is  active&#39;)
            Waypoint=True
        if quit_menu_int:
            EscMenu=True
            #print(&#39;!!!quit menu is  active&#39;)
        if item_pick:
            AltPick=True
            #print(&#39;item pick is active&#39;)
        if quest_menu_int:
            QuestLog=True
            #print(&#39;Quest log is active&#39;)
        if char_menu_int:
            Character=True
            #print(&#39;Char menu is active&#39;)
        if skill_menu_int:
            SkillTree=True
            #print(&#39;Skill tree is active&#39;)

        self.menus =    {&#39;InGame&#39;: InGame,
                        &#39;Inventory&#39;: Inventory,
                        &#39;Character&#39;: Character,
                        &#39;SkillSelect&#39;: SkillSelect,
                        &#39;SkillTree&#39;: SkillTree,
                        &#39;Chat&#39;: Chat,
                        &#39;NpcInteract&#39;: NpcInteract,
                        &#39;EscMenu&#39;: EscMenu,
                        &#39;Map&#39;: Map,
                        &#39;NpcShop&#39;: NpcShop,
                        &#39;QuestLog&#39;: QuestLog,
                        &#39;Waypoint&#39;: Waypoint,
                        &#39;Party&#39;: Party,
                        &#39;Stash&#39;: Stash,
                        &#39;Cube&#39;: Cube,
                        &#39;AltPick&#39;:AltPick,
                        &#39;Potions&#39;:Potions
                        }


    def find_items(self):
        &#34;&#34;&#34;Summary
        &#34;&#34;&#34;
        items = []
        item_offset = self.starting_offset + (4*1024)

        for i in range(256):


            new_offset = item_offset +(8 *(i))
            item_addr = self.base + new_offset
            item_unit = self.process.read_longlong(item_addr)

            while (item_unit&gt;0):
                item_type = self.process.read_uint(item_unit+0x00)
                if item_type == 4:
                    txt_file_no = self.process.read_uint(item_unit+0x04)
                    item_loc = self.process.read_uint(item_unit+0x0C)

                    # item loc 0 = inventory, 1 = equipped, 2 in belt, 3 on ground, 4 cursor, 5 dropping ,6 socketed
                    if item_loc == 3 or item_loc == 5:
                        #print(&#34;item on ground&#34;)
                        p_unit_data = self.process.read_longlong(item_unit + 0x10)
                        #itemQuality - 5 is set, 7 is unique (6 rare, 4, magic)
                        item_quality = self.process.read_uint(p_unit_data)
                        p_path = self.process.read_longlong(item_unit+0x38)
                        item_x = self.process.read_ushort(p_path+0x10)
                        item_y = self.process.read_ushort(p_path+0x14)

                        p_stat_list_ex = self.process.read_longlong(item_unit + 0x88)
                        stat_ptr = self.process.read_longlong(p_stat_list_ex + 0x30)
                        stat_count = self.process.read_longlong(p_stat_list_ex + 0x38)
                        num_sockets = 0

                        for j in range(stat_count):
                            #print(&#34;checking for sockets&#34;)
                            stat_offset = (j)*8
                            stat_enum = self.process.read_ushort(stat_ptr+0x2+stat_offset)
                            if stat_enum == 194:
                                num_sockets = self.process.read_uint(stat_ptr+0x4+stat_offset)
                                #print(&#39;number of sockets -&gt;&#39;+str(num_sockets))
                                break

                        flags = self.process.read_uint(p_unit_data+0x18)


                        identified = False
                        if(0x00000010 &amp; flags):
                            identified = True
                            #print(&#34;id&#39;d&#34;)
                        ethereal = False
                        if(0x00400000 &amp; flags):
                            ethereal = True

                        quality=&#39;Any&#39;
                        if item_quality == 1:
                            quality = &#39;Inferior&#39;
                        if item_quality == 2:
                            quality = &#39;Normal&#39;
                        if item_quality == 3:
                            quality = &#39;Superior&#39;
                        if item_quality == 4:
                            quality = &#39;Magic&#39;
                        if item_quality == 5:
                            quality = &#39;Set&#39;
                        if item_quality == 6:
                            quality = &#39;Rare&#39;
                        if item_quality == 7:
                            quality = &#39;Unique&#39;
                        if item_quality == 8:
                            quality = &#39;Crafted&#39;
                        if item_quality == 9:
                            quality = &#39;Tempered&#39;

                        #print(txt_file_no)
                        if txt_file_no &gt;= 557 and txt_file_no &lt;= 586 or txt_file_no&gt;= 597 and txt_file_no&lt;= 601:
                            quality = &#39;Gem&#39;
                        if txt_file_no &gt;= 610 and txt_file_no &lt;= 642:
                            quality = &#39;Rune&#39;

                        item = (txt_file_no,quality,item_name[txt_file_no],item_quality,item_loc,item_x,item_y,num_sockets)


                        for category in self._loot_data:
                            q_match = 0
                            i_match = 0
                            loot_check = 0

                            data = self._loot_data.get(category)
                            quality_match = [&#39;Any&#39;]
                            item_match = [&#39;Any&#39;]
                            try:
                                quality_match = data[&#39;quality&#39;]
                            except:
                                quality_match = [&#39;Inferior&#39;,&#39;Normal&#39;,&#39;Superior&#39;,&#39;Magic&#39;,&#39;Set&#39;,&#39;Rare&#39;,&#39;Unique&#39;,&#39;Crafted&#39;,&#39;Tempered&#39;,&#39;Gem&#39;,&#39;Rune&#39;]
                                pass
                            try:
                                item_match = data[&#39;items&#39;]
                            except:
                                item_match = [&#39;Any&#39;]
                                pass

                            for q in quality_match:
                                if quality in q:
                                    q_match=1

                            for i in item_match:
                                item_to_check = str(item_name[txt_file_no])
                                if num_sockets&gt;0:
                                    item_to_check = str(item_name[txt_file_no])+&#39;,&#39;+str(num_sockets)
                                if item_to_check in i or item_match[0] is &#39;Any&#39;:
                                    i_match=1

                            if q_match and i_match:
                                loot_check =1

                            try:
                                if data[&#39;ignoreidentified&#39;] is True and identified:
                                    loot_check=0
                            except:
                                pass

                            if loot_check:
                                print(&#34;good to loot&#34;)
                                #self._move_to_mem(item_x,item_y)
                                print(item_name[txt_file_no])


                        #hard coded test for thul and ist
                        #if txt_file_no == 619 or txt_file_no == 620 or txt_file_no == 633:
                        #   self._move_to_mem(item_x,item_y)
                        #   print(items_list.item_name[txt_file_no])

                    if item_loc == 4:
                        #print(&#34;item on cursor&#34;)
                        p_unit_data = self.process.read_longlong(item_unit + 0x10)
                        item_quality = self.process.read_longlong(p_unit_data)
                        p_path = self.process.read_longlong(item_unit+0x38)
                        item_x = self.process.read_ushort(p_path+0x10)
                        item_y = self.process.read_ushort(p_path+0x14)
                        #print(item_loc,item_type,txt_file_no)
                        #print(item_x,item_y)
                        

                item_unit = self.process.read_longlong(item_unit + 0x150)


    def find_mobs(self):
        &#34;&#34;&#34;Summary
        &#34;&#34;&#34;
        monstersOffset = self.starting_offset + 1024
        mobs = []
        loc_monsters = []
        skel_count =0
        mage_count =0
        golem_count = &#39;none&#39;

        for i in range(128):
            newOffset = monstersOffset + (8 * (i - 1))
            mobAddress = self.base + newOffset
            mobUnit = self.process.read_longlong(mobAddress)
            
            while (mobUnit&gt; 0):

                txtFileNo = self.process.read_uint(mobUnit + 0x04)
                hide_check = 0
                try:
                    hide_npc[txtFileNo]
                except:
                    #no key 
                    pass

                if not hide_check:

                    mobTypeString = &#34;&#34;
                    #
                    unit_data = self.process.read_ulonglong(mobUnit + 0x10)
                    mob_type = self.process.read_bytes(unit_data+0x1a,1)
                    mob_type_int = int.from_bytes(mob_type,&#34;little&#34;)

                    if mob_type_int == 0:
                        mobTypeString = &#39;None&#39;
                    if mob_type_int == 1:
                        mobTypeString = &#39;Other&#39;
                    if mob_type_int  == 10:
                        mobTypeString = &#39;SuperUnique&#39;
                    if mob_type_int == 8:
                        mobTypeString = &#39;Unique&#39;
                    if mob_type_int == 12:
                        mobTypeString = &#39;Champion&#39;                        
                    if mob_type_int == 16:
                        mobTypeString = &#39;Minion&#39;
                    if mob_type_int == 32:
                        mobTypeString = &#39;Possessed?&#39;
                    if mob_type_int == 76:
                        mobTypeString = &#39;Ghostly&#39;
                    if mob_type_int == 64:
                        mobTypeString = &#39;Multishot?&#39;
                        
                    

                    unitId = self.process.read_uint(mobUnit + 0x08)
                    mode = self.process.read_uint(mobUnit + 0x0c)
                    iscorpse = self.process.read_uchar (mobUnit + 0x1A6)
                    interactable = self.process.read_uchar (mobUnit + 0x1A6+4)
                    pUnitData = self.process.read_longlong(mobUnit + 0x10)
                    pPath = self.process.read_longlong(mobUnit + 0x38)
                
                    isUnique = self.process.read_ushort(pUnitData + 0x18)
                    #????
                    uniqueNo = self.process.read_ushort(pUnitData + 42)

                    monx = self.process.read_ushort(pPath + 0x02)
                    mony = self.process.read_ushort(pPath + 0x06)
                    xPosOffset = self.process.read_ushort(pPath + 0x00) 
                    yPosOffset = self.process.read_ushort(pPath + 0x04)
                    xPosOffset = xPosOffset / 65536
                    yPosOffset = yPosOffset / 65536
                    monx = monx + xPosOffset
                    mony = mony + yPosOffset

                    #+026?
                    #+017 - eLastMode
                    #+018 - dwDuriel - set only for duriel
                    #+01C - MonUModList[9] - nine bytes holding the Ids for each MonUMod assigned to the unit
                    #+026 - bossNo - hcIdx from superuniques.txt for superuniques (word)
                    #+028 - pAiGeneral
                    BossLineID = self.process.read_ushort(unit_data + 0x2A) 

                    isBoss = 0
                    textTitle = None

                    textTitle = get_mob_name[txtFileNo]

                    if mob_type_int == 10:
                        try:
                            textTitle = super_unique_names[uniqueNo]
                        except:
                            pass
                    if mob_type_int == 8:
                        try:
                            textTitle = get_mob_name[txtFileNo]
                        except:
                            pass
                        isBoss= 1
    

                    #get immunities
                    pStatsListEx = self.process.read_longlong(mobUnit + 0x88)
                    ownerType = self.process.read_uint(pStatsListEx + 0x08)
                    ownerId = self.process.read_uint(pStatsListEx + 0x0C)

                    statPtr = self.process.read_longlong(pStatsListEx + 0x30)
                    statCount = self.process.read_longlong(pStatsListEx + 0x38)

                    #if(isUnique):
                        #print(textTitle,mobTypeString, mob_type_int)

                    &#39;&#39;&#39;
                    #these need to be added

                    loadEncText(auraStrings[33], cfg-&gt;MightAura);
                    loadEncText(auraStrings[35], cfg-&gt;HolyFireAura);
                    loadEncText(auraStrings[40], cfg-&gt;BlessedAimAura);
                    loadEncText(auraStrings[43], cfg-&gt;HolyFreezeAura);
                    loadEncText(auraStrings[46], cfg-&gt;HolyShockAura);
                    loadEncText(auraStrings[28], cfg-&gt;ConvictionAura);
                    loadEncText(auraStrings[49], cfg-&gt;FanaticismAura);

                    loadEncText(enchantStrings[5], cfg-&gt;encTxtExtraStrong);
                    loadEncText(enchantStrings[6], cfg-&gt;encTxtExtraFast);
                    loadEncText(enchantStrings[7], cfg-&gt;encTxtCursed);
                    loadEncText(enchantStrings[8], cfg-&gt;encTxtMagicResistant);
                    loadEncText(enchantStrings[9], cfg-&gt;encTxtFireEnchanted);
                    loadEncText(enchantStrings[17], cfg-&gt;encTxtLigntningEnchanted);
                    loadEncText(enchantStrings[18], cfg-&gt;encTxtColdEnchanted);
                    loadEncText(enchantStrings[25], cfg-&gt;encTxtManaBurn);
                    loadEncText(enchantStrings[26], cfg-&gt;encTxtTeleportation);
                    loadEncText(enchantStrings[27], cfg-&gt;encTxtSpectralHit);
                    loadEncText(enchantStrings[28], cfg-&gt;encTxtStoneSkin);
                    loadEncText(enchantStrings[29], cfg-&gt;encTxtMultipleShots);
                    loadEncText(enchantStrings[37], cfg-&gt;encTxtFanatic);
                    loadEncText(enchantStrings[39], cfg-&gt;encTxtBerserker);

                    &#39;&#39;&#39;
                    #
                    immunities = {&#39;physical&#39;: 0,&#39;magic&#39;: 0,&#39;fire&#39;: 0,&#39;light&#39;: 0,&#39;cold&#39;: 0,&#39;poison&#39;: 0}
                    auras = {&#39;MightAura&#39;: 0,&#39;HolyFireAura&#39;: 0, &#39;BlessedAimAura&#39;: 0, &#39;HolyFreezeAura&#39;: 0, &#39;HolyShockAura&#39;: 0,&#39;ConvictionAura&#39;: 0,&#39;FanaticismAura&#39;:0}
                    enchants = {&#39;ExtraStrong&#39;: 0,&#39;ExtraFast&#39;: 0, &#39;Cursed&#39;: 0, &#39;MagicResistant&#39;: 0, &#39;FireEnchanted&#39;: 0,&#39;LigntningEnchanted&#39;: 0,&#39;ColdEnchanted&#39;:0,&#39;ManaBurn&#39;:0,&#39;Teleportation&#39;:0,&#39;SpectralHit&#39;:0,&#39;StoneSkin&#39;:0,&#39;MultipleShots&#39;:0,&#39;Berserker&#39;:0}

                    for s in range(statCount):
                        offset = (s -1) * 8
                        statParam = self.process.read_ushort(statPtr + offset)
                        statEnum = self.process.read_ushort(statPtr + 0x2 + offset)
                        statValue = self.process.read_uint(statPtr + 0x4 + offset)
                        if (statValue&gt;= 100):
                            if statEnum == 36:
                                immunities[&#34;physical&#34;] = 1 #physical immune      
                            if statEnum == 37:
                                immunities[&#34;magic&#34;] = 1    
                            if statEnum == 39:
                                immunities[&#34;fire&#34;] = 1
                            if statEnum == 41:
                                immunities[&#34;light&#34;] = 1  
                            if statEnum == 43:
                                immunities[&#34;cold&#34;] = 1
                            if statEnum == 45:
                                immunities[&#34;poison&#34;] = 1 
                    self.get_ppos()
                    dist = math.dist(self.player_world_pos,np.array([int(monx),int(mony)]))

                    abs_screen_position = world_to_abs(np.array([monx,mony]), self.player_world_pos)
                    mob = {&#39;position&#39;: np.array([int(monx),int(mony)]),&#39;dist&#39;: dist, &#39;abs_screen_position&#39;: abs_screen_position, &#39;immunities&#39;: immunities, &#39;unit_type&#39;: &#39;Monster&#39;, &#39;type&#39;: mobTypeString, &#39;id&#39;: unitId, &#39;name&#39;: textTitle, &#39;mode&#39;: mode, &#39;number&#39;: txtFileNo, &#39;super_unique&#39;:isUnique,&#39;boss&#39;:isBoss,&#39;is_corpse&#39;:iscorpse, &#39;interactable&#39;:interactable }
                    
                    # filter out some stuff and calculate summon count
                    if textTitle is not None:
                        if &#39;ClayGolem&#39; in mob[&#39;name&#39;]:
                            if mob[&#39;mode&#39;] != 12:
                                golem_count = &#34;ClayGolem&#34;

                        elif &#39;FireGolem&#39; in mob[&#39;name&#39;]:
                            if mob[&#39;mode&#39;] != 12:
                                golem_count = &#34;FireGolem&#34;

                        elif &#39;BloodGolem&#39; in mob[&#39;name&#39;]:
                            if mob[&#39;mode&#39;] != 12:
                                golem_count = &#34;BloodGolem&#34;

                        elif &#39;IronGolem&#39; in mob[&#39;name&#39;]:
                            if mob[&#39;mode&#39;] != 12:
                                golem_count = &#34;IronGolem&#34;

                        elif &#39;NecroMage&#39; == mob[&#39;name&#39;]:
                            if mob[&#39;mode&#39;] != 12:
                                mage_count +=1

                        elif &#39;NecroSkeleton&#39; == mob[&#39;name&#39;]:
                            if mob[&#39;mode&#39;] != 12:
                                skel_count +=1
                        elif &#39;Rouge&#39; in mob[&#39;name&#39;]:
                            pass
                        elif &#39;Gaurd&#39; in mob[&#39;name&#39;]:
                            pass
                        elif &#39;Alkor&#39; in mob[&#39;name&#39;]:
                            pass
                        elif &#39;a trap&#39; in mob[&#39;name&#39;]:
                            pass
                        elif &#39;IronWolf&#39; in mob[&#39;name&#39;]:
                            pass
                        elif &#39;Malachai&#39; in mob[&#39;name&#39;]:
                            pass
                        elif mob[&#39;name&#39;] == &#39;&#39;:
                            pass
                        elif &#39;?&#39; in mob[&#39;name&#39;]:
                            pass
                        elif &#39;Barricade&#39; in mob[&#39;name&#39;]:
                            pass
                        else:
                            loc_monsters.append(mob)

                            #if dist&lt;5:
                            #    print(mob[&#39;name&#39;])

                            #    print(mob[&#39;id&#39;])
                            #    print(mob[&#39;number&#39;])

                #get next mob
                mobUnit = self.process.read_longlong(mobUnit + 0x150)
        self.monsters = loc_monsters
        self.botty_data[&#39;monsters&#39;] = loc_monsters
        if self.botty_data[&#39;necroSkel&#39;] != skel_count:
            self.botty_data[&#39;necroSkel&#39;]=skel_count
        if self.botty_data[&#39;necroMage&#39;] != mage_count:
            self.botty_data[&#39;necroMage&#39;]=mage_count
        if self.botty_data[&#39;necroGol&#39;]!=golem_count:
            self.botty_data[&#39;necroGol&#39;] = golem_count</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="d2read.proc.proc.chest_dist"><code class="name flex">
<span>def <span class="ident">chest_dist</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>doc string</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def chest_dist(self):
    &#39;&#39;&#39;doc string&#39;&#39;&#39;
    self.x_pos = self.process.read_ushort(self.path_addr+0x02)-self.map_ox
    self.y_pos = self.process.read_ushort(self.path_addr+0x06)-self.map_oy

    for chest in self.chests:
        chest_loc_x = chest[&#39;x&#39;]
        chest_loc_y = chest[&#39;y&#39;]
        odist = math.dist([chest_loc_x,chest_loc_y],[self.x_pos,self.y_pos])
        #print(&#39;dist -&gt; &#39;+ str(odist))
        #print(&#39;current pos -&gt;  &#39;+str(self.x_pos)+&#39;,&#39;+str(self.y_pos))</code></pre>
</details>
</dd>
<dt id="d2read.proc.proc.find_info"><code class="name flex">
<span>def <span class="ident">find_info</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Summary</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>TYPE</code></dt>
<dd>Description</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_info(self):
    &#34;&#34;&#34;Summary
    
    Returns:
        TYPE: Description
    &#34;&#34;&#34;
    startingAddress = self.base + self.player_unit
    playerUnit = self.process.read_ulonglong(startingAddress)

    pUnitData = playerUnit + 0x10
    try:
        playerNameAddress = self.process.read_ulonglong(pUnitData)
    except:
        print(&#34;FAILED&#34;)
        print(&#34;FAILED&#34;)
        print(&#34;FAILED&#34;)
        print(&#34;FAILED&#34;)
        print(&#34;FAILED&#34;)
        print(&#34;FAILED&#34;)
        return False
        pass
    if(playerNameAddress):
        playerName = self.process.read_string(playerNameAddress)
    
    pStatsListEx = self.process.read_ulonglong(playerUnit+0x88)
    statPtr = self.process.read_ulonglong(pStatsListEx+0x30)
    statCount = self.process.read_ulonglong(pStatsListEx+0x38)

    for i in range(statCount):

        statOffset = (i-1) * 8
        statEnum = self.process.read_ushort(statPtr + 0x2 + statOffset)
        if (statEnum == 12):
            self.player_level = self.process.read_uint(statPtr + 0x4 + statOffset)
        if (statEnum == 13):
            self.experience = self.process.read_uint(statPtr + 0x4 + statOffset)
        if (statEnum == 6):
            hp = self.process.read_uint(statPtr + 0x4 + statOffset)
            self.hp = hp &gt;&gt; 8
        if (statEnum == 7):
            maxhp = self.process.read_uint(statPtr + 0x4 + statOffset)
            self.max_hp = maxhp &gt;&gt; 8
    log = &#34;:: LVL:&#34; +str(self.player_level)+&#34;, HP:&#34;+str(self.max_hp)+&#34;, EXP:&#34;+str(self.experience)
    log_color(log,fg_color=0,bg_color=traverse_color)

    #get the level number
    pPathAddress = playerUnit + 0x38
    pPath = self.process.read_ulonglong(pPathAddress)
    pRoom1 = pPath + 0x20
    pRoom1Address = self.process.read_ulonglong(pRoom1)
    pRoom2 = pRoom1Address + 0x18
    pRoom2Address = self.process.read_ulonglong(pRoom2)
    pLevel = pRoom2Address + 0x90
    pLevelAddress = self.process.read_ulonglong(pLevel)
    dwLevelNo = pLevelAddress + 0x1F8
    levelNo = self.process.read_uint(dwLevelNo)
    self._level_addr = dwLevelNo
    
    
    self.level = levelNo
    log = (&#34;:: current level      -&gt; &#34;+str(area_list[levelNo]))
    log_color(log,fg_color=0,bg_color=traverse_color)

    if not levelNo:
        log = &#34;!! Did not find level num using player offset&#34; +str(playerOffset)
        log_color(log,fg_color=0,bg_color=traverse_color)


    #get the map seed
    pAct = playerUnit + 0x20
    actAddress = self.process.read_ulonglong(pAct)


    if actAddress:
        mapSeedAddress = actAddress + 0x14
        if mapSeedAddress:
            mapSeed = self.process.read_uint(mapSeedAddress)
            self.map_seed = mapSeed
            #print(&#34;Found seed&#34;+str(mapSeed)+ &#34;at address&#34; +str(mapSeedAddress))
        else:
            log = (&#34;!! Did not find map seed at address&#34;+(mapSeedAddress))
            log_color(log,fg_color=0,bg_color=traverse_color)

    #get the level number
    actAddress = self.process.read_ulonglong(pAct)

    pActUnk1 = actAddress + 0x70
    aActUnk2 = self.process.read_ulonglong(pActUnk1)
    aDifficulty = aActUnk2 + 0x830
    difficulty = self.process.read_ushort(aDifficulty)
    self.difficulty=difficulty

    if difficulty==0:
        log = (&#34;:: current difficulty      -&gt; Normal&#34;)
        log_color(log,fg_color=0,bg_color=traverse_color)
    if difficulty==1:
        log = (&#34;:: current difficulty      -&gt; Nightmare&#34;)
        log_color(log,fg_color=0,bg_color=traverse_color)
    if difficulty==2:
        log = (&#34;:: current difficulty      -&gt; Hell&#34;)
        log_color(log,fg_color=0,bg_color=traverse_color)</code></pre>
</details>
</dd>
<dt id="d2read.proc.proc.find_items"><code class="name flex">
<span>def <span class="ident">find_items</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Summary</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_items(self):
    &#34;&#34;&#34;Summary
    &#34;&#34;&#34;
    items = []
    item_offset = self.starting_offset + (4*1024)

    for i in range(256):


        new_offset = item_offset +(8 *(i))
        item_addr = self.base + new_offset
        item_unit = self.process.read_longlong(item_addr)

        while (item_unit&gt;0):
            item_type = self.process.read_uint(item_unit+0x00)
            if item_type == 4:
                txt_file_no = self.process.read_uint(item_unit+0x04)
                item_loc = self.process.read_uint(item_unit+0x0C)

                # item loc 0 = inventory, 1 = equipped, 2 in belt, 3 on ground, 4 cursor, 5 dropping ,6 socketed
                if item_loc == 3 or item_loc == 5:
                    #print(&#34;item on ground&#34;)
                    p_unit_data = self.process.read_longlong(item_unit + 0x10)
                    #itemQuality - 5 is set, 7 is unique (6 rare, 4, magic)
                    item_quality = self.process.read_uint(p_unit_data)
                    p_path = self.process.read_longlong(item_unit+0x38)
                    item_x = self.process.read_ushort(p_path+0x10)
                    item_y = self.process.read_ushort(p_path+0x14)

                    p_stat_list_ex = self.process.read_longlong(item_unit + 0x88)
                    stat_ptr = self.process.read_longlong(p_stat_list_ex + 0x30)
                    stat_count = self.process.read_longlong(p_stat_list_ex + 0x38)
                    num_sockets = 0

                    for j in range(stat_count):
                        #print(&#34;checking for sockets&#34;)
                        stat_offset = (j)*8
                        stat_enum = self.process.read_ushort(stat_ptr+0x2+stat_offset)
                        if stat_enum == 194:
                            num_sockets = self.process.read_uint(stat_ptr+0x4+stat_offset)
                            #print(&#39;number of sockets -&gt;&#39;+str(num_sockets))
                            break

                    flags = self.process.read_uint(p_unit_data+0x18)


                    identified = False
                    if(0x00000010 &amp; flags):
                        identified = True
                        #print(&#34;id&#39;d&#34;)
                    ethereal = False
                    if(0x00400000 &amp; flags):
                        ethereal = True

                    quality=&#39;Any&#39;
                    if item_quality == 1:
                        quality = &#39;Inferior&#39;
                    if item_quality == 2:
                        quality = &#39;Normal&#39;
                    if item_quality == 3:
                        quality = &#39;Superior&#39;
                    if item_quality == 4:
                        quality = &#39;Magic&#39;
                    if item_quality == 5:
                        quality = &#39;Set&#39;
                    if item_quality == 6:
                        quality = &#39;Rare&#39;
                    if item_quality == 7:
                        quality = &#39;Unique&#39;
                    if item_quality == 8:
                        quality = &#39;Crafted&#39;
                    if item_quality == 9:
                        quality = &#39;Tempered&#39;

                    #print(txt_file_no)
                    if txt_file_no &gt;= 557 and txt_file_no &lt;= 586 or txt_file_no&gt;= 597 and txt_file_no&lt;= 601:
                        quality = &#39;Gem&#39;
                    if txt_file_no &gt;= 610 and txt_file_no &lt;= 642:
                        quality = &#39;Rune&#39;

                    item = (txt_file_no,quality,item_name[txt_file_no],item_quality,item_loc,item_x,item_y,num_sockets)


                    for category in self._loot_data:
                        q_match = 0
                        i_match = 0
                        loot_check = 0

                        data = self._loot_data.get(category)
                        quality_match = [&#39;Any&#39;]
                        item_match = [&#39;Any&#39;]
                        try:
                            quality_match = data[&#39;quality&#39;]
                        except:
                            quality_match = [&#39;Inferior&#39;,&#39;Normal&#39;,&#39;Superior&#39;,&#39;Magic&#39;,&#39;Set&#39;,&#39;Rare&#39;,&#39;Unique&#39;,&#39;Crafted&#39;,&#39;Tempered&#39;,&#39;Gem&#39;,&#39;Rune&#39;]
                            pass
                        try:
                            item_match = data[&#39;items&#39;]
                        except:
                            item_match = [&#39;Any&#39;]
                            pass

                        for q in quality_match:
                            if quality in q:
                                q_match=1

                        for i in item_match:
                            item_to_check = str(item_name[txt_file_no])
                            if num_sockets&gt;0:
                                item_to_check = str(item_name[txt_file_no])+&#39;,&#39;+str(num_sockets)
                            if item_to_check in i or item_match[0] is &#39;Any&#39;:
                                i_match=1

                        if q_match and i_match:
                            loot_check =1

                        try:
                            if data[&#39;ignoreidentified&#39;] is True and identified:
                                loot_check=0
                        except:
                            pass

                        if loot_check:
                            print(&#34;good to loot&#34;)
                            #self._move_to_mem(item_x,item_y)
                            print(item_name[txt_file_no])


                    #hard coded test for thul and ist
                    #if txt_file_no == 619 or txt_file_no == 620 or txt_file_no == 633:
                    #   self._move_to_mem(item_x,item_y)
                    #   print(items_list.item_name[txt_file_no])

                if item_loc == 4:
                    #print(&#34;item on cursor&#34;)
                    p_unit_data = self.process.read_longlong(item_unit + 0x10)
                    item_quality = self.process.read_longlong(p_unit_data)
                    p_path = self.process.read_longlong(item_unit+0x38)
                    item_x = self.process.read_ushort(p_path+0x10)
                    item_y = self.process.read_ushort(p_path+0x14)
                    #print(item_loc,item_type,txt_file_no)
                    #print(item_x,item_y)
                    

            item_unit = self.process.read_longlong(item_unit + 0x150)</code></pre>
</details>
</dd>
<dt id="d2read.proc.proc.find_mobs"><code class="name flex">
<span>def <span class="ident">find_mobs</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Summary</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_mobs(self):
    &#34;&#34;&#34;Summary
    &#34;&#34;&#34;
    monstersOffset = self.starting_offset + 1024
    mobs = []
    loc_monsters = []
    skel_count =0
    mage_count =0
    golem_count = &#39;none&#39;

    for i in range(128):
        newOffset = monstersOffset + (8 * (i - 1))
        mobAddress = self.base + newOffset
        mobUnit = self.process.read_longlong(mobAddress)
        
        while (mobUnit&gt; 0):

            txtFileNo = self.process.read_uint(mobUnit + 0x04)
            hide_check = 0
            try:
                hide_npc[txtFileNo]
            except:
                #no key 
                pass

            if not hide_check:

                mobTypeString = &#34;&#34;
                #
                unit_data = self.process.read_ulonglong(mobUnit + 0x10)
                mob_type = self.process.read_bytes(unit_data+0x1a,1)
                mob_type_int = int.from_bytes(mob_type,&#34;little&#34;)

                if mob_type_int == 0:
                    mobTypeString = &#39;None&#39;
                if mob_type_int == 1:
                    mobTypeString = &#39;Other&#39;
                if mob_type_int  == 10:
                    mobTypeString = &#39;SuperUnique&#39;
                if mob_type_int == 8:
                    mobTypeString = &#39;Unique&#39;
                if mob_type_int == 12:
                    mobTypeString = &#39;Champion&#39;                        
                if mob_type_int == 16:
                    mobTypeString = &#39;Minion&#39;
                if mob_type_int == 32:
                    mobTypeString = &#39;Possessed?&#39;
                if mob_type_int == 76:
                    mobTypeString = &#39;Ghostly&#39;
                if mob_type_int == 64:
                    mobTypeString = &#39;Multishot?&#39;
                    
                

                unitId = self.process.read_uint(mobUnit + 0x08)
                mode = self.process.read_uint(mobUnit + 0x0c)
                iscorpse = self.process.read_uchar (mobUnit + 0x1A6)
                interactable = self.process.read_uchar (mobUnit + 0x1A6+4)
                pUnitData = self.process.read_longlong(mobUnit + 0x10)
                pPath = self.process.read_longlong(mobUnit + 0x38)
            
                isUnique = self.process.read_ushort(pUnitData + 0x18)
                #????
                uniqueNo = self.process.read_ushort(pUnitData + 42)

                monx = self.process.read_ushort(pPath + 0x02)
                mony = self.process.read_ushort(pPath + 0x06)
                xPosOffset = self.process.read_ushort(pPath + 0x00) 
                yPosOffset = self.process.read_ushort(pPath + 0x04)
                xPosOffset = xPosOffset / 65536
                yPosOffset = yPosOffset / 65536
                monx = monx + xPosOffset
                mony = mony + yPosOffset

                #+026?
                #+017 - eLastMode
                #+018 - dwDuriel - set only for duriel
                #+01C - MonUModList[9] - nine bytes holding the Ids for each MonUMod assigned to the unit
                #+026 - bossNo - hcIdx from superuniques.txt for superuniques (word)
                #+028 - pAiGeneral
                BossLineID = self.process.read_ushort(unit_data + 0x2A) 

                isBoss = 0
                textTitle = None

                textTitle = get_mob_name[txtFileNo]

                if mob_type_int == 10:
                    try:
                        textTitle = super_unique_names[uniqueNo]
                    except:
                        pass
                if mob_type_int == 8:
                    try:
                        textTitle = get_mob_name[txtFileNo]
                    except:
                        pass
                    isBoss= 1


                #get immunities
                pStatsListEx = self.process.read_longlong(mobUnit + 0x88)
                ownerType = self.process.read_uint(pStatsListEx + 0x08)
                ownerId = self.process.read_uint(pStatsListEx + 0x0C)

                statPtr = self.process.read_longlong(pStatsListEx + 0x30)
                statCount = self.process.read_longlong(pStatsListEx + 0x38)

                #if(isUnique):
                    #print(textTitle,mobTypeString, mob_type_int)

                &#39;&#39;&#39;
                #these need to be added

                loadEncText(auraStrings[33], cfg-&gt;MightAura);
                loadEncText(auraStrings[35], cfg-&gt;HolyFireAura);
                loadEncText(auraStrings[40], cfg-&gt;BlessedAimAura);
                loadEncText(auraStrings[43], cfg-&gt;HolyFreezeAura);
                loadEncText(auraStrings[46], cfg-&gt;HolyShockAura);
                loadEncText(auraStrings[28], cfg-&gt;ConvictionAura);
                loadEncText(auraStrings[49], cfg-&gt;FanaticismAura);

                loadEncText(enchantStrings[5], cfg-&gt;encTxtExtraStrong);
                loadEncText(enchantStrings[6], cfg-&gt;encTxtExtraFast);
                loadEncText(enchantStrings[7], cfg-&gt;encTxtCursed);
                loadEncText(enchantStrings[8], cfg-&gt;encTxtMagicResistant);
                loadEncText(enchantStrings[9], cfg-&gt;encTxtFireEnchanted);
                loadEncText(enchantStrings[17], cfg-&gt;encTxtLigntningEnchanted);
                loadEncText(enchantStrings[18], cfg-&gt;encTxtColdEnchanted);
                loadEncText(enchantStrings[25], cfg-&gt;encTxtManaBurn);
                loadEncText(enchantStrings[26], cfg-&gt;encTxtTeleportation);
                loadEncText(enchantStrings[27], cfg-&gt;encTxtSpectralHit);
                loadEncText(enchantStrings[28], cfg-&gt;encTxtStoneSkin);
                loadEncText(enchantStrings[29], cfg-&gt;encTxtMultipleShots);
                loadEncText(enchantStrings[37], cfg-&gt;encTxtFanatic);
                loadEncText(enchantStrings[39], cfg-&gt;encTxtBerserker);

                &#39;&#39;&#39;
                #
                immunities = {&#39;physical&#39;: 0,&#39;magic&#39;: 0,&#39;fire&#39;: 0,&#39;light&#39;: 0,&#39;cold&#39;: 0,&#39;poison&#39;: 0}
                auras = {&#39;MightAura&#39;: 0,&#39;HolyFireAura&#39;: 0, &#39;BlessedAimAura&#39;: 0, &#39;HolyFreezeAura&#39;: 0, &#39;HolyShockAura&#39;: 0,&#39;ConvictionAura&#39;: 0,&#39;FanaticismAura&#39;:0}
                enchants = {&#39;ExtraStrong&#39;: 0,&#39;ExtraFast&#39;: 0, &#39;Cursed&#39;: 0, &#39;MagicResistant&#39;: 0, &#39;FireEnchanted&#39;: 0,&#39;LigntningEnchanted&#39;: 0,&#39;ColdEnchanted&#39;:0,&#39;ManaBurn&#39;:0,&#39;Teleportation&#39;:0,&#39;SpectralHit&#39;:0,&#39;StoneSkin&#39;:0,&#39;MultipleShots&#39;:0,&#39;Berserker&#39;:0}

                for s in range(statCount):
                    offset = (s -1) * 8
                    statParam = self.process.read_ushort(statPtr + offset)
                    statEnum = self.process.read_ushort(statPtr + 0x2 + offset)
                    statValue = self.process.read_uint(statPtr + 0x4 + offset)
                    if (statValue&gt;= 100):
                        if statEnum == 36:
                            immunities[&#34;physical&#34;] = 1 #physical immune      
                        if statEnum == 37:
                            immunities[&#34;magic&#34;] = 1    
                        if statEnum == 39:
                            immunities[&#34;fire&#34;] = 1
                        if statEnum == 41:
                            immunities[&#34;light&#34;] = 1  
                        if statEnum == 43:
                            immunities[&#34;cold&#34;] = 1
                        if statEnum == 45:
                            immunities[&#34;poison&#34;] = 1 
                self.get_ppos()
                dist = math.dist(self.player_world_pos,np.array([int(monx),int(mony)]))

                abs_screen_position = world_to_abs(np.array([monx,mony]), self.player_world_pos)
                mob = {&#39;position&#39;: np.array([int(monx),int(mony)]),&#39;dist&#39;: dist, &#39;abs_screen_position&#39;: abs_screen_position, &#39;immunities&#39;: immunities, &#39;unit_type&#39;: &#39;Monster&#39;, &#39;type&#39;: mobTypeString, &#39;id&#39;: unitId, &#39;name&#39;: textTitle, &#39;mode&#39;: mode, &#39;number&#39;: txtFileNo, &#39;super_unique&#39;:isUnique,&#39;boss&#39;:isBoss,&#39;is_corpse&#39;:iscorpse, &#39;interactable&#39;:interactable }
                
                # filter out some stuff and calculate summon count
                if textTitle is not None:
                    if &#39;ClayGolem&#39; in mob[&#39;name&#39;]:
                        if mob[&#39;mode&#39;] != 12:
                            golem_count = &#34;ClayGolem&#34;

                    elif &#39;FireGolem&#39; in mob[&#39;name&#39;]:
                        if mob[&#39;mode&#39;] != 12:
                            golem_count = &#34;FireGolem&#34;

                    elif &#39;BloodGolem&#39; in mob[&#39;name&#39;]:
                        if mob[&#39;mode&#39;] != 12:
                            golem_count = &#34;BloodGolem&#34;

                    elif &#39;IronGolem&#39; in mob[&#39;name&#39;]:
                        if mob[&#39;mode&#39;] != 12:
                            golem_count = &#34;IronGolem&#34;

                    elif &#39;NecroMage&#39; == mob[&#39;name&#39;]:
                        if mob[&#39;mode&#39;] != 12:
                            mage_count +=1

                    elif &#39;NecroSkeleton&#39; == mob[&#39;name&#39;]:
                        if mob[&#39;mode&#39;] != 12:
                            skel_count +=1
                    elif &#39;Rouge&#39; in mob[&#39;name&#39;]:
                        pass
                    elif &#39;Gaurd&#39; in mob[&#39;name&#39;]:
                        pass
                    elif &#39;Alkor&#39; in mob[&#39;name&#39;]:
                        pass
                    elif &#39;a trap&#39; in mob[&#39;name&#39;]:
                        pass
                    elif &#39;IronWolf&#39; in mob[&#39;name&#39;]:
                        pass
                    elif &#39;Malachai&#39; in mob[&#39;name&#39;]:
                        pass
                    elif mob[&#39;name&#39;] == &#39;&#39;:
                        pass
                    elif &#39;?&#39; in mob[&#39;name&#39;]:
                        pass
                    elif &#39;Barricade&#39; in mob[&#39;name&#39;]:
                        pass
                    else:
                        loc_monsters.append(mob)

                        #if dist&lt;5:
                        #    print(mob[&#39;name&#39;])

                        #    print(mob[&#39;id&#39;])
                        #    print(mob[&#39;number&#39;])

            #get next mob
            mobUnit = self.process.read_longlong(mobUnit + 0x150)
    self.monsters = loc_monsters
    self.botty_data[&#39;monsters&#39;] = loc_monsters
    if self.botty_data[&#39;necroSkel&#39;] != skel_count:
        self.botty_data[&#39;necroSkel&#39;]=skel_count
    if self.botty_data[&#39;necroMage&#39;] != mage_count:
        self.botty_data[&#39;necroMage&#39;]=mage_count
    if self.botty_data[&#39;necroGol&#39;]!=golem_count:
        self.botty_data[&#39;necroGol&#39;] = golem_count</code></pre>
</details>
</dd>
<dt id="d2read.proc.proc.find_objects"><code class="name flex">
<span>def <span class="ident">find_objects</span></span>(<span>self, file_number:int)</span>
</code></dt>
<dd>
<div class="desc"><p>Summary</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>file_number</code></strong> :&ensp;<code>int</code></dt>
<dd>Description</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>TYPE</code></dt>
<dd>Description</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_objects(self, file_number:int):
    &#34;&#34;&#34;Summary
    
    Args:
        file_number (int): Description
    
    Returns:
        TYPE: Description
    &#34;&#34;&#34;
    self.super_chests =[]
    object_offset = self.starting_offset + (2 * 1024)
    attempts=0


    for i in range(256):
        attempts=i+0
        new_offset = object_offset + (8 * (i-1))
        item_addr = self.base + new_offset
        object_unit = self.process.read_longlong(item_addr)

        #print(i)
        while (object_unit&gt;0):
            item_type = self.process.read_int(object_unit+0x00)
            pRoomnext = self.process.read_ulonglong(object_unit+0x158)
            #pRoomEx = self.process.read_ulonglong (pRoomnext+0x18)
            if(item_type==2):
                file_no = self.process.read_int(object_unit+0x04)
                if file_no == file_number:
                    print (&#34;Object found&#34;)
                    p_unit_data = self.process.read_ulonglong(object_unit + 0x10)
                    mode = self.process.read_uint (object_unit + 0x0C)
                    #pObjectTxt = self.process.read_ulonglong(p_unit_data)
                    #print(str(pObjectTxt))
                    #sObjectTxt = self.process.read_string(p_unit_data, 16)
                    #shrineTxt = self.process.read_string(p_unit_data + 0x0c, 16)
                    pPath = self.process.read_ulonglong(object_unit + 0x38)  
                    objectx = self.process.read_ushort(pPath + 0x10)
                    objecty = self.process.read_ushort(pPath + 0x14)
                    self.x_pos = self.process.read_ushort(self.path_addr+0x02)
                    self.y_pos = self.process.read_ushort(self.path_addr+0x06)
                    odist = math.dist([objectx,objecty],[self.x_pos,self.y_pos])
                    #print(self.y_pos)
                    #print(self.x_pos)
                    print(txt_obj_name[file_no-1] + &#34;&#34;+ str(str(file_no)))    
                    print(&#39;dist -&gt; &#39;+ str(odist))
                    obj = Object (objectx, objecty, mode)
                    return obj



            object_unit = self.process.read_longlong(object_unit + 0x150)</code></pre>
</details>
</dd>
<dt id="d2read.proc.proc.get_current_level"><code class="name flex">
<span>def <span class="ident">get_current_level</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Summary</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_current_level(self):
    &#34;&#34;&#34;Summary
    &#34;&#34;&#34;
    startingAddress = self.base + self.player_unit
    playerUnit = self.process.read_ulonglong(startingAddress)
    pUnitData = playerUnit + 0x10
    #get the level number
    pPathAddress = playerUnit + 0x38
    pPath = self.process.read_ulonglong(pPathAddress)
    pRoom1 = pPath + 0x20
    pRoom1Address = self.process.read_ulonglong(pRoom1)
    pRoom2 = pRoom1Address + 0x18
    pRoom2Address = self.process.read_ulonglong(pRoom2)
    pLevel = pRoom2Address + 0x90
    pLevelAddress = self.process.read_ulonglong(pLevel)
    dwLevelNo = pLevelAddress + 0x1F8
    levelNo = self.process.read_uint(dwLevelNo)
    self._level_addr = dwLevelNo
    self.level = levelNo</code></pre>
</details>
</dd>
<dt id="d2read.proc.proc.get_exp_offset"><code class="name flex">
<span>def <span class="ident">get_exp_offset</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Summary</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>TYPE</code></dt>
<dd>Description</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_exp_offset(self):
    &#34;&#34;&#34;Summary
    
    Returns:
        TYPE: Description
    &#34;&#34;&#34;
    #expansion offset
    pat = b&#39;\xC7\x05........\x48\x85\xC0\x0F\x84....\x83\x78\x5C.\x0F\x84....\x33\xD2\x41&#39;
    #this works fine, shorter pattern
    pat = b&#39;\xC7\x05........\x48\x85\xC0\x0F\x84....&#39;
    pat_addr = pymem.pattern.pattern_scan_module(self.handle, self.module, pat)
    offset_buffer = self.process.read_int(pat_addr-4)
    exp_offset = ((pat_addr - self.base) + offset_buffer)
    log = (&#34;:: Found exp offset        -&gt; {}&#34;.format(hex(exp_offset)))
    log_color(log,fg_color=0,bg_color=traverse_color)
    return exp_offset</code></pre>
</details>
</dd>
<dt id="d2read.proc.proc.get_game_info_offset"><code class="name flex">
<span>def <span class="ident">get_game_info_offset</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Summary</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>TYPE</code></dt>
<dd>Description</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_game_info_offset(self):
    &#34;&#34;&#34;Summary
    
    Returns:
        TYPE: Description
    &#34;&#34;&#34;
    #get game info offset
    pat = b&#39;\xE8....\x48\x8D\x0D....\x44\x88\x2D....&#39;
    pat_addr = pymem.pattern.pattern_scan_module(self.handle, self.module, pat)
    offset_buffer = self.process.read_int(pat_addr+8)
    game_info_offset = ((pat_addr - self.base)  + 7 -256 + 5 + offset_buffer)
    log = (&#34;:: Found game info offset  -&gt; {}&#34;.format(hex(game_info_offset)))
    log_color(log,fg_color=0,bg_color=traverse_color)
    return game_info_offset</code></pre>
</details>
</dd>
<dt id="d2read.proc.proc.get_hover_object_offset"><code class="name flex">
<span>def <span class="ident">get_hover_object_offset</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Summary</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>TYPE</code></dt>
<dd>Description</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_hover_object_offset(self):
    &#34;&#34;&#34;Summary
    
    Returns:
        TYPE: Description
    &#34;&#34;&#34;
    pat = b&#39;\xc6\x84\xc2.....\x48\x8b\x74.&#39;
    pat_addr = pymem.pattern.pattern_scan_module(self.handle, self.module, pat, return_multiple=False)
    offset_buffer = self.process.read_bytes(pat_addr+3,4)
    offset_buffer_int = int.from_bytes(offset_buffer,&#39;little&#39;)
    hover_offset = (offset_buffer_int)-1
    log = (&#34;:: Found hover offset        -&gt; {}&#34;.format(hex(hover_offset)))
    log_color(log,fg_color=0,bg_color=traverse_color)
    return hover_offset</code></pre>
</details>
</dd>
<dt id="d2read.proc.proc.get_last_hovered"><code class="name flex">
<span>def <span class="ident">get_last_hovered</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Summary</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_last_hovered(self):
    &#34;&#34;&#34;Summary
    &#34;&#34;&#34;
    offset = self.hoverd_offset
    is_hovered = self.process.read_int(offset+self.base+0x00)
    is_tooltip = self.process.read_int(offset+self.base+0x01)
    hovered_unit_type = self.process.read_int(offset+self.base+0x03)
    hoverd_id = self.process.read_uint(offset+self.base+0x08)

    for m in self.monsters:
        if hoverd_id == m[&#39;id&#39;] and is_hovered:
            print(m[&#39;name&#39;])
            break</code></pre>
</details>
</dd>
<dt id="d2read.proc.proc.get_map_d2api"><code class="name flex">
<span>def <span class="ident">get_map_d2api</span></span>(<span>self, seed)</span>
</code></dt>
<dd>
<div class="desc"><p>Get map values for input seed, using the piped api</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>seed</code></strong> :&ensp;<code>uint</code></dt>
<dd>current map seed</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_map_d2api(self,seed):
    &#34;&#34;&#34;Get map values for input seed, using the piped api
    
    Args:
        seed (uint): current map seed
    &#34;&#34;&#34;

    p = Popen([&#34;d2mapapi_piped.exe&#34;, &#34;C:/Program Files/Diablo II&#34;], stdin=PIPE, stdout=PIPE)
    #seed
    s = (seed).to_bytes(4,&#39;little&#39;)
    #difficulty
    d = (2).to_bytes(4,&#39;little&#39;)
    #map id
    m = (79).to_bytes(4,&#39;little&#39;)
    
    p.stdin.write(s)
    p.stdin.write(d)
    p.stdin.write(m)
    data,err = p.communicate()
    sd = data.decode(&#39;ascii&#39;,&#39;ignore&#39;)
    #nasty 
    sd = sd[sd.find(&#39;{&#39;):]
    j = json.loads(sd,strict=False) 
    obj = j[&#39;objects&#39;]
    #get chests....
    chests = obj[&#39;580&#39;]
    #print(sd)
    map_offset_x = j[&#39;offset&#39;][&#39;x&#39;]
    map_offset_y = j[&#39;offset&#39;][&#39;y&#39;]
    self.chests = chests
    self.map_ox = map_offset_x
    self.map_oy = map_offset_y</code></pre>
</details>
</dd>
<dt id="d2read.proc.proc.get_map_json"><code class="name flex">
<span>def <span class="ident">get_map_json</span></span>(<span>self, seed, mapid:int, objectIDs:list=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Summary</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>seed</code></strong> :&ensp;<code>TYPE</code></dt>
<dd>current map seed read from memory</dd>
<dt><strong><code>mapid</code></strong> :&ensp;<code>int</code></dt>
<dd>current in game map number</dd>
<dt><strong><code>objectIDs</code></strong> :&ensp;<code>list</code>, optional</dt>
<dd>Description</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>TYPE</code></dt>
<dd>Description</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_map_json(self,seed, mapid:int, objectIDs:list=None):
    &#34;&#34;&#34;Summary
    
    Args:
        seed (TYPE): current map seed read from memory
        mapid (int): current in game map number
        objectIDs (list, optional): Description
    
    Returns:
        TYPE: Description
    &#34;&#34;&#34;

    #url for map api
    base_url=&#39;http://34.69.54.92:8000&#39;    
    url=base_url+&#39;/&#39;+str(seed)+f&#39;/2/{str(mapid)}/1&#39;

    log = (&#34;:: Got data from           -&gt; {}&#34;.format(url))
    log_color(log,fg_color=0,bg_color=traverse_color)
    resp = requests.get(url=url)
    j = resp.json()

    obj = j[&#39;objects&#39;]
    if objectIDs is not None:
        for objectID in objectIDs:
            self.responseList.append (obj[objectID])
    map_offset_x = j[&#39;offset&#39;][&#39;x&#39;]
    map_offset_y = j[&#39;offset&#39;][&#39;y&#39;]

    map_offset =np.array([map_offset_x,map_offset_y])


    self.map_offset = map_offset
    row = []
    for point in j[&#39;mapData&#39;]:
        if point != -1:
            row.append (point)
        else:
            self.grid.append (row)
            row = []              
    
    

    def split(a, sep):
        &#34;&#34;&#34;Summary
        
        Args:
            a (TYPE): Description
            sep (TYPE): Description
        
        Yields:
            TYPE: Description
        &#34;&#34;&#34;
        pos = i = 0
        while i &lt;len(a):
            if a[i:i+len(sep)] == sep:
                yield a[pos:i]
                pos = i = i+len(sep)
            else:
                i += 1
        yield a[pos:i]

    points_of_interest = []
    map_objects = []

    if j != None:
        map_crop = j[&#39;crop&#39;]
        obj_str = &#34;|&#34;
        poi_str = &#34;|&#34;
        #these are mostly garbage and not useful, its map decorator stuff
        for key in j[&#39;objects&#39;]:
            value = j[&#39;objects&#39;][key]
            name = objects[int(key)]
            obj_str+=name+&#34;|&#34;
            #print(int(key),name)
            for instance in value:
                offset_x =instance[&#39;x&#39;]
                offset_y=instance[&#39;y&#39;]
                pos =np.array([offset_x,offset_y])
                pos_area = pos-map_offset
                flag = 0
                new_obj = {&#34;position&#34;:pos,&#34;flag&#34;:1,&#34;name&#34;:name,&#34;pos_area&#34;:pos_area}
                map_objects.append(new_obj)
                break

        #filter ut way points from the objects list
        for key in j[&#39;objects&#39;]:
            value = j[&#39;objects&#39;][key]
            name = objects[int(key)]
            if &#39;waypoint&#39; in name or &#39;Waypoint&#39; in name:
                poi_str+=name+&#34;|&#34;
                #print(int(key),name)
                for instance in value:
                    offset_x =instance[&#39;x&#39;]
                    offset_y=instance[&#39;y&#39;]
                    pos =np.array([offset_x,offset_y])
                    pos_area = pos-map_offset
                    flag = 0
                    new_obj = {&#34;position&#34;:pos,&#34;flag&#34;:1,&#34;label&#34;:name,&#34;pos_area&#34;:pos_area}
                    points_of_interest.append(new_obj)
                    break

        #convert exits to a uniform format in poi
        for key in j[&#39;exits&#39;]:
            value = j[&#39;exits&#39;][key]
            name = areas[int(key)]
            poi_str+=name+&#34;|&#34;
            is_portal = value[&#39;isPortal&#39;]
            offset_x = value[&#39;offsets&#39;][0][&#39;x&#39;]
            offset_y = value[&#39;offsets&#39;][0][&#39;y&#39;]
            pos =np.array([offset_x,offset_y])
            pos_area = pos-map_offset
            new_poi = {&#34;position&#34;:pos,&#34;type&#34;:1,&#34;label&#34;:name,&#34;pos_area&#34;:pos_area}
            points_of_interest.append(new_poi)
        #convert npcs to a uniform format
        if j[&#39;npcs&#39;] is not None:
            for key in j[&#39;npcs&#39;]:
                if int(key)&lt;738:
                    value = j[&#39;npcs&#39;][key]
                    name = get_mob_name[int(key)]
                    poi_str+=name+&#34;|&#34;
                    is_portal=False
                    is_npc=True
                    offset_x = value[0][&#39;x&#39;]
                    offset_y = value[0][&#39;y&#39;]
                    pos = np.array([offset_x,offset_y])
                    pos_area = pos-map_offset
                    new_poi = {&#34;position&#34;:pos,&#34;type&#34;:1,&#34;label&#34;:name,&#34;pos_area&#34;:pos_area}
                    points_of_interest.append(new_poi)

        map_id = j[&#39;id&#39;]
        map_data = j[&#39;mapData&#39;]
        #map_offset = j[&#39;offset&#39;]
        map_size = j[&#39;size&#39;]
        map_decode = list(split(map_data,sep=[-1]))

        self.area_origin = map_offset
        self.botty_data[&#39;area_origin&#39;] = map_offset

        nodes = []
        col_grid = []

        #map_decode.pop(-1)

        collision_grid = np.empty([int(map_size[&#39;height&#39;]),int(map_size[&#39;width&#39;])], dtype=np.uint8)
        
        if map_data != None:
            mini_map_w=int(map_size[&#39;width&#39;])
            mini_map_h=int(map_size[&#39;height&#39;])
            walkable = True
            y = 0
            for ele in map_decode:
                x = 0
                row = []
                for i in range(len(ele)):
                    if walkable:
                        for j in range(ele[i]):
                            nodes.append([x,y,walkable])
                            row.append(0)
                            collision_grid[y][x] = 0
                            x+=1
                    if not walkable:
                        for j in range(ele[i]):
                            nodes.append([x,y,walkable])
                            row.append(-1)
                            collision_grid[y][x] = -1
                            x+=1

                    walkable = not walkable
                y+=1
                col_grid.append(row)
                x=0
                walkable = True
        

        new_map = {&#34;crop&#34;: map_crop,&#34;id&#34;: map_id,&#39;poi&#39;: points_of_interest,&#34;objects&#34;: map_objects,&#34;size&#34;: map_size,&#34;nodes&#34;:nodes,&#34;data&#34;:col_grid}

        log = (&#34;:: Loaded map              -&gt; {}&#34;.format(area_list[new_map[&#39;id&#39;]]))
        self.current_area=area_list[new_map[&#39;id&#39;]]
        self.botty_data[&#39;current_area&#39;]=area_list[new_map[&#39;id&#39;]]


        log_color(log,fg_color=0,bg_color=traverse_color)
        log = (&#34;:: Number of POI           -&gt; {}&#34;.format(len(points_of_interest)))
        log_color(log,fg_color=0,bg_color=traverse_color)
        log = (&#34;:: {}&#34;.format(poi_str))
        log_color(log,fg_color=0,bg_color=traverse_color)
        log = (&#34;:: Number of OBJ           -&gt; {}&#34;.format(len(map_objects)))
        log_color(log,fg_color=0,bg_color=traverse_color)
        log = (&#34;:: {}&#34;.format(obj_str))
        log_color(log,fg_color=0,bg_color=traverse_color)

        self.maps.append(new_map)
        self.botty_data[&#39;poi&#39;] = points_of_interest
        self.botty_data[&#39;objects&#39;] = map_objects
        self.botty_data[&#39;map&#39;]= collision_grid #np.array(collision_grid, dtype=np.uint8)
        return self.responseList</code></pre>
</details>
</dd>
<dt id="d2read.proc.proc.get_map_json_exit"><code class="name flex">
<span>def <span class="ident">get_map_json_exit</span></span>(<span>self, seed, mapid:int, objectIDs:list=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Summary</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>seed</code></strong> :&ensp;<code>TYPE</code></dt>
<dd>Description</dd>
<dt><strong><code>mapid</code></strong> :&ensp;<code>int</code></dt>
<dd>Description</dd>
<dt><strong><code>objectIDs</code></strong> :&ensp;<code>list</code>, optional</dt>
<dd>Description</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>TYPE</code></dt>
<dd>Description</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_map_json_exit(self,seed, mapid:int, objectIDs:list=None):
    &#34;&#34;&#34;Summary
    
    Args:
        seed (TYPE): Description
        mapid (int): Description
        objectIDs (list, optional): Description
    
    Returns:
        TYPE: Description
    &#34;&#34;&#34;
    #map hosting
    base_url=&#39;http://34.69.54.92:8000&#39;
    url=base_url+&#39;/&#39;+str(seed)+f&#39;/2/{str(mapid)}/1&#39;
    #
    print(url)
    resp = requests.get(url=url)
    j = resp.json()
    #data = json.loads(data,strict=False)   
    with open(&#39;data.json&#39;, &#39;w&#39;) as f:
        json.dump(j, f)
    obj = j[&#39;exits&#39;]
    obj = obj [str(objectIDs)]
    
    #print(sd)
    map_offset_x = j[&#39;offset&#39;][&#39;x&#39;]
    map_offset_y = j[&#39;offset&#39;][&#39;y&#39;]
    #self.chests = chests
    self.map_ox = map_offset_x
    self.map_oy = map_offset_y
    return obj[&#39;offsets&#39;]</code></pre>
</details>
</dd>
<dt id="d2read.proc.proc.get_menu_data_offset"><code class="name flex">
<span>def <span class="ident">get_menu_data_offset</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Summary</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>TYPE</code></dt>
<dd>Description</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_menu_data_offset(self):
    &#34;&#34;&#34;Summary
    
    Returns:
        TYPE: Description
    &#34;&#34;&#34;
    #unit table offset
    pat = b&#34;\x41\x0f\xb6\xac\x3f....&#34;
    pat_addr = pymem.pattern.pattern_scan_module(self.handle, self.module, pat)
    offset_buffer = self.process.read_int(pat_addr-5)
    ui_offset = ((pat_addr - self.base) + offset_buffer)
    log = (&#34;:: Found menu data offset  -&gt; {}&#34;.format(hex(ui_offset)))
    log_color(log,fg_color=0,bg_color=traverse_color)
    #ui_offset =  0x21F89AA
    return ui_offset</code></pre>
</details>
</dd>
<dt id="d2read.proc.proc.get_menu_vis_offset"><code class="name flex">
<span>def <span class="ident">get_menu_vis_offset</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Summary</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>TYPE</code></dt>
<dd>Description</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_menu_vis_offset(self):
    &#34;&#34;&#34;Summary
    
    Returns:
        TYPE: Description
    &#34;&#34;&#34;
    #menu vis offset
    #pat = b&#39;\x8B\x05....\x89\x44\x24\x20\x74\x07&#39;
    #?? search less direct matches?
    pat = b&#39;\x8B\x05....\x89\x44.\x20\x74\x07&#39;
    pat_addr = pymem.pattern.pattern_scan_module(self.handle, self.module, pat)
    offset_buffer = self.process.read_int(pat_addr+2)
    #maybe dont need +6 here?
    menu_offset = ((pat_addr - self.base) + 6 + offset_buffer)
    log = (&#34;:: Found menu offset       -&gt; {}&#34;.format(hex(menu_offset)))
    log_color(log,fg_color=0,bg_color=traverse_color)
    return menu_offset</code></pre>
</details>
</dd>
<dt id="d2read.proc.proc.get_player_offset"><code class="name flex">
<span>def <span class="ident">get_player_offset</span></span>(<span>self, loops)</span>
</code></dt>
<dd>
<div class="desc"><p>Summary</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>loops</code></strong> :&ensp;<code>TYPE</code></dt>
<dd>Description</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>TYPE</code></dt>
<dd>Description</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_player_offset(self,loops):
    &#34;&#34;&#34;Summary
    
    Args:
        loops (TYPE): Description
    
    Returns:
        TYPE: Description
    &#34;&#34;&#34;
    found = False
    #ui_offset = 0x21F89AA
    attempts=0
    name = &#34;&#34;
    new_offset=0

    for i in range(loops):
        attempts=i+0
        new_offset = (self.starting_offset)+(attempts-1)*8

        start_addr = self.base + new_offset

        player_unit = self.process.read_longlong(start_addr)
        #print (player_unit)
        while player_unit&gt;0:
            p_inventory = player_unit+0x90
            inventory = self.process.read_longlong(p_inventory)
            if(inventory):
                log = (&#34;:: Found inventory offset  -&gt; {}&#34;.format(hex(self.base-inventory)))
                log_color(log,fg_color=0,bg_color=traverse_color)
                exp_char = self.process.read_ushort(self.base+self.exp_offset)
                base_check = self.process.read_ushort(inventory+0x30) !=1
                if(exp_char):
                    log = (&#34;:: Expansion char          -&gt; True&#34;)
                    log_color(log,fg_color=0,bg_color=traverse_color)
                    base_check = self.process.read_ushort(inventory+0x70) !=0

            if(base_check):
                #print(&#34;base checks&#34;)
                p_act = player_unit+0x20
                act_addr = self.process.read_ulonglong(p_act)
                map_seed_addr = act_addr +0x14
                map_seed = self.process.read_uint(map_seed_addr)
                self.map_seed = map_seed
                #print(map_seed)
                p_path = player_unit+0x38
                path_addr = self.process.read_longlong(p_path)

                x_pos = self.process.read_ushort(path_addr+0x02)
                #print (x_pos)
                y_pos = self.process.read_ushort(path_addr+0x06)
                #print (y_pos)
                p_unit_data = player_unit +0x10
                try:
                    player_name_addr = self.process.read_longlong(p_unit_data)
                except:
                    pass
                p_name = &#34;&#34;
                #
                for i in range(16):
                    name = name + str(chr(self.process.read_uchar(player_name_addr+i-1)))

                if(x_pos&gt; 0 and y_pos &gt;0 and len(str(map_seed))&gt;6):
                    if loops &gt; 1:
                        log = (&#34;:: Found player name       -&gt; {}&#34;.format(name))
                        log_color(log,fg_color=0,bg_color=traverse_color)
                        log = (&#34;:: Found map seed          -&gt; {}&#34;.format(map_seed))
                        log_color(log,fg_color=0,bg_color=traverse_color)
                    new_offset = new_offset+0
                    found = True
                    self.player_unit = new_offset
                    self.path_addr = path_addr
                    return True

            new_offset = (player_unit+0x150)-self.base
            try:
                player_unit = self.process.read_longlong(player_unit +0x150)
            except:
                pass</code></pre>
</details>
</dd>
<dt id="d2read.proc.proc.get_ppos"><code class="name flex">
<span>def <span class="ident">get_ppos</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Summary</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_ppos(self):
    &#34;&#34;&#34;Summary
    &#34;&#34;&#34;
    x = self.process.read_ushort(self.path_addr+0x02)
    y = self.process.read_ushort(self.path_addr+0x06)
    self.player_world_pos = np.array([x,y])
    self.botty_data[&#39;player_pos_area&#39;] =self.player_world_pos -self.area_origin
    self.botty_data[&#39;player_pos_world&#39;] = self.player_world_pos</code></pre>
</details>
</dd>
<dt id="d2read.proc.proc.get_ui_settings_offset"><code class="name flex">
<span>def <span class="ident">get_ui_settings_offset</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Summary</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>TYPE</code></dt>
<dd>Description</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_ui_settings_offset(self):
    &#34;&#34;&#34;Summary
    
    Returns:
        TYPE: Description
    &#34;&#34;&#34;
    #unit table offset
    pat = b&#34;\x40\x84\xed\x0f\x94\x05&#34;
    pat_addr = pymem.pattern.pattern_scan_module(self.handle, self.module, pat)
    offset_buffer = self.process.read_int(pat_addr+6)
    ui_offset = ((pat_addr - self.base) + 10 + offset_buffer)
    log = (&#34;:: Found ui offset         -&gt; {}&#34;.format(hex(ui_offset)))
    log_color(log,fg_color=0,bg_color=traverse_color)
    #ui_offset =  0x21F89AA
    return ui_offset</code></pre>
</details>
</dd>
<dt id="d2read.proc.proc.get_unit_offset"><code class="name flex">
<span>def <span class="ident">get_unit_offset</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>doc string</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>TYPE</code></dt>
<dd>Description</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_unit_offset(self):
    &#39;&#39;&#39;doc string
    
    Returns:
        TYPE: Description
    &#39;&#39;&#39;
    #unit table offset
    pat = b&#34;\x48\x8d.....\x8b\xd1&#34;
    pat_addr = pymem.pattern.pattern_scan_module(self.handle, self.module, pat)
    offset_buffer = self.process.read_int(pat_addr+3)
    player_offset = ((pat_addr - self.base) + 7 + offset_buffer)
    log = (&#34;:: Found player offset     -&gt; {}&#34;.format(hex(player_offset)))
    log_color(log,fg_color=0,bg_color=traverse_color)
    return player_offset</code></pre>
</details>
</dd>
<dt id="d2read.proc.proc.normalized_p"><code class="name flex">
<span>def <span class="ident">normalized_p</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Summary</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def normalized_p(self):
    &#34;&#34;&#34;Summary
    &#34;&#34;&#34;
    self.np_x = float(self.map_ox)/float(self.process.read_ushort(self.path_addr+0x02))
    self.np_y = float(self.map_oy)/float(self.process.read_ushort(self.path_addr+0x06))</code></pre>
</details>
</dd>
<dt id="d2read.proc.proc.read_loot_cfg"><code class="name flex">
<span>def <span class="ident">read_loot_cfg</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_loot_cfg(self):
    with open(&#34;Z:/botty-r-latest/src/read_mem/item_filter.yaml&#34;, &#34;r&#34;) as stream:
        try:
            loot_filter = yaml.safe_load(stream)
            #print(loot_filter)
            &#39;&#39;&#39;
            for category in loot_filter:
                print(str(category))
                #for item in loot_filter.get(category):
                print(loot_filter.get(category))
            &#39;&#39;&#39;
                #for value in key:
                #   print(str(value))
            self._loot_data = loot_filter
        except yaml.YAMLError as exc:
            print(exc)</code></pre>
</details>
</dd>
<dt id="d2read.proc.proc.ui_status"><code class="name flex">
<span>def <span class="ident">ui_status</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Summary</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ui_status(self):
    &#34;&#34;&#34;Summary
    &#34;&#34;&#34;
    InGame = False
    Inventory =  False
    Character =  False
    SkillSelect = False
    SkillTree = False
    Chat = False
    NpcInteract =  False
    EscMenu = False
    Map = False
    NpcShop = False
    QuestLog = False
    Waypoint = False
    Party = False
    Stash = False
    Cube = False
    AltPick = False
    Potions=False

    offset = self.ui_settings_offset
    ui = self.base + offset
    item_pick = self.process.read_ushort(ui+2)
    quit_menu = self.process.read_bytes(ui-0x01,1)
    quit_menu_int = int.from_bytes(quit_menu,&#34;little&#34;)
    quest_menu = self.process.read_bytes(ui+0x04,1)
    quest_menu_int = int.from_bytes(quest_menu,&#34;little&#34;)
    skill_menu = self.process.read_bytes(ui-0x06,1)
    skill_menu_int = int.from_bytes(skill_menu,&#34;little&#34;)
    char_menu = self.process.read_bytes(ui-0x08,1)
    char_menu_int = int.from_bytes(char_menu,&#34;little&#34;)
    stash_menu = self.process.read_bytes(ui-0x19+0x28-1,1)
    stash_menu_int = int.from_bytes(stash_menu,&#34;little&#34;)
    npc_menu = self.process.read_bytes(ui+1,1)
    npc_menu_int = int.from_bytes(npc_menu,&#34;little&#34;)
    inv_menu = self.process.read_bytes(ui-0x09,1)
    inv_menu_int = int.from_bytes(inv_menu,&#34;little&#34;)
    merc_menu = self.process.read_ushort(ui+0x14)
    party_menu = self.process.read_bytes(ui+0x0b,1)
    party_menu_int = int.from_bytes(party_menu,&#34;little&#34;)
    waypoint_menu = self.process.read_bytes(ui+0x09,1)
    #ugh why
    waypoint_menu_int = int.from_bytes(waypoint_menu,&#34;little&#34;)
    in_game = self.process.read_bytes(ui+0x08,1)
    in_game_int = int.from_bytes(in_game,&#34;little&#34;)

    cube_menu = self.process.read_bytes(ui-0x19+0x28,1)
    cube_menu_int = int.from_bytes(cube_menu,&#34;little&#34;)
    
    map_menu = self.process.read_bytes(ui-0x19+0x28-15,1)
    map_menu_int = int.from_bytes(map_menu,&#34;little&#34;)

    potion_menu = self.process.read_bytes(ui-0x19+0x28+1,1)
    potion_menu_int = int.from_bytes(potion_menu,&#34;little&#34;)

    npc_interact = self.process.read_bytes(ui-0x19+0x28-0x11,1)
    npc_interact_int = int.from_bytes(npc_interact,&#34;little&#34;)
    

    chat = self.process.read_bytes(ui-0x19+0x28-0x11-3,1)
    chat_int = int.from_bytes(chat,&#34;little&#34;)

    if chat_int:
        Chat=True
        #print(&#34;chattings&#34;)
    if npc_interact_int:
        NpcInteract=True
        #print(&#39;talkign to npc&#39;)
    if potion_menu_int:
        Potions=True
        #print(&#39;pOtioOn is active&#39;)
    if map_menu_int:
        Map=True
        #print(&#39;Map is active&#39;)
    if cube_menu_int:
        Cube=True
        #print(&#39;Cube is active&#39;)
    if in_game_int:
        #print(&#39;in game&#39;) #works
        InGame=True
    if stash_menu_int:
        #print(&#39;stash menu is  active&#39;)
        Stash=True
    if npc_menu_int:
        #print(&#39;npc menu is  active&#39;)
        NpcShop=True
    if party_menu_int:
        #print(&#39;party menu is  active&#39;)
        Party=True
    if inv_menu_int:
        #print(&#39;inv menu is  active&#39;)
        Inventory=True
    if waypoint_menu_int:
        #print(&#39;waypoint menu is  active&#39;)
        Waypoint=True
    if quit_menu_int:
        EscMenu=True
        #print(&#39;!!!quit menu is  active&#39;)
    if item_pick:
        AltPick=True
        #print(&#39;item pick is active&#39;)
    if quest_menu_int:
        QuestLog=True
        #print(&#39;Quest log is active&#39;)
    if char_menu_int:
        Character=True
        #print(&#39;Char menu is active&#39;)
    if skill_menu_int:
        SkillTree=True
        #print(&#39;Skill tree is active&#39;)

    self.menus =    {&#39;InGame&#39;: InGame,
                    &#39;Inventory&#39;: Inventory,
                    &#39;Character&#39;: Character,
                    &#39;SkillSelect&#39;: SkillSelect,
                    &#39;SkillTree&#39;: SkillTree,
                    &#39;Chat&#39;: Chat,
                    &#39;NpcInteract&#39;: NpcInteract,
                    &#39;EscMenu&#39;: EscMenu,
                    &#39;Map&#39;: Map,
                    &#39;NpcShop&#39;: NpcShop,
                    &#39;QuestLog&#39;: QuestLog,
                    &#39;Waypoint&#39;: Waypoint,
                    &#39;Party&#39;: Party,
                    &#39;Stash&#39;: Stash,
                    &#39;Cube&#39;: Cube,
                    &#39;AltPick&#39;:AltPick,
                    &#39;Potions&#39;:Potions
                    }</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div id="dark-mode-toggle" onclick="toggleDarkMode()">
<svg class="dm-icon-off" viewBox="0 0 16 16">
<path d="M7 0h2v2H7zM12.88 1.637l1.414 1.415-1.415 1.413-1.414-1.414zM14 7h2v2h-2zM12.95 14.433l-1.415-1.414 1.414-1.414 1.415 1.413zM7 14h2v2H7zM2.98 14.363L1.566 12.95l1.415-1.414 1.414 1.415zM0 7h2v2H0zM3.05 1.707L4.465 3.12 3.05 4.535 1.636 3.121z" />
<path d="M8 4C5.8 4 4 5.8 4 8s1.8 4 4 4 4-1.8 4-4-1.8-4-4-4z" />
</svg>
<svg class="dm-icon-on" viewBox="0 0 16 16">
<path d="M6,0C2.5,0.9,0,4.1,0,7.9C0,12.4,3.6,16,8.1,16c3.8,0,6.9-2.5,7.9-6C9.9,11.7,4.3,6.1,6,0z"></path>
</svg>
</div>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="d2read" href="index.html">d2read</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="d2read.proc.proc" href="#d2read.proc.proc">proc</a></code></h4>
<ul class="">
<li><code><a title="d2read.proc.proc.chest_dist" href="#d2read.proc.proc.chest_dist">chest_dist</a></code></li>
<li><code><a title="d2read.proc.proc.find_info" href="#d2read.proc.proc.find_info">find_info</a></code></li>
<li><code><a title="d2read.proc.proc.find_items" href="#d2read.proc.proc.find_items">find_items</a></code></li>
<li><code><a title="d2read.proc.proc.find_mobs" href="#d2read.proc.proc.find_mobs">find_mobs</a></code></li>
<li><code><a title="d2read.proc.proc.find_objects" href="#d2read.proc.proc.find_objects">find_objects</a></code></li>
<li><code><a title="d2read.proc.proc.get_current_level" href="#d2read.proc.proc.get_current_level">get_current_level</a></code></li>
<li><code><a title="d2read.proc.proc.get_exp_offset" href="#d2read.proc.proc.get_exp_offset">get_exp_offset</a></code></li>
<li><code><a title="d2read.proc.proc.get_game_info_offset" href="#d2read.proc.proc.get_game_info_offset">get_game_info_offset</a></code></li>
<li><code><a title="d2read.proc.proc.get_hover_object_offset" href="#d2read.proc.proc.get_hover_object_offset">get_hover_object_offset</a></code></li>
<li><code><a title="d2read.proc.proc.get_last_hovered" href="#d2read.proc.proc.get_last_hovered">get_last_hovered</a></code></li>
<li><code><a title="d2read.proc.proc.get_map_d2api" href="#d2read.proc.proc.get_map_d2api">get_map_d2api</a></code></li>
<li><code><a title="d2read.proc.proc.get_map_json" href="#d2read.proc.proc.get_map_json">get_map_json</a></code></li>
<li><code><a title="d2read.proc.proc.get_map_json_exit" href="#d2read.proc.proc.get_map_json_exit">get_map_json_exit</a></code></li>
<li><code><a title="d2read.proc.proc.get_menu_data_offset" href="#d2read.proc.proc.get_menu_data_offset">get_menu_data_offset</a></code></li>
<li><code><a title="d2read.proc.proc.get_menu_vis_offset" href="#d2read.proc.proc.get_menu_vis_offset">get_menu_vis_offset</a></code></li>
<li><code><a title="d2read.proc.proc.get_player_offset" href="#d2read.proc.proc.get_player_offset">get_player_offset</a></code></li>
<li><code><a title="d2read.proc.proc.get_ppos" href="#d2read.proc.proc.get_ppos">get_ppos</a></code></li>
<li><code><a title="d2read.proc.proc.get_ui_settings_offset" href="#d2read.proc.proc.get_ui_settings_offset">get_ui_settings_offset</a></code></li>
<li><code><a title="d2read.proc.proc.get_unit_offset" href="#d2read.proc.proc.get_unit_offset">get_unit_offset</a></code></li>
<li><code><a title="d2read.proc.proc.normalized_p" href="#d2read.proc.proc.normalized_p">normalized_p</a></code></li>
<li><code><a title="d2read.proc.proc.read_loot_cfg" href="#d2read.proc.proc.read_loot_cfg">read_loot_cfg</a></code></li>
<li><code><a title="d2read.proc.proc.ui_status" href="#d2read.proc.proc.ui_status">ui_status</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>