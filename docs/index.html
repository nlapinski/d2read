<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>d2read API documentation</title>
<meta name="description" content="proc - handles reading memory from the d2r process." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link id="hljs" rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/a11y-dark.min.css" crossorigin>
<style id="css-theme">
:root[data-theme='theme-light']{--bg-highlight-color:#FFEE99;--bg-default:#FFFFFF;--bg-code:#EEEEEE;--bg-code-hover:#e0e0e0;--fc-default:#0F1A20;--fc-muted:#666666;--link-primary:#005588;--link-hover:#ee8822;--ident-primary:#990000;--hr-default:#666666;--bd-default:#DDDDDD;--bd-pre:#DDDDDD;--bd-primary:#666666;--adm-note:#abeeff;--adm-todo:#ddffdd;--adm-warning:#ffdd44;--adm-error:#feb6c1;--adm-bd-note:#abeeff;--adm-bd-todo:#ddffdd;--adm-bd-warning:#ffdd44;--adm-bd-error:#feb6c1}:root[data-theme='theme-dark']{--bg-highlight-color:#3e4951;--bg-default:#22282D;--bg-code:#3e4951;--bg-code-hover:#313b42;--fc-default:#ACBAC7;--fc-muted:#ACBAC7;--link-primary:#539bf5;--link-hover:#abcdf9;--ident-primary:#539bf5;--hr-default:#444d56;--bd-default:#444d56;--bd-pre:#3e4951;--bd-primary:#539bf5;--adm-note:rgba(65,132,288,0.1);--adm-todo:rgba(165,255,169,0.1);--adm-warning:rgba(255,221,68,0.2);--adm-error:rgba(254,182,193,0.2);--adm-bd-note:#539bf5;--adm-bd-todo:#a5ffa9;--adm-bd-warning:#ffdd44;--adm-bd-error:#feb6c1}@media (prefers-color-scheme:light){:root[data-theme='theme-light']{--bg-highlight-color:#FFEE99;--bg-default:#FFFFFF;--bg-code:#EEEEEE;--bg-code-hover:#e0e0e0;--fc-default:#0F1A20;--fc-muted:#666666;--link-primary:#005588;--link-hover:#ee8822;--ident-primary:#990000;--hr-default:#666666;--bd-default:#DDDDDD;--bd-pre:#DDDDDD;--bd-primary:#666666;--adm-note:#abeeff;--adm-todo:#ddffdd;--adm-warning:#ffdd44;--adm-error:#feb6c1;--adm-bd-note:#abeeff;--adm-bd-todo:#ddffdd;--adm-bd-warning:#ffdd44;--adm-bd-error:#feb6c1}}@media (prefers-color-scheme:dark){:root[data-theme='theme-dark']{--bg-highlight-color:#3e4951;--bg-default:#22282D;--bg-code:#3e4951;--bg-code-hover:#313b42;--fc-default:#ACBAC7;--fc-muted:#ACBAC7;--link-primary:#539bf5;--link-hover:#abcdf9;--ident-primary:#539bf5;--hr-default:#444d56;--bd-default:#444d56;--bd-pre:#3e4951;--bd-primary:#539bf5;--adm-note:rgba(65,132,288,0.1);--adm-todo:rgba(165,255,169,0.1);--adm-warning:rgba(255,221,68,0.2);--adm-error:rgba(254,182,193,0.2);--adm-bd-note:#539bf5;--adm-bd-todo:#a5ffa9;--adm-bd-warning:#ffdd44;--adm-bd-error:#feb6c1}}
html {
background-color: var(--bg-default);
cursor: auto;
}
#dark-mode-toggle {
display: none;
border: 1px solid;
border-color: var(--bd-primary);
color: var(--bd-primary);
border-radius: 20px;
padding-left: 6px;
padding-right: 6px;
cursor: pointer;
}
.hidden {
visibility: hidden;
}
.dm-icon-off, .dm-icon-on {
display: inline;
width: 14px;
height: 14px;
margin-bottom: 4px;
}
h1:target,
h2:target,
h3:target,
h4:target,
h5:target,
h6:target {
background: var(--bg-highlight-color);
padding: .2em 0;
}
.flex {
display: flex;
}
body {
line-height: 1.5em;
color: var(--fc-default);
}
hr {
border-color: var(--hr-default);
}
#sidebar {
padding: 30px;
overflow: hidden;
}
#sidebar > *:last-child {
margin-bottom: 2cm;
}
.http-server-breadcrumbs {
font-size: 130%;
margin: 0 0 15px 0;
}
h1, h2, h3, h4, h5, h6 {
font-weight: 300;
color: var(--fc-default);
}
h1 {
font-size: 2.5em;
line-height: 1.1em;
}
h2 {
font-size: 1.75em;
margin: 1em 0 .50em 0;
}
h3 {
font-size: 1.4em;
margin: 25px 0 10px 0;
}
h4 {
margin: 0;
font-size: 105%;
}
#footer {
font-size: .75em;
padding: 5px 30px;
border-top: 1px solid;
border-color: var(--bd-default);
text-align: right;
}
#footer p {
margin: 0 0 0 1em;
display: inline-block;
}
#footer p:last-child {
margin-right: 30px;
}
a {
color: var(--link-primary);
text-decoration: none;
transition: color .3s ease-in-out;
}
a:hover {
color: var(--link-hover);
}
.title code {
font-weight: bold;
}
h2[id^="header-"] {
margin-top: 2em;
}
.ident {
color: var(--ident-primary);
}
pre code {
background: var(--bg-code);
font-size: .8em;
line-height: 1.4em;
}
code {
background: var(--bg-code);
padding: 1px 4px;
overflow-wrap: break-word;
}
h1 code { background: transparent }
pre {
border-top: 1px solid;
border-bottom: 1px solid;
border-color: var(--bd-pre);
}
#http-server-module-list {
display: flex;
flex-flow: column;
}
#http-server-module-list div {
display: flex;
}
#http-server-module-list dt {
min-width: 10%;
}
#http-server-module-list p {
margin-top: 0;
}
.toc ul, #index {
list-style-type: none;
margin: 0;
padding: 0;
}
#index code {
background: transparent;
}
#index h3 {
border-bottom: 1px solid;
border-color: var(--bd-default);
}
#index ul {
padding: 0;
}
#index h4 {
margin-top: .6em;
font-weight: bold;
}
/*
Make TOC lists have 2+ columns when viewport is wide enough.
Assuming ~20-character identifiers and ~30% wide sidebar.
*/
@media (min-width: 200ex) { #index .two-column { column-count: 2 } }
@media (min-width: 300ex) { #index .two-column { column-count: 3 } }
dl {
margin-bottom: 2em;
}
dl dl:last-child {
margin-bottom: 4em;
}
dd {
margin: 0 0 1em 3em;
}
#header-classes + dl > dd {
margin-bottom: 3em;
}
dd dd {
margin-left: 2em;
}
dd p {
margin: 10px 0;
}
.name {
background: var(--bg-code);
font-weight: bold;
font-size: .85em;
padding: 5px 10px;
display: inline-block;
min-width: 40%;
}
.name:hover {
background: var(--bg-code-hover);
}
dt:target .name {
background: var(--highlight-color);
}
.name > span:first-child {
white-space: nowrap;
}
.name.class > span:nth-child(2) {
margin-left: .4em;
}
.inherited {
color: #999; /* NOTE: Not entirely sure how to check this one.. Seems ok already?? */
border-left: 5px solid #eee;
padding-left: 1em;
}
.inheritance em {
font-style: normal;
font-weight: bold;
}
/* Docstrings titles, e.g. in numpydoc format */
.desc h2 {
font-weight: 400;
font-size: 1.25em;
}
.desc h3 {
font-size: 1em;
}
.desc dt code {
background: inherit;
/* Don't grey-back parameters */
}
.source summary, .git-link-div {
outline: none;
color: var(--fc-muted);
text-align: right;
font-weight: 400;
font-size: .8em;
text-transform: uppercase;
}
.source summary > * {
white-space: nowrap;
cursor: pointer;
}
.git-link {
color: inherit;
margin-left: 1em;
}
.source pre {
max-height: 500px;
overflow: auto;
margin: 0;
}
.source pre code {
font-size: 12px;
overflow: visible;
}
.hlist {
list-style: none;
}
.hlist li {
display: inline;
}
.hlist li:after {
content: ',\2002';
}
.hlist li:last-child:after {
content: none;
}
.hlist .hlist {
display: inline;
padding-left: 1em;
}
img {
max-width: 100%;
}
td {
padding: 0 .5em;
}
.admonition {
padding: .1em .5em;
margin-bottom: 1em;
border-radius: 8px;
border: 1px solid;
}
.admonition-title {
font-weight: bold;
}
.admonition.note,
.admonition.info,
.admonition.important {
background: var(--adm-note);
border-color: var(--adm-bd-note);
}
.admonition.todo,
.admonition.versionadded,
.admonition.tip,
.admonition.hint {
background: var(--adm-todo);
border-color: var(--adm-bd-todo);
}
.admonition.warning,
.admonition.versionchanged,
.admonition.deprecated {
background: var(--adm-warning);
border-color: var(--adm-bd-warning);
}
.admonition.error,
.admonition.danger,
.admonition.caution {
background: var(--adm-error);
border-color: var(--adm-bd-error);
}
/*
Desktop MQuery
* Standard desktop breakpoint is 1024, below are tablets and portables.
* No need to limit the max-width of #content, otherwise space is being wasted.
*/
@media screen and (min-width: 1024px) {
#dark-mode-toggle {
display: block;
position: absolute;
top: 5px;
right: 5px;
}
#sidebar {
width: 30%;
height: 100vh;
overflow: auto;
position: sticky;
top: 0;
}
#content {
width: 100%;
padding: 3em 4em;
border-left: 1px solid var(--bd-default);
}
pre code {
font-size: 1em;
}
.item .name {
font-size: 1em;
}
main {
display: flex;
flex-direction: row-reverse;
justify-content: flex-end;
}
.toc ul ul, #index ul {
padding-left: 1.5em;
}
.toc > ul > li {
margin-top: .5em;
}
}
@media print {
* {
background: transparent !important;
color: #000 !important; /* Black prints faster: h5bp.com/s */
box-shadow: none !important;
text-shadow: none !important;
}
#sidebar h1 {
page-break-before: always;
}
.source {
display: none;
}
a[href]:after {
content: " (" attr(href) ")";
font-size: 90%;
}
/* Internal, documentation links, recognized by having a title, don't need the URL explicity stated. */
a[href][title]:after {
content: none;
}
abbr[title]:after {
content: " (" attr(title) ")";
}
/* Don't show links for images, or javascript/internal links */
.ir a:after,
a[href^="javascript:"]:after,
a[href^="#"]:after {
content: "";
}
pre, blockquote {
border: 1px solid #999;
page-break-inside: avoid;
}
thead {
display: table-header-group; /* h5bp.com/t */
}
tr, img {
page-break-inside: avoid;
}
img {
max-width: 100% !important;
}
@page {
margin: 0.5cm;
}
p, h2, h3 {
orphans: 3;
widows: 3;
}
h1, h2, h3, h4, h5, h6 {
page-break-after: avoid;
}
}
</style>
<script>
const html = document.querySelector("html");
const isDarkQuery = window.matchMedia("(prefers-color-scheme: dark)");
const changeHLJS = (style) => {
const hljsStyle = document.querySelector("#hljs");
const styleURL = "https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/" + style + ".min.css";
hljsStyle.href = styleURL;
}
const loadedTheme = window.localStorage.getItem("theme");
if (loadedTheme) {
html.dataset.theme = loadedTheme;
if (loadedTheme == "theme-dark") {
changeHLJS(`atom-one-dark`);
} else {
changeHLJS(`a11y-dark`);
}
}
const onSystemThemeChange = (event) => {
const iconOff = document.querySelector(".dm-icon-off");
const iconOn = document.querySelector(".dm-icon-on");
if (event.matches) {
html.dataset.theme = "theme-dark";
iconOff.classList.add("hidden");
iconOn.classList.remove("hidden");
changeHLJS(`atom-one-dark`);
window.localStorage.setItem("theme", "theme-dark");
} else {
html.dataset.theme = "theme-light";
iconOff.classList.remove("hidden");
iconOn.classList.add("hidden");
changeHLJS(`a11y-dark`);
window.localStorage.setItem("theme", "theme-light");
}
};
isDarkQuery.addEventListener("change", onSystemThemeChange);
window.addEventListener("DOMContentLoaded", () => {
const iconOff = document.querySelector(".dm-icon-off");
const iconOn = document.querySelector(".dm-icon-on");
if (isDarkQuery.matches || loadedTheme == "theme-dark") {
iconOff.classList.add("hidden");
iconOn.classList.remove("hidden");
changeHLJS(`atom-one-dark`);
}
if ((!isDarkQuery.matches || loadedTheme == "theme-light") || !loadedTheme) {
iconOff.classList.remove("hidden");
iconOn.classList.add("hidden");
changeHLJS(`a11y-dark`);
}
});
const toggleDarkMode = () => {
const iconOff = document.querySelector(".dm-icon-off");
const iconOn = document.querySelector(".dm-icon-on");
if (html.dataset.theme == "theme-dark") {
html.dataset.theme = "theme-light";
iconOff.classList.remove("hidden");
iconOn.classList.add("hidden");
changeHLJS(`a11y-dark`);
window.localStorage.setItem("theme", "theme-light");
} else {
html.dataset.theme = "theme-dark";
iconOff.classList.add("hidden");
iconOn.classList.remove("hidden");
changeHLJS(`atom-one-dark`);
window.localStorage.setItem("theme", "theme-dark");
}
};
</script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Package <code>d2read</code></h1>
</header>
<section id="section-intro">
<p>proc - handles reading memory from the d2r process.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#39;&#39;&#39;proc - handles reading memory from the d2r process.&#39;&#39;&#39;
import sys
import os
from dataclasses import dataclass
import dataclasses
from .mem import *
from .enums import *
from .utils import *

from . import game_state

from bitstring import BitArray
import requests
import math
import pymem
import pymem.pattern
import numpy as np
import time
from subprocess import PIPE, Popen
import json
import yaml
import pymem.memory
import pymem.ressources.kernel32
import pymem.ressources.structure

from struct import unpack
import copy

import threading

from .event import events

running = False
api_thread = None

monsters = None


def delta_in_world_to_minimap_delta(delta, diag, scale, deltaZ=0.0):
    camera_angle = -26.0 * 3.14159274 / 180.0
    cos = (diag * math.cos(camera_angle) / scale)
    sin = (diag * math.sin(camera_angle) / scale)
    d = ((delta[0] - delta[1]) * cos, deltaZ - (delta[0] + delta[1]) * sin)
    return d

def world_to_abs(dest, player):
    w = 1280
    h = 720
    screen_center = (w/2.0, h/2.0)
    delta = delta_in_world_to_minimap_delta(dest-player, math.sqrt(w*w+h*h), 68.5,30)
    
    x = np.clip(delta[0]-9.5, -638, 638)
    y = np.clip(delta[1]-39.5, -350, 235)

    screen_coords = (x,y)

    return screen_coords

def shutdown():
    global running

    running = False

    log = (&#34;API THREAD SHUTDOWN&#34;)
    log_color(log)

def game_tick():
    global running

    current_level = -1
    local_tick = -1
    #global offsets
    populate_offsets()
    
    
    while running:

        get_in_game_flag()
        get_tick()

        #this should sync us to the current game clock, to prevent acessing things during loading times
        if game_state.tick &gt;0 and game_state.tick != local_tick:

            if game_state.new_session==1 and game_state.in_game ==1:
                #in game offsets
                
                log = (&#34;In Game!&#34;)
                log_color(log,fg_color=important_color)
                populate_punit()
                get_current_level()

                get_map_json(str(game_state.map_seed), game_state.level)
                #_cluster_map_data(game_state.botty_data[&#34;map&#34;])
                #read_loot_cfg()
                game_state.new_session=0
                current_level = game_state.level
                game_state.loaded = 1

            if game_state.in_game == 1 and game_state.loaded==1:

                try:
                    get_current_level()
                except Exception as err:
                    print(err)

                if current_level != game_state.level:
                    log = (&#34;New Map!&#34;)
                    log_color(log,fg_color=important_color)
                    #self.d2.botty_data[&#34;clusters&#34;] =  None
                    #self.d2.botty_data[&#34;features&#34;] =  None
                    game_state.loaded=0
                    get_map_json(str(game_state.map_seed), game_state.level)
                    #self.d2.get_map_json(str(self.d2.map_seed), self.d2.level)
                    game_state._features = None
                    #_cluster_map_data(self.d2.botty_data[&#34;map&#34;])
                    current_level = game_state.level
                    #game_state._current_area = str(self.d2.botty_data[&#39;current_area&#39;])
                    game_state.loaded=1

                try:
                    get_ppos()
                    #find_mobs()
                    #ui_status()
                    get_ui()
                    #print(game_state.player_world_pos)
                    #get_items()
                    #self.d2.botty_data[&#39;menus&#39;] = self.d2.menus
                    #self.d2.get_last_hovered()
                except Exception as err:
                    print(err)
                    pass
            if game_state.in_game == 1:
                events.emit(&#34;game_state_update&#34;)

            if game_state.in_game == 0:
                game_state.new_session=1
                game_state.loaded=0    

        local_tick = game_state.tick    


    

def start():

    global running
    global api_thread
    
    if running == False:
        running = True
        api_thread = threading.Thread(target=game_tick, daemon=True, args=())
        log = (&#34;API THREAD STARTED&#34;)
        log_color(log,fg_color=note_color)
        api_thread.start()

def populate_offsets():
    get_exp_offset()
    get_unit_offset()
    get_game_info_offset()
    get_ui_settings_offset()
    get_menu_vis_offset()
    get_menu_data_offset()
    get_hover_object_offset()

def populate_punit():
    get_player_offset(128)
    find_info()
    get_ppos()
    

def get_map_json(seed, mapid:int, objectIDs:list=None):
    &#34;&#34;&#34;Summary
    
    Args:
        seed (TYPE): current map seed read from memory
        mapid (int): current in game map number
        objectIDs (list, optional): Description
    
    Returns:
        TYPE: Description
    &#34;&#34;&#34;

    #url for map api
    base_url=&#39;http://34.69.54.92:8000&#39;    
    url=base_url+&#39;/&#39;+str(seed)+f&#39;/2/{str(mapid)}/1&#39;

    log = (&#34;Got data from           -&gt; {}&#34;.format(url))
    log_color(log,fg_color=mem_color)
    resp = requests.get(url=url)
    j = resp.json()

    obj = j[&#39;objects&#39;]
    if objectIDs is not None:
        for objectID in objectIDs:
            responseList.append (obj[objectID])
    map_offset_x = j[&#39;offset&#39;][&#39;x&#39;]
    map_offset_y = j[&#39;offset&#39;][&#39;y&#39;]

    map_offset =np.array([map_offset_x,map_offset_y])


    map_offset = map_offset
    row = []
    for point in j[&#39;mapData&#39;]:
        if point != -1:
            row.append (point)
        else:
            game_state.grid.append (row)
            row = []              
    
    

    def split(a, sep):
        &#34;&#34;&#34;Summary segment up map data for the correct formatting for collisions/path finding
        
        Args:
            a (TYPE): data
            sep (TYPE): delimiter
        
        Yields:
            TYPE: Chop up our map xx
        &#34;&#34;&#34;
        pos = i = 0
        while i &lt;len(a):
            if a[i:i+len(sep)] == sep:
                yield a[pos:i]
                pos = i = i+len(sep)
            else:
                i += 1
        yield a[pos:i]


    if j != None:
        map_crop = j[&#39;crop&#39;]
        obj_str = &#34;|&#34;
        poi_str = &#34;|&#34;
        #these are mostly garbage and not useful, its map decorator stuff
        for key in j[&#39;objects&#39;]:
            value = j[&#39;objects&#39;][key]
            name = objects[int(key)]
            obj_str+=name+&#34;|&#34;
            #print(int(key),name)
            for instance in value:
                offset_x =instance[&#39;x&#39;]
                offset_y=instance[&#39;y&#39;]
                pos =np.array([offset_x,offset_y])
                pos_area = pos-map_offset
                flag = 0
                new_obj = {&#34;position&#34;:pos,&#34;flag&#34;:1,&#34;name&#34;:name,&#34;pos_area&#34;:pos_area}
                game_state.map_objects.append(new_obj)
                break

        #filter ut way points from the objects list
        for key in j[&#39;objects&#39;]:
            value = j[&#39;objects&#39;][key]
            name = objects[int(key)]
            if &#39;waypoint&#39; in name or &#39;Waypoint&#39; in name:
                poi_str+=name+&#34;|&#34;
                #print(int(key),name)
                for instance in value:
                    offset_x =instance[&#39;x&#39;]
                    offset_y=instance[&#39;y&#39;]
                    pos =np.array([offset_x,offset_y])
                    pos_area = pos-map_offset
                    flag = 0
                    new_obj = {&#34;position&#34;:pos,&#34;flag&#34;:1,&#34;label&#34;:name,&#34;pos_area&#34;:pos_area}
                    game_state.points_of_interest.append(new_obj)
                    break

        #convert exits to a uniform format in poi
        if j[&#39;exits&#39;] is not None:
            for key in j[&#39;exits&#39;]:
                value = j[&#39;exits&#39;][key]
                name = areas[int(key)]
                poi_str+=name+&#34;|&#34;
                is_portal = value[&#39;isPortal&#39;]
                offset_x = value[&#39;offsets&#39;][0][&#39;x&#39;]
                offset_y = value[&#39;offsets&#39;][0][&#39;y&#39;]
                pos =np.array([offset_x,offset_y])
                pos_area = pos-map_offset
                new_poi = {&#34;position&#34;:pos,&#34;type&#34;:1,&#34;label&#34;:name,&#34;pos_area&#34;:pos_area}
                game_state.points_of_interest.append(new_poi)
        #convert npcs to a uniform format
        if j[&#39;npcs&#39;] is not None:
            for key in j[&#39;npcs&#39;]:
                if int(key)&lt;738:
                    value = j[&#39;npcs&#39;][key]
                    name = get_mob_name[int(key)]
                    poi_str+=name+&#34;|&#34;
                    is_portal=False
                    is_npc=True
                    offset_x = value[0][&#39;x&#39;]
                    offset_y = value[0][&#39;y&#39;]
                    pos = np.array([offset_x,offset_y])
                    pos_area = pos-map_offset
                    new_poi = {&#34;position&#34;:pos,&#34;type&#34;:1,&#34;label&#34;:name,&#34;pos_area&#34;:pos_area}
                    game_state.points_of_interest.append(new_poi)

        map_id = j[&#39;id&#39;]
        map_data = j[&#39;mapData&#39;]
        map_size = j[&#39;size&#39;]
        map_decode = list(split(map_data,sep=[-1]))

        area_origin = map_offset
        nodes = []
        col_grid = []

        collision_grid = np.empty([int(map_size[&#39;height&#39;]),int(map_size[&#39;width&#39;])], dtype=np.uint8)
        
        if map_data != None:
            mini_map_w=int(map_size[&#39;width&#39;])
            mini_map_h=int(map_size[&#39;height&#39;])
            walkable = True
            y = 0
            for ele in map_decode:
                x = 0
                row = []
                for i in range(len(ele)):
                    if walkable:
                        for j in range(ele[i]):
                            nodes.append([x,y,walkable])
                            row.append(0)
                            collision_grid[y][x] = 0
                            x+=1
                    if not walkable:
                        for j in range(ele[i]):
                            nodes.append([x,y,walkable])
                            row.append(-1)
                            collision_grid[y][x] = -1
                            x+=1

                    walkable = not walkable
                y+=1
                col_grid.append(row)
                x=0
                walkable = True
        

        new_map = {&#34;crop&#34;: map_crop,&#34;id&#34;: map_id,&#39;poi&#39;: game_state.points_of_interest,&#34;objects&#34;: game_state.map_objects,&#34;size&#34;: map_size,&#34;nodes&#34;:nodes,&#34;data&#34;:col_grid}

        log = (&#34;Loaded map              -&gt; {}&#34;.format(area_list[new_map[&#39;id&#39;]]))
        current_area=area_list[new_map[&#39;id&#39;]]

        log_color(log,fg_color=mem_color)
        log = (&#34;Number of POI           -&gt; {}&#34;.format(len(game_state.points_of_interest)))
        log_color(log,fg_color=mem_color)
        log = (&#34;{}&#34;.format(poi_str))
        log_color(log,fg_color=mem_color)
        log = (&#34;Number of OBJ           -&gt; {}&#34;.format(len(game_state.map_objects)))
        log_color(log,fg_color=mem_color)
        log = (&#34;{}&#34;.format(obj_str))
        log_color(log,fg_color=mem_color)

        game_state.maps.append(new_map)



def read_loot_cfg():
    with open(&#34;Z:/botty-r-latest/src/read_mem/item_filter.yaml&#34;, &#34;r&#34;) as stream:
        try:
            loot_filter = yaml.safe_load(stream)
            #print(loot_filter)
            &#39;&#39;&#39;
            for category in loot_filter:
                print(str(category))
                #for item in loot_filter.get(category):
                print(loot_filter.get(category))
            &#39;&#39;&#39;
                #for value in key:
                #   print(str(value))
            loot_data = loot_filter
        except yaml.YAMLError as exc:
            print(exc)


def get_in_game_flag():
    &#34;&#34;&#34;Summary
    
    Returns:
        TYPE: Description
    &#34;&#34;&#34;
    #get game info offset
    ui = base + ui_settings_offset
    igo =0x08
    in_game_ptr = process.read_bytes(ui+igo,1)
    game_state.in_game = int.from_bytes(in_game_ptr ,&#34;little&#34;)        

def get_game_info_offset():
    &#34;&#34;&#34;Summary
    
    Returns:
        TYPE: Description
    &#34;&#34;&#34;
    #get game info offset
    global game_info_offset
    pat = b&#39;\xE8....\x48\x8D\x0D....\x44\x88\x2D....&#39;
    pat_addr = pymem.pattern.pattern_scan_module(handle, module, pat)
    offset_buffer = process.read_int(pat_addr+8)
    game_info_offset = ((pat_addr - base)  + 7 -256 + 5 + offset_buffer)
    log = (&#34;Found game info offset  -&gt;&#34;)
    log_color(log,target=hex(game_info_offset),fg_color=mem_color,fg2_color=offset_color)


def get_hover_object_offset():
    &#34;&#34;&#34;Summary
    
    Returns:
        TYPE: Description
    &#34;&#34;&#34;
    global hover_offset
    pat = b&#39;\xc6\x84\xc2.....\x48\x8b\x74.&#39;
    pat_addr = pymem.pattern.pattern_scan_module(handle, module, pat, return_multiple=False)
    offset_buffer = process.read_bytes(pat_addr+3,4)
    offset_buffer_int = int.from_bytes(offset_buffer,&#39;little&#39;)
    hover_offset = (offset_buffer_int)-1
    log = (&#34;Found hover offset      -&gt;&#34;)
    log_color(log,target=hex(hover_offset),fg_color=mem_color,fg2_color=offset_color)



def get_exp_offset():
    &#34;&#34;&#34;Summary
    
    Returns:
        TYPE: Description
    &#34;&#34;&#34;
    #expansion offset
    pat = b&#39;\xC7\x05........\x48\x85\xC0\x0F\x84....\x83\x78\x5C.\x0F\x84....\x33\xD2\x41&#39;
    #this works fine, shorter pattern
    global exp_offset
    pat = b&#39;\xC7\x05........\x48\x85\xC0\x0F\x84....&#39;
    pat_addr = pymem.pattern.pattern_scan_module(handle, module, pat)
    offset_buffer = process.read_int(pat_addr-4)
    exp_offset = ((pat_addr - base) + offset_buffer)
    log = (&#34;Found exp offset        -&gt;&#34;)
    log_color(log,target=hex(exp_offset),fg_color=mem_color,fg2_color=offset_color)

def get_unit_offset():
    &#39;&#39;&#39;doc string
    
    Returns:
        TYPE: Description
    &#39;&#39;&#39;
    #unit table offset
    global starting_offset
    global player_offset
    pat = b&#34;\x48\x8d.....\x8b\xd1&#34;
    pat_addr = pymem.pattern.pattern_scan_module(handle, module, pat)
    offset_buffer = process.read_int(pat_addr+3)
    player_offset = ((pat_addr - base) + 7 + offset_buffer)
    log = (&#34;Found player offset     -&gt;&#34;)
    log_color(log,target=hex(player_offset),fg_color=mem_color,fg2_color=offset_color)
    starting_offset = player_offset

def get_menu_data_offset():
    &#34;&#34;&#34;Summary
    
    Returns:
        TYPE: Description
    &#34;&#34;&#34;
    #unit table offset
    global ui_offset
    pat = b&#34;\x41\x0f\xb6\xac\x3f....&#34;
    pat_addr = pymem.pattern.pattern_scan_module(handle, module, pat)
    offset_buffer = process.read_int(pat_addr-5)
    ui_offset = ((pat_addr - base) + offset_buffer)
    log = (&#34;Found menu data offset  -&gt;&#34;)
    log_color(log,target=hex(ui_offset),fg_color=mem_color,fg2_color=offset_color)
    #ui_offset =  0x21F89AA

def get_ui_settings_offset():
    &#34;&#34;&#34;Summary
    
    Returns:
        TYPE: Description
    &#34;&#34;&#34;
    #unit table offset
    global ui_settings_offset
    pat = b&#34;\x40\x84\xed\x0f\x94\x05&#34;
    pat_addr = pymem.pattern.pattern_scan_module(handle, module, pat)
    offset_buffer = process.read_int(pat_addr+6)
    ui_settings_offset = ((pat_addr - base) + 10 + offset_buffer)
    log = (&#34;Found ui offset         -&gt;&#34;)
    log_color(log,target=hex(ui_settings_offset),fg_color=mem_color,fg2_color=offset_color)
    #ui_offset =  0x21F89AA


def get_menu_vis_offset():
    &#34;&#34;&#34;Summary
    
    Returns:
        TYPE: Description
    &#34;&#34;&#34;
    #menu vis offset
    #pat = b&#39;\x8B\x05....\x89\x44\x24\x20\x74\x07&#39;
    #?? search less direct matches?
    global menu_offset
    pat = b&#39;\x8B\x05....\x89\x44.\x20\x74\x07&#39;
    pat_addr = pymem.pattern.pattern_scan_module(handle, module, pat)
    offset_buffer = process.read_int(pat_addr+2)
    #maybe dont need +6 here?
    menu_offset = ((pat_addr - base) + 6 + offset_buffer)
    log = (&#34;Found menu offset       -&gt;&#34;)
    log_color(log,target=hex(menu_offset),fg_color=mem_color,fg2_color=offset_color)

def get_last_hovered():
    &#34;&#34;&#34;Summary
    &#34;&#34;&#34;
    global hover_offset

    offset = hover_offset
    is_hovered = process.read_int(offset+base+0x00)
    is_tooltip = process.read_int(offset+base+0x01)
    hovered_unit_type = process.read_int(offset+base+0x03)
    hid =process.read_uint(offset+base+0x08)

    #print(hovered_unit_type)

    #print(hid)

    #print(is_tooltip)

    if is_hovered:
        
        game_state.hover_obj = hid
        #print(hid)
        if hovered_unit_type == 1024:
            for item in game_state.items:
                #print(len(game_state.items))
                try:
                    pass
                    #print(game_state.items[hid-1])
                except:
                    pass
                break


        if hovered_unit_type == 256:
            if monsters is not None:
                for m in monsters:
                    #print(m)
                    if hid == m[&#39;id&#39;] and is_hovered:
                        #print(m[&#39;name&#39;])
                        pass
                        break


def get_player_offset(loops=128):
    &#34;&#34;&#34;Summary - scan for player unit as a starting point for all relevant memory offsets
    
    Args:
        loops (TYPE): iterations 
    
    Returns:
        TYPE: sets the global player unit offset
    &#34;&#34;&#34;
    found = False

    attempts=0
    name = &#34;&#34;
    new_offset=0

    global player_unit
    global path_addr

    for i in range(loops):
        attempts=i+0

        new_offset = (starting_offset)+(attempts-1)*8

        start_addr = base + new_offset

        player_unit = process.read_longlong(start_addr)

        while player_unit&gt;0:
            p_inventory = player_unit+0x90
            inventory = process.read_longlong(p_inventory)
            if(inventory):

                exp_char = process.read_ushort(base+exp_offset)
                base_check = process.read_ushort(inventory+0x30) !=1


                if(exp_char):
                    base_check = process.read_ushort(inventory+0x70) !=0

            if(base_check):
                
                log = (&#34;Found inventory offset  -&gt;&#34;)
                log_color(log,target=hex(base-inventory),fg_color=mem_color,fg2_color=offset_color)

                if(exp_char):
                    log = (&#34;Char Type               -&gt;&#34;)
                    log_color(log,target=&#34;Expansion&#34;,fg_color=mem_color,fg2_color=offset_color)
                else:
                    log = (&#34;Char Type               -&gt;&#34;)
                    log_color(log,target=&#34;Classic&#34;,fg_color=mem_color,fg2_color=offset_color)

                p_act = player_unit+0x20
                act_addr = process.read_ulonglong(p_act)
                map_seed_addr = act_addr +0x14
                map_seed = process.read_uint(map_seed_addr)
                game_state.map_seed = map_seed

                #print(map_seed)
                p_path = player_unit+0x38
                path_addr = process.read_longlong(p_path)

                x_pos = process.read_ushort(path_addr+0x02)
                #print (x_pos)
                y_pos = process.read_ushort(path_addr+0x06)
                #print (y_pos)
                p_unit_data = player_unit +0x10
                try:
                    player_name_addr = process.read_longlong(p_unit_data)
                except:
                    pass
                p_name = &#34;&#34;
                #
                for i in range(16):
                    name = name + str(chr(process.read_uchar(player_name_addr+i-1)))

                if(x_pos&gt; 0 and y_pos &gt;0 and len(str(map_seed))&gt;6):
                    if loops &gt; 1:
                        log = (&#34;Found player name       -&gt;&#34;)
                        log_color(log,target=name,fg_color=mem_color,fg2_color=important_color)
                        
                        log = (&#34;Found map seed          -&gt;&#34;)
                        log_color(log,target=str(map_seed),fg_color=mem_color,fg2_color=important_color)
                    new_offset = new_offset+0
                    found = True
                    player_unit = new_offset
                    path_addr = path_addr
                    return True

            new_offset = (player_unit+0x150)-base
            try:
                player_unit = process.read_longlong(player_unit +0x150)
            except:
                pass


def get_current_level():
    &#34;&#34;&#34;Summary
    &#34;&#34;&#34;
    startingAddress = base + player_unit
    playerUnit = process.read_ulonglong(startingAddress)
    pUnitData = playerUnit + 0x10
    #get the level number
    pPathAddress = playerUnit + 0x38
    pPath = process.read_ulonglong(pPathAddress)
    pRoom1 = pPath + 0x20
    pRoom1Address = process.read_ulonglong(pRoom1)
    pRoom2 = pRoom1Address + 0x18
    pRoom2Address = process.read_ulonglong(pRoom2)
    pLevel = pRoom2Address + 0x90
    pLevelAddress = process.read_ulonglong(pLevel)
    dwLevelNo = pLevelAddress + 0x1F8
    levelNo = process.read_uint(dwLevelNo)
    level_addr = dwLevelNo
    game_state.level = levelNo

def find_info():
    &#34;&#34;&#34;Summary
    
    Returns:
        TYPE: Description
    &#34;&#34;&#34;
    startingAddress = base + player_unit
    playerUnit = process.read_ulonglong(startingAddress)
    pUnitData = playerUnit + 0x10
    try:
        playerNameAddress = process.read_ulonglong(pUnitData)
    except:
        #just so we really know
        print(&#34;FAILED&#34;)
        print(&#34;FAILED&#34;)
        print(&#34;FAILED&#34;)
        print(&#34;FAILED&#34;)
        print(&#34;FAILED&#34;)
        print(&#34;FAILED&#34;)
        return False
        pass
    if(playerNameAddress):
        playerName = process.read_string(playerNameAddress)
    
    pStatsListEx = process.read_ulonglong(playerUnit+0x88)
    statPtr = process.read_ulonglong(pStatsListEx+0x30)
    statCount = process.read_ulonglong(pStatsListEx+0x38)

    experience=0

    for i in range(statCount):

        statOffset = (i-1) * 8
        statEnum = process.read_ushort(statPtr + 0x2 + statOffset)
        if (statEnum == 12):
            player_level = process.read_uint(statPtr + 0x4 + statOffset)
        if (statEnum == 13):
            experience = process.read_uint(statPtr + 0x4 + statOffset)
        if (statEnum == 6):
            hp = process.read_uint(statPtr + 0x4 + statOffset)
            hp = hp &gt;&gt; 8
        if (statEnum == 7):
            maxhp = process.read_uint(statPtr + 0x4 + statOffset)
            max_hp = maxhp &gt;&gt; 8
    log = &#34;LVL:&#34; +str(player_level)+&#34;, HP:&#34;+str(max_hp)+&#34;, EXP:&#34;+str(experience)
    log_color(log,fg_color=mem_color)

    #get the level number
    pPathAddress = playerUnit + 0x38
    pPath = process.read_ulonglong(pPathAddress)
    pRoom1 = pPath + 0x20
    pRoom1Address = process.read_ulonglong(pRoom1)
    pRoom2 = pRoom1Address + 0x18
    pRoom2Address = process.read_ulonglong(pRoom2)
    pLevel = pRoom2Address + 0x90
    pLevelAddress = process.read_ulonglong(pLevel)
    dwLevelNo = pLevelAddress + 0x1F8
    levelNo = process.read_uint(dwLevelNo)
    level_addr = dwLevelNo
    
    
    level = levelNo
    log = (&#34;current level      -&gt; &#34;+str(area_list[levelNo]))
    log_color(log,fg_color=mem_color)

    if not levelNo:
        log = &#34;!! Did not find level num using player offset&#34; +str(playerOffset)
        log_color(log,fg_color=mem_color)


    #get the map seed
    pAct = playerUnit + 0x20
    actAddress = process.read_ulonglong(pAct)


    if actAddress:
        mapSeedAddress = actAddress + 0x14
        if mapSeedAddress:
            mapSeed = process.read_uint(mapSeedAddress)
            map_seed = mapSeed
        else:
            log = (&#34;!! Did not find map seed at address&#34;+(mapSeedAddress))
            log_color(log,fg_color=mem_color)

    #get the level number
    actAddress = process.read_ulonglong(pAct)

    pActUnk1 = actAddress + 0x70
    aActUnk2 = process.read_ulonglong(pActUnk1)
    aDifficulty = aActUnk2 + 0x830
    difficulty = process.read_ushort(aDifficulty)
    difficulty=difficulty

    if difficulty==0:
        log = (&#34;current difficulty      -&gt; Normal&#34;)
        log_color(log,fg_color=mem_color)
    if difficulty==1:
        log = (&#34;current difficulty      -&gt; Nightmare&#34;)
        log_color(log,fg_color=mem_color)
    if difficulty==2:
        log = (&#34;current difficulty      -&gt; Hell&#34;)
        log_color(log,fg_color=mem_color)


def get_ppos():
    &#34;&#34;&#34;Summary - update the player positon game state globals
    &#34;&#34;&#34;
    global path_addr
    #global player_world_pos
    bytes_read = process.read_bytes(path_addr,8)
    x,y = unpack(&#39;xHxxH&#39;, bytes_read)
    game_state.player_world_pos = np.array([x,y])
    #log_color(&#34;Player pos            -&gt; {}&#34;.format(player_world_pos),fg_color=mem_color)


def find_objects(file_number:int):
    &#34;&#34;&#34;Summary
    
    Args:
        file_number (int): Description
    
    Returns:
        TYPE: Description
    &#34;&#34;&#34;
    super_chests =[]
    object_offset = starting_offset + (2 * 1024)
    attempts=0


    for i in range(256):
        attempts=i+0
        new_offset = object_offset + (8 * (i-1))
        item_addr = base + new_offset
        object_unit = process.read_longlong(item_addr)

        #print(i)
        while (object_unit&gt;0):
            item_type = process.read_int(object_unit+0x00)
            pRoomnext = process.read_ulonglong(object_unit+0x158)
            #pRoomEx = process.read_ulonglong (pRoomnext+0x18)
            if(item_type==2):
                file_no = process.read_int(object_unit+0x04)
                if file_no == file_number:
                    print (&#34;Object found&#34;)
                    p_unit_data = process.read_ulonglong(object_unit + 0x10)
                    mode = process.read_uint (object_unit + 0x0C)
                    #pObjectTxt = process.read_ulonglong(p_unit_data)
                    #print(str(pObjectTxt))
                    #sObjectTxt = process.read_string(p_unit_data, 16)
                    #shrineTxt = process.read_string(p_unit_data + 0x0c, 16)
                    pPath = process.read_ulonglong(object_unit + 0x38)  
                    objectx = process.read_ushort(pPath + 0x10)
                    objecty = process.read_ushort(pPath + 0x14)
                    x_pos = process.read_ushort(path_addr+0x02)
                    y_pos = process.read_ushort(path_addr+0x06)
                    odist = math.dist([objectx,objecty],[x_pos,y_pos])
                    #print(y_pos)
                    #print(x_pos)
                    print(txt_obj_name[file_no-1] + &#34;&#34;+ str(str(file_no)))    
                    print(&#39;dist -&gt; &#39;+ str(odist))
                    obj = Object (objectx, objecty, mode)
                    return obj



            object_unit = process.read_longlong(object_unit + 0x150)




def get_ui():
    &#34;&#34;&#34;Summary - update the global UI state
    &#34;&#34;&#34;

    offset = ui_settings_offset
    ui = base + offset    
    bytes_read = process.read_bytes(ui-10,31)
    ret = unpack(&#39;??????xx???????xxxx?x?xx????x??&#39;, bytes_read)    
    game_state.ui_state = game_state.UI(*ret)

def scan_around_16():
    &#34;&#34;&#34;Summary - for debug
    &#34;&#34;&#34;
    global game_info_state

    offset = game_info_offset
    game_info_addr = base + offset

    i=0
    while i &lt; (72*4):
        bytes_read = process.read_bytes(game_info_addr+i,16)
        ret = unpack(&#39;cccccccccccccccc&#39;, bytes_read)
        #name = process.read_string(game_info_addr,10)
        #print(ret, i)
        out = b&#39;&#39;
        for b in ret:
            out+=b
        print(out, i)
        i+=16



def get_tick():
    &#34;&#34;&#34;Summary - for debug, gets the 3D graphics ticks based on frame rate cap
    &#34;&#34;&#34;
    global game_info_state

    offset = game_info_offset
    game_info_addr = base + offset

    off = 0xb4+68
    result = process.read_ulonglong(game_info_addr+off)
    result_2 = process.read_bytes(result+16,1)

    tick = result_2
    game_state.tick = int.from_bytes(tick,&#39;little&#39;)

    
def get_cursor_item():
    #pUnit-&gt;inventory_0x60-&gt;unitdata_0x20-&gt;itemdata0x14-&gt;itemLvl_0x2C
    items = []
    item_offset = starting_offset + (4*1024)

    for i in range(256):


        new_offset = item_offset +(8 *(i))
        item_addr = base + new_offset
        item_unit = process.read_longlong(item_addr)

        while (item_unit&gt;0):
            item_type = process.read_uint(item_unit+0x00)
            if item_type == 4:
                txt_file_no = process.read_uint(item_unit+0x04)
                item_loc = process.read_uint(item_unit+0x0C)

                # item loc 0 = inventory, 1 = equipped, 2 in belt, 3 on ground, 4 cursor, 5 dropping ,6 socketed
                if item_loc == 4:
                    #print(&#34;item on ground&#34;)
                    print(&#34;item on cursor&#34;)
                    p_unit_data = process.read_longlong(item_unit + 0x10)
                    #itemQuality - 5 is set, 7 is unique (6 rare, 4, magic)
                    item_quality = process.read_uint(p_unit_data)
                    p_path = process.read_longlong(item_unit+0x38)
                    item_x = process.read_ushort(p_path+0x10)
                    item_y = process.read_ushort(p_path+0x14)


                    p_stat_list_ex = process.read_longlong(item_unit + 0x88)
                    stat_ptr = process.read_longlong(p_stat_list_ex + 0x30)
                    stat_count = process.read_longlong(p_stat_list_ex + 0x38)
                    num_sockets = 0

                    for j in range(stat_count):
                        #print(&#34;checking for sockets&#34;)
                        stat_offset = (j)*8
                        stat_enum = process.read_ushort(stat_ptr+0x2+stat_offset)
                        #print(stat_enum)

                        if stat_enum == 73:
                            s_73 = process.read_uint(stat_ptr+0x4+stat_offset)
                            #print(&#39;number of sockets -&gt;&#39;+str(num_sockets))
                            #print(s_73)

                        if stat_enum == 72:
                            s_72 = process.read_uint(stat_ptr+0x4+stat_offset)
                            #print(&#39;number of sockets -&gt;&#39;+str(num_sockets))
                            #print(s_72)

                        if stat_enum == 22:
                            s_22 = process.read_uint(stat_ptr+0x4+stat_offset)
                            #print(s_22)
                            #print(&#39;number of sockets -&gt;&#39;+str(num_sockets))

                        if stat_enum == 21:
                            s_21 = process.read_uint(stat_ptr+0x4+stat_offset)
                            #print(s_21)
                            #print(&#39;number of sockets -&gt;&#39;+str(num_sockets))

                        if stat_enum == 194:
                            num_sockets = process.read_uint(stat_ptr+0x4+stat_offset)
                            #print(&#39;number of sockets -&gt;&#39;+str(num_sockets))


                    flags = process.read_uint(p_unit_data+0x18)

                    identified = False
                    if(0x00000010 &amp; flags):
                        identified = True
                        #print(&#34;id&#39;d&#34;)
                    ethereal = False
                    if(0x00400000 &amp; flags):
                        ethereal = True

                    quality=&#39;Any&#39;
                    if item_quality == 1:
                        quality = &#39;Inferior&#39;
                    if item_quality == 2:
                        quality = &#39;Normal&#39;
                    if item_quality == 3:
                        quality = &#39;Superior&#39;
                    if item_quality == 4:
                        quality = &#39;Magic&#39;
                    if item_quality == 5:
                        quality = &#39;Set&#39;
                    if item_quality == 6:
                        quality = &#39;Rare&#39;
                    if item_quality == 7:
                        quality = &#39;Unique&#39;
                    if item_quality == 8:
                        quality = &#39;Crafted&#39;
                    if item_quality == 9:
                        quality = &#39;Tempered&#39;

                    #print(txt_file_no)
                    if txt_file_no &gt;= 557 and txt_file_no &lt;= 586 or txt_file_no&gt;= 597 and txt_file_no&lt;= 601:
                        quality = &#39;Gem&#39;
                    if txt_file_no &gt;= 610 and txt_file_no &lt;= 642:
                        quality = &#39;Rune&#39;

                    item = (txt_file_no,quality,item_name[txt_file_no],item_quality,item_loc,item_x,item_y,num_sockets)



                    print(item_name[txt_file_no],item)


            item_unit = process.read_longlong(item_unit + 0x150)



def get_addr_test():
    &#34;&#34;&#34;Summary - for debug
    &#34;&#34;&#34;
    global game_info_state

    offset = game_info_offset
    game_info_addr = base + offset

    result = process.read_bytes(game_info_addr+0x2a+24+6,14)
    off = 0x2a
    off = 0x6d
    off = 0xb4
    #result = process.read_bytes(game_info_addr+off+24+6,4)
    &#39;&#39;&#39;
    for i in range(-128,128):
        result = process.read_ulonglong(game_info_addr+off+24+6+i)
        try:
            result_2 = process.read_bytes(result,32)
            #result_3 = process.read_uint(result)
            #r = int.from_bytes(result,&#34;little&#34;)
            print(result_2,i)
        except:
            pass
    &#39;&#39;&#39;
    result = process.read_ulonglong(game_info_addr+off+24+6+38)
    result_2 = process.read_bytes(result+4+2+2-2,11)

    result_2 = process.read_bytes(result+4+2+2-2+10,1)

    #print(hex(result-base))

    #ret = unpack(&#39;&lt;Q&#39;, result_2)
    #result_3 = int.from_bytes(result_2,&#39;little&#39;)
    #result_4 = process.read_ulong(result+8)
    #print(result_2)
    return result_2
    

def get_game_pass():
    &#34;&#34;&#34;Summary - update the game data globals with the current game password
    &#34;&#34;&#34;
    global game_info_state

    offset = game_info_offset
    game_info_addr = base + offset

    read_game_pass = process.read_string(game_info_addr+120,16)
    game_state.game_pass = read_game_pass


def get_game_name():
    &#34;&#34;&#34;Summary - update the game data globals with the current game name
    &#34;&#34;&#34;
    offset = game_info_offset
    game_info_addr = base + offset
    read_game_name = process.read_string(game_info_addr+72,16)
    game_state.game_name = read_game_name

def get_game_ip():
    &#34;&#34;&#34;Summary - update the game data globals
    &#34;&#34;&#34;

    offset = game_info_offset
    game_info_addr = base + offset
    #bytes_read = process.read_bytes(game_info_addr+0x1D0,31)
    #ret = unpack(&#39;??????xx???????xxxx?x?xx????x??&#39;, bytes_read)    
    ip = process.read_string(game_info_addr+0X1D0,16)


def get_items():
    &#34;&#34;&#34;Summary
    &#34;&#34;&#34;
    items=[]
    item_offset = starting_offset + (4*1024)

    for i in range(256):


        new_offset = item_offset +(8 *(i))
        item_addr = base + new_offset
        item_unit = process.read_longlong(item_addr)

        while (item_unit&gt;0):
            item_type = process.read_uint(item_unit+0x00)

            if item_type == 4:
                txt_file_no = process.read_uint(item_unit+0x04)
                item_loc = process.read_uint(item_unit+0x0C)

                # item loc 0 = inventory, 1 = equipped, 2 in belt, 3 on ground, 4 cursor, 5 dropping ,6 socketed
                if item_loc == 0 or 1:
                    #print(&#34;item on ground&#34;)
                    p_unit_data = process.read_longlong(item_unit + 0x10)
                    #itemQuality - 5 is set, 7 is unique (6 rare, 4, magic)
                    item_quality = process.read_uint(p_unit_data)
                    p_path = process.read_longlong(item_unit+0x38)
                    item_x = process.read_ushort(p_path+0x10)
                    item_y = process.read_ushort(p_path+0x14)

                    p_stat_list_ex = process.read_longlong(item_unit + 0x88)
                    stat_ptr = process.read_longlong(p_stat_list_ex + 0x30)
                    stat_count = process.read_longlong(p_stat_list_ex + 0x38)
                    num_sockets = 0

                    for j in range(stat_count):
                        #print(&#34;checking for sockets&#34;)
                        stat_offset = (j)*8
                        stat_enum = process.read_ushort(stat_ptr+0x2+stat_offset)
                        if stat_enum == 194:
                            num_sockets = process.read_uint(stat_ptr+0x4+stat_offset)
                            #print(&#39;number of sockets -&gt;&#39;+str(num_sockets))
                            break

                    flags = process.read_uint(p_unit_data+0x18)


                    identified = False
                    if(0x00000010 &amp; flags):
                        identified = True
                        #print(&#34;id&#39;d&#34;)
                    ethereal = False
                    if(0x00400000 &amp; flags):
                        ethereal = True

                    quality=&#39;Any&#39;
                    if item_quality == 1:
                        quality = &#39;Inferior&#39;
                    if item_quality == 2:
                        quality = &#39;Normal&#39;
                    if item_quality == 3:
                        quality = &#39;Superior&#39;
                    if item_quality == 4:
                        quality = &#39;Magic&#39;
                    if item_quality == 5:
                        quality = &#39;Set&#39;
                    if item_quality == 6:
                        quality = &#39;Rare&#39;
                    if item_quality == 7:
                        quality = &#39;Unique&#39;
                    if item_quality == 8:
                        quality = &#39;Crafted&#39;
                    if item_quality == 9:
                        quality = &#39;Tempered&#39;

                    #print(txt_file_no)
                    if txt_file_no &gt;= 557 and txt_file_no &lt;= 586 or txt_file_no&gt;= 597 and txt_file_no&lt;= 601:
                        quality = &#39;Gem&#39;
                    if txt_file_no &gt;= 610 and txt_file_no &lt;= 642:
                        quality = &#39;Rune&#39;


                    body_loc = process.read_uchar(p_unit_data+0x54)
                    inventory_page = process.read_uchar(p_unit_data+0x0c)
                    inventory_ptr = process.read_ulonglong(p_unit_data+0x70)

                    node = process.read_uchar(p_unit_data+0x88)
                    nodeOther = process.read_uchar(p_unit_data+0x89)
                    
                    item = (txt_file_no,quality,item_name[txt_file_no],item_quality,item_loc,item_x,item_y,num_sockets,inventory_page,inventory_ptr,body_loc)


                    items.append(item)

                    &#39;&#39;&#39;
                    for category in _loot_data:
                        q_match = 0
                        i_match = 0
                        loot_check = 0

                        data = _loot_data.get(category)
                        quality_match = [&#39;Any&#39;]
                        item_match = [&#39;Any&#39;]
                        try:
                            quality_match = data[&#39;quality&#39;]
                        except:
                            quality_match = [&#39;Inferior&#39;,&#39;Normal&#39;,&#39;Superior&#39;,&#39;Magic&#39;,&#39;Set&#39;,&#39;Rare&#39;,&#39;Unique&#39;,&#39;Crafted&#39;,&#39;Tempered&#39;,&#39;Gem&#39;,&#39;Rune&#39;]
                            pass
                        try:
                            item_match = data[&#39;items&#39;]
                        except:
                            item_match = [&#39;Any&#39;]
                            pass

                        for q in quality_match:
                            if quality in q:
                                q_match=1

                        for i in item_match:
                            item_to_check = str(item_name[txt_file_no])
                            if num_sockets&gt;0:
                                item_to_check = str(item_name[txt_file_no])+&#39;,&#39;+str(num_sockets)
                            if item_to_check in i or item_match[0] is &#39;Any&#39;:
                                i_match=1

                        if q_match and i_match:
                            loot_check =1

                        try:
                            if data[&#39;ignoreidentified&#39;] is True and identified:
                                loot_check=0
                        except:
                            pass

                        if loot_check:
                            print(&#34;good to loot&#34;)
                            #_move_to_mem(item_x,item_y)
                            print(item_name[txt_file_no])
                    &#39;&#39;&#39;
        
                    

            item_unit = process.read_longlong(item_unit + 0x150)

    game_state.items=items


def find_mobs():
    &#34;&#34;&#34;Summary
    &#34;&#34;&#34;
    global monsters

    monstersOffset = starting_offset + 1024
    mobs = []
    loc_monsters = []
    skel_count =0
    mage_count =0
    golem_count = &#39;none&#39;

    for i in range(128):
        newOffset = monstersOffset + (8 * (i - 1))
        mobAddress = base + newOffset
        mobUnit = process.read_longlong(mobAddress)
        
        while (mobUnit&gt; 0):

            txtFileNo = process.read_uint(mobUnit + 0x04)
            hide_check = 0
            try:
                hide_npc[txtFileNo]
            except:
                #no key 
                pass

            if not hide_check:

                mobTypeString = &#34;&#34;
                #
                unit_data = process.read_ulonglong(mobUnit + 0x10)
                mob_type = process.read_bytes(unit_data+0x1a,1)
                mob_type_int = int.from_bytes(mob_type,&#34;little&#34;)

                if mob_type_int == 0:
                    mobTypeString = &#39;None&#39;
                if mob_type_int == 1:
                    mobTypeString = &#39;Other&#39;
                if mob_type_int  == 10:
                    mobTypeString = &#39;SuperUnique&#39;
                if mob_type_int == 8:
                    mobTypeString = &#39;Unique&#39;
                if mob_type_int == 12:
                    mobTypeString = &#39;Champion&#39;                        
                if mob_type_int == 16:
                    mobTypeString = &#39;Minion&#39;
                if mob_type_int == 32:
                    mobTypeString = &#39;Possessed?&#39;
                if mob_type_int == 76:
                    mobTypeString = &#39;Ghostly&#39;
                if mob_type_int == 64:
                    mobTypeString = &#39;Multishot?&#39;
                    
                

                unitId = process.read_uint(mobUnit + 0x08)
                mode = process.read_uint(mobUnit + 0x0c)
                iscorpse = process.read_uchar (mobUnit + 0x1A6)
                interactable = process.read_uchar (mobUnit + 0x1A6+4)
                pUnitData = process.read_longlong(mobUnit + 0x10)
                pPath = process.read_longlong(mobUnit + 0x38)
            
                isUnique = process.read_ushort(pUnitData + 0x18)
                #????
                uniqueNo = process.read_ushort(pUnitData + 42)

                monx = process.read_ushort(pPath + 0x02)
                mony = process.read_ushort(pPath + 0x06)
                xPosOffset = process.read_ushort(pPath + 0x00) 
                yPosOffset = process.read_ushort(pPath + 0x04)
                xPosOffset = xPosOffset / 65536
                yPosOffset = yPosOffset / 65536
                monx = monx + xPosOffset
                mony = mony + yPosOffset

                #+026?
                #+017 - eLastMode
                #+018 - dwDuriel - set only for duriel
                #+01C - MonUModList[9] - nine bytes holding the Ids for each MonUMod assigned to the unit
                #+026 - bossNo - hcIdx from superuniques.txt for superuniques (word)
                #+028 - pAiGeneral
                BossLineID = process.read_ushort(unit_data + 0x2A) 

                isBoss = 0
                textTitle = None

                textTitle = get_mob_name[txtFileNo]

                if mob_type_int == 10:
                    try:
                        textTitle = super_unique_names[uniqueNo]
                    except:
                        pass
                if mob_type_int == 8:
                    try:
                        textTitle = get_mob_name[txtFileNo]
                    except:
                        pass
                    isBoss= 1


                #get immunities
                pStatsListEx = process.read_longlong(mobUnit + 0x88)
                ownerType = process.read_uint(pStatsListEx + 0x08)
                ownerId = process.read_uint(pStatsListEx + 0x0C)

                statPtr = process.read_longlong(pStatsListEx + 0x30)
                statCount = process.read_longlong(pStatsListEx + 0x38)

                #if(isUnique):
                    #print(textTitle,mobTypeString, mob_type_int)

                &#39;&#39;&#39;
                #these need to be added

                loadEncText(auraStrings[33], cfg-&gt;MightAura);
                loadEncText(auraStrings[35], cfg-&gt;HolyFireAura);
                loadEncText(auraStrings[40], cfg-&gt;BlessedAimAura);
                loadEncText(auraStrings[43], cfg-&gt;HolyFreezeAura);
                loadEncText(auraStrings[46], cfg-&gt;HolyShockAura);
                loadEncText(auraStrings[28], cfg-&gt;ConvictionAura);
                loadEncText(auraStrings[49], cfg-&gt;FanaticismAura);

                loadEncText(enchantStrings[5], cfg-&gt;encTxtExtraStrong);
                loadEncText(enchantStrings[6], cfg-&gt;encTxtExtraFast);
                loadEncText(enchantStrings[7], cfg-&gt;encTxtCursed);
                loadEncText(enchantStrings[8], cfg-&gt;encTxtMagicResistant);
                loadEncText(enchantStrings[9], cfg-&gt;encTxtFireEnchanted);
                loadEncText(enchantStrings[17], cfg-&gt;encTxtLigntningEnchanted);
                loadEncText(enchantStrings[18], cfg-&gt;encTxtColdEnchanted);
                loadEncText(enchantStrings[25], cfg-&gt;encTxtManaBurn);
                loadEncText(enchantStrings[26], cfg-&gt;encTxtTeleportation);
                loadEncText(enchantStrings[27], cfg-&gt;encTxtSpectralHit);
                loadEncText(enchantStrings[28], cfg-&gt;encTxtStoneSkin);
                loadEncText(enchantStrings[29], cfg-&gt;encTxtMultipleShots);
                loadEncText(enchantStrings[37], cfg-&gt;encTxtFanatic);
                loadEncText(enchantStrings[39], cfg-&gt;encTxtBerserker);

                &#39;&#39;&#39;
                #
                immunities = {&#39;physical&#39;: 0,&#39;magic&#39;: 0,&#39;fire&#39;: 0,&#39;light&#39;: 0,&#39;cold&#39;: 0,&#39;poison&#39;: 0}
                auras = {&#39;MightAura&#39;: 0,&#39;HolyFireAura&#39;: 0, &#39;BlessedAimAura&#39;: 0, &#39;HolyFreezeAura&#39;: 0, &#39;HolyShockAura&#39;: 0,&#39;ConvictionAura&#39;: 0,&#39;FanaticismAura&#39;:0}
                enchants = {&#39;ExtraStrong&#39;: 0,&#39;ExtraFast&#39;: 0, &#39;Cursed&#39;: 0, &#39;MagicResistant&#39;: 0, &#39;FireEnchanted&#39;: 0,&#39;LigntningEnchanted&#39;: 0,&#39;ColdEnchanted&#39;:0,&#39;ManaBurn&#39;:0,&#39;Teleportation&#39;:0,&#39;SpectralHit&#39;:0,&#39;StoneSkin&#39;:0,&#39;MultipleShots&#39;:0,&#39;Berserker&#39;:0}

                for s in range(statCount):
                    offset = (s -1) * 8
                    statParam = process.read_ushort(statPtr + offset)
                    statEnum = process.read_ushort(statPtr + 0x2 + offset)
                    statValue = process.read_uint(statPtr + 0x4 + offset)
                    if (statValue&gt;= 100):
                        if statEnum == 36:
                            immunities[&#34;physical&#34;] = 1 #physical immune      
                        if statEnum == 37:
                            immunities[&#34;magic&#34;] = 1    
                        if statEnum == 39:
                            immunities[&#34;fire&#34;] = 1
                        if statEnum == 41:
                            immunities[&#34;light&#34;] = 1  
                        if statEnum == 43:
                            immunities[&#34;cold&#34;] = 1
                        if statEnum == 45:
                            immunities[&#34;poison&#34;] = 1 
                get_ppos()
                dist = math.dist(game_state.player_world_pos,np.array([int(monx),int(mony)]))

                abs_screen_position = world_to_abs(np.array([monx,mony]), game_state.player_world_pos)
                mob = {&#39;position&#39;: np.array([int(monx),int(mony)]),&#39;dist&#39;: dist, &#39;abs_screen_position&#39;: abs_screen_position, &#39;immunities&#39;: immunities, &#39;unit_type&#39;: &#39;Monster&#39;, &#39;type&#39;: mobTypeString, &#39;id&#39;: unitId, &#39;name&#39;: textTitle, &#39;mode&#39;: mode, &#39;number&#39;: txtFileNo, &#39;super_unique&#39;:isUnique,&#39;boss&#39;:isBoss,&#39;is_corpse&#39;:iscorpse, &#39;interactable&#39;:interactable }
                
                # filter out some stuff and calculate summon count
                if textTitle is not None:
                    if &#39;ClayGolem&#39; in mob[&#39;name&#39;]:
                        if mob[&#39;mode&#39;] != 12:
                            golem_count = &#34;ClayGolem&#34;

                    elif &#39;FireGolem&#39; in mob[&#39;name&#39;]:
                        if mob[&#39;mode&#39;] != 12:
                            golem_count = &#34;FireGolem&#34;

                    elif &#39;BloodGolem&#39; in mob[&#39;name&#39;]:
                        if mob[&#39;mode&#39;] != 12:
                            golem_count = &#34;BloodGolem&#34;

                    elif &#39;IronGolem&#39; in mob[&#39;name&#39;]:
                        if mob[&#39;mode&#39;] != 12:
                            golem_count = &#34;IronGolem&#34;

                    elif &#39;NecroMage&#39; == mob[&#39;name&#39;]:
                        if mob[&#39;mode&#39;] != 12:
                            mage_count +=1

                    elif &#39;NecroSkeleton&#39; == mob[&#39;name&#39;]:
                        if mob[&#39;mode&#39;] != 12:
                            skel_count +=1
                    elif &#39;Rouge&#39; in mob[&#39;name&#39;]:
                        pass
                    elif &#39;Gaurd&#39; in mob[&#39;name&#39;]:
                        pass
                    elif &#39;Alkor&#39; in mob[&#39;name&#39;]:
                        pass
                    elif &#39;a trap&#39; in mob[&#39;name&#39;]:
                        pass
                    elif &#39;IronWolf&#39; in mob[&#39;name&#39;]:
                        pass
                    elif &#39;Malachai&#39; in mob[&#39;name&#39;]:
                        pass
                    elif mob[&#39;name&#39;] == &#39;&#39;:
                        pass
                    elif &#39;?&#39; in mob[&#39;name&#39;]:
                        pass
                    elif &#39;Barricade&#39; in mob[&#39;name&#39;]:
                        pass
                    else:
                        loc_monsters.append(mob)

                        #if dist&lt;5:
                        #    print(mob[&#39;name&#39;])

                        #    print(mob[&#39;id&#39;])
                        #    print(mob[&#39;number&#39;])

            #get next mob
            mobUnit = process.read_longlong(mobUnit + 0x150)
    monsters = loc_monsters
    #botty_data[&#39;monsters&#39;] = loc_monsters
    #if botty_data[&#39;necroSkel&#39;] != skel_count:
    #    botty_data[&#39;necroSkel&#39;]=skel_count
    #if botty_data[&#39;necroMage&#39;] != mage_count:
    #    botty_data[&#39;necroMage&#39;]=mage_count
    #if botty_data[&#39;necroGol&#39;]!=golem_count:
    #    botty_data[&#39;necroGol&#39;] = golem_count



if __name__ == &#34;__main__&#34;:
    
    #get new starting offsets
    d2 = d2r_proc()

    #check if we are in game
    ui = d2.base + d2.ui_settings_offset
    igo =0x08
    in_game = d2.process.read_bytes(ui+igo,1)
    in_game = int.from_bytes(in_game,&#34;little&#34;)
    current_level = -1

    new_session = 1
    #constant update
    while 1:
        if new_session==1 and in_game==1:

            d2.get_player_offset(128)
            d2.find_info()
            d2.get_ppos()

            d2.get_map_json(str(d2.map_seed), d2.level)
            d2.read_loot_cfg()
            new_session=0
            current_level = d2.level

        if in_game==1:
            try:
                d2.get_current_level()
            except:
                pass
            if current_level != d2.level:
                d2.get_map_json(str(d2.map_seed), d2.level)
                current_level = d2.level
            d2.get_ppos()
            d2.find_mobs()
            d2.ui_status()
            d2.find_items()
            d2.botty_data[&#39;menus&#39;] = d2.menus

            d2.get_last_hovered()
        if in_game == 0:
            new_session=1
        in_game = d2.process.read_bytes(ui+igo,1)
        in_game = int.from_bytes(in_game,&#34;little&#34;)
        time.sleep(.02)</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="d2read.enums" href="enums.html">d2read.enums</a></code></dt>
<dd>
<div class="desc"><p>lists.py - Really big list of d2 enums.</p></div>
</dd>
<dt><code class="name"><a title="d2read.event" href="event.html">d2read.event</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="d2read.game_state" href="game_state.html">d2read.game_state</a></code></dt>
<dd>
<div class="desc"><p>globals for game state</p></div>
</dd>
<dt><code class="name"><a title="d2read.mem" href="mem.html">d2read.mem</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="d2read.proc" href="proc.html">d2read.proc</a></code></dt>
<dd>
<div class="desc"><p>proc - handles reading memory from the d2r process.</p></div>
</dd>
<dt><code class="name"><a title="d2read.utils" href="utils.html">d2read.utils</a></code></dt>
<dd>
<div class="desc"><p>utils - some misc helper functions</p></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="d2read.delta_in_world_to_minimap_delta"><code class="name flex">
<span>def <span class="ident">delta_in_world_to_minimap_delta</span></span>(<span>delta, diag, scale, deltaZ=0.0)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delta_in_world_to_minimap_delta(delta, diag, scale, deltaZ=0.0):
    camera_angle = -26.0 * 3.14159274 / 180.0
    cos = (diag * math.cos(camera_angle) / scale)
    sin = (diag * math.sin(camera_angle) / scale)
    d = ((delta[0] - delta[1]) * cos, deltaZ - (delta[0] + delta[1]) * sin)
    return d</code></pre>
</details>
</dd>
<dt id="d2read.find_info"><code class="name flex">
<span>def <span class="ident">find_info</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Summary</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>TYPE</code></dt>
<dd>Description</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_info():
    &#34;&#34;&#34;Summary
    
    Returns:
        TYPE: Description
    &#34;&#34;&#34;
    startingAddress = base + player_unit
    playerUnit = process.read_ulonglong(startingAddress)
    pUnitData = playerUnit + 0x10
    try:
        playerNameAddress = process.read_ulonglong(pUnitData)
    except:
        #just so we really know
        print(&#34;FAILED&#34;)
        print(&#34;FAILED&#34;)
        print(&#34;FAILED&#34;)
        print(&#34;FAILED&#34;)
        print(&#34;FAILED&#34;)
        print(&#34;FAILED&#34;)
        return False
        pass
    if(playerNameAddress):
        playerName = process.read_string(playerNameAddress)
    
    pStatsListEx = process.read_ulonglong(playerUnit+0x88)
    statPtr = process.read_ulonglong(pStatsListEx+0x30)
    statCount = process.read_ulonglong(pStatsListEx+0x38)

    experience=0

    for i in range(statCount):

        statOffset = (i-1) * 8
        statEnum = process.read_ushort(statPtr + 0x2 + statOffset)
        if (statEnum == 12):
            player_level = process.read_uint(statPtr + 0x4 + statOffset)
        if (statEnum == 13):
            experience = process.read_uint(statPtr + 0x4 + statOffset)
        if (statEnum == 6):
            hp = process.read_uint(statPtr + 0x4 + statOffset)
            hp = hp &gt;&gt; 8
        if (statEnum == 7):
            maxhp = process.read_uint(statPtr + 0x4 + statOffset)
            max_hp = maxhp &gt;&gt; 8
    log = &#34;LVL:&#34; +str(player_level)+&#34;, HP:&#34;+str(max_hp)+&#34;, EXP:&#34;+str(experience)
    log_color(log,fg_color=mem_color)

    #get the level number
    pPathAddress = playerUnit + 0x38
    pPath = process.read_ulonglong(pPathAddress)
    pRoom1 = pPath + 0x20
    pRoom1Address = process.read_ulonglong(pRoom1)
    pRoom2 = pRoom1Address + 0x18
    pRoom2Address = process.read_ulonglong(pRoom2)
    pLevel = pRoom2Address + 0x90
    pLevelAddress = process.read_ulonglong(pLevel)
    dwLevelNo = pLevelAddress + 0x1F8
    levelNo = process.read_uint(dwLevelNo)
    level_addr = dwLevelNo
    
    
    level = levelNo
    log = (&#34;current level      -&gt; &#34;+str(area_list[levelNo]))
    log_color(log,fg_color=mem_color)

    if not levelNo:
        log = &#34;!! Did not find level num using player offset&#34; +str(playerOffset)
        log_color(log,fg_color=mem_color)


    #get the map seed
    pAct = playerUnit + 0x20
    actAddress = process.read_ulonglong(pAct)


    if actAddress:
        mapSeedAddress = actAddress + 0x14
        if mapSeedAddress:
            mapSeed = process.read_uint(mapSeedAddress)
            map_seed = mapSeed
        else:
            log = (&#34;!! Did not find map seed at address&#34;+(mapSeedAddress))
            log_color(log,fg_color=mem_color)

    #get the level number
    actAddress = process.read_ulonglong(pAct)

    pActUnk1 = actAddress + 0x70
    aActUnk2 = process.read_ulonglong(pActUnk1)
    aDifficulty = aActUnk2 + 0x830
    difficulty = process.read_ushort(aDifficulty)
    difficulty=difficulty

    if difficulty==0:
        log = (&#34;current difficulty      -&gt; Normal&#34;)
        log_color(log,fg_color=mem_color)
    if difficulty==1:
        log = (&#34;current difficulty      -&gt; Nightmare&#34;)
        log_color(log,fg_color=mem_color)
    if difficulty==2:
        log = (&#34;current difficulty      -&gt; Hell&#34;)
        log_color(log,fg_color=mem_color)</code></pre>
</details>
</dd>
<dt id="d2read.find_mobs"><code class="name flex">
<span>def <span class="ident">find_mobs</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Summary</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_mobs():
    &#34;&#34;&#34;Summary
    &#34;&#34;&#34;
    global monsters

    monstersOffset = starting_offset + 1024
    mobs = []
    loc_monsters = []
    skel_count =0
    mage_count =0
    golem_count = &#39;none&#39;

    for i in range(128):
        newOffset = monstersOffset + (8 * (i - 1))
        mobAddress = base + newOffset
        mobUnit = process.read_longlong(mobAddress)
        
        while (mobUnit&gt; 0):

            txtFileNo = process.read_uint(mobUnit + 0x04)
            hide_check = 0
            try:
                hide_npc[txtFileNo]
            except:
                #no key 
                pass

            if not hide_check:

                mobTypeString = &#34;&#34;
                #
                unit_data = process.read_ulonglong(mobUnit + 0x10)
                mob_type = process.read_bytes(unit_data+0x1a,1)
                mob_type_int = int.from_bytes(mob_type,&#34;little&#34;)

                if mob_type_int == 0:
                    mobTypeString = &#39;None&#39;
                if mob_type_int == 1:
                    mobTypeString = &#39;Other&#39;
                if mob_type_int  == 10:
                    mobTypeString = &#39;SuperUnique&#39;
                if mob_type_int == 8:
                    mobTypeString = &#39;Unique&#39;
                if mob_type_int == 12:
                    mobTypeString = &#39;Champion&#39;                        
                if mob_type_int == 16:
                    mobTypeString = &#39;Minion&#39;
                if mob_type_int == 32:
                    mobTypeString = &#39;Possessed?&#39;
                if mob_type_int == 76:
                    mobTypeString = &#39;Ghostly&#39;
                if mob_type_int == 64:
                    mobTypeString = &#39;Multishot?&#39;
                    
                

                unitId = process.read_uint(mobUnit + 0x08)
                mode = process.read_uint(mobUnit + 0x0c)
                iscorpse = process.read_uchar (mobUnit + 0x1A6)
                interactable = process.read_uchar (mobUnit + 0x1A6+4)
                pUnitData = process.read_longlong(mobUnit + 0x10)
                pPath = process.read_longlong(mobUnit + 0x38)
            
                isUnique = process.read_ushort(pUnitData + 0x18)
                #????
                uniqueNo = process.read_ushort(pUnitData + 42)

                monx = process.read_ushort(pPath + 0x02)
                mony = process.read_ushort(pPath + 0x06)
                xPosOffset = process.read_ushort(pPath + 0x00) 
                yPosOffset = process.read_ushort(pPath + 0x04)
                xPosOffset = xPosOffset / 65536
                yPosOffset = yPosOffset / 65536
                monx = monx + xPosOffset
                mony = mony + yPosOffset

                #+026?
                #+017 - eLastMode
                #+018 - dwDuriel - set only for duriel
                #+01C - MonUModList[9] - nine bytes holding the Ids for each MonUMod assigned to the unit
                #+026 - bossNo - hcIdx from superuniques.txt for superuniques (word)
                #+028 - pAiGeneral
                BossLineID = process.read_ushort(unit_data + 0x2A) 

                isBoss = 0
                textTitle = None

                textTitle = get_mob_name[txtFileNo]

                if mob_type_int == 10:
                    try:
                        textTitle = super_unique_names[uniqueNo]
                    except:
                        pass
                if mob_type_int == 8:
                    try:
                        textTitle = get_mob_name[txtFileNo]
                    except:
                        pass
                    isBoss= 1


                #get immunities
                pStatsListEx = process.read_longlong(mobUnit + 0x88)
                ownerType = process.read_uint(pStatsListEx + 0x08)
                ownerId = process.read_uint(pStatsListEx + 0x0C)

                statPtr = process.read_longlong(pStatsListEx + 0x30)
                statCount = process.read_longlong(pStatsListEx + 0x38)

                #if(isUnique):
                    #print(textTitle,mobTypeString, mob_type_int)

                &#39;&#39;&#39;
                #these need to be added

                loadEncText(auraStrings[33], cfg-&gt;MightAura);
                loadEncText(auraStrings[35], cfg-&gt;HolyFireAura);
                loadEncText(auraStrings[40], cfg-&gt;BlessedAimAura);
                loadEncText(auraStrings[43], cfg-&gt;HolyFreezeAura);
                loadEncText(auraStrings[46], cfg-&gt;HolyShockAura);
                loadEncText(auraStrings[28], cfg-&gt;ConvictionAura);
                loadEncText(auraStrings[49], cfg-&gt;FanaticismAura);

                loadEncText(enchantStrings[5], cfg-&gt;encTxtExtraStrong);
                loadEncText(enchantStrings[6], cfg-&gt;encTxtExtraFast);
                loadEncText(enchantStrings[7], cfg-&gt;encTxtCursed);
                loadEncText(enchantStrings[8], cfg-&gt;encTxtMagicResistant);
                loadEncText(enchantStrings[9], cfg-&gt;encTxtFireEnchanted);
                loadEncText(enchantStrings[17], cfg-&gt;encTxtLigntningEnchanted);
                loadEncText(enchantStrings[18], cfg-&gt;encTxtColdEnchanted);
                loadEncText(enchantStrings[25], cfg-&gt;encTxtManaBurn);
                loadEncText(enchantStrings[26], cfg-&gt;encTxtTeleportation);
                loadEncText(enchantStrings[27], cfg-&gt;encTxtSpectralHit);
                loadEncText(enchantStrings[28], cfg-&gt;encTxtStoneSkin);
                loadEncText(enchantStrings[29], cfg-&gt;encTxtMultipleShots);
                loadEncText(enchantStrings[37], cfg-&gt;encTxtFanatic);
                loadEncText(enchantStrings[39], cfg-&gt;encTxtBerserker);

                &#39;&#39;&#39;
                #
                immunities = {&#39;physical&#39;: 0,&#39;magic&#39;: 0,&#39;fire&#39;: 0,&#39;light&#39;: 0,&#39;cold&#39;: 0,&#39;poison&#39;: 0}
                auras = {&#39;MightAura&#39;: 0,&#39;HolyFireAura&#39;: 0, &#39;BlessedAimAura&#39;: 0, &#39;HolyFreezeAura&#39;: 0, &#39;HolyShockAura&#39;: 0,&#39;ConvictionAura&#39;: 0,&#39;FanaticismAura&#39;:0}
                enchants = {&#39;ExtraStrong&#39;: 0,&#39;ExtraFast&#39;: 0, &#39;Cursed&#39;: 0, &#39;MagicResistant&#39;: 0, &#39;FireEnchanted&#39;: 0,&#39;LigntningEnchanted&#39;: 0,&#39;ColdEnchanted&#39;:0,&#39;ManaBurn&#39;:0,&#39;Teleportation&#39;:0,&#39;SpectralHit&#39;:0,&#39;StoneSkin&#39;:0,&#39;MultipleShots&#39;:0,&#39;Berserker&#39;:0}

                for s in range(statCount):
                    offset = (s -1) * 8
                    statParam = process.read_ushort(statPtr + offset)
                    statEnum = process.read_ushort(statPtr + 0x2 + offset)
                    statValue = process.read_uint(statPtr + 0x4 + offset)
                    if (statValue&gt;= 100):
                        if statEnum == 36:
                            immunities[&#34;physical&#34;] = 1 #physical immune      
                        if statEnum == 37:
                            immunities[&#34;magic&#34;] = 1    
                        if statEnum == 39:
                            immunities[&#34;fire&#34;] = 1
                        if statEnum == 41:
                            immunities[&#34;light&#34;] = 1  
                        if statEnum == 43:
                            immunities[&#34;cold&#34;] = 1
                        if statEnum == 45:
                            immunities[&#34;poison&#34;] = 1 
                get_ppos()
                dist = math.dist(game_state.player_world_pos,np.array([int(monx),int(mony)]))

                abs_screen_position = world_to_abs(np.array([monx,mony]), game_state.player_world_pos)
                mob = {&#39;position&#39;: np.array([int(monx),int(mony)]),&#39;dist&#39;: dist, &#39;abs_screen_position&#39;: abs_screen_position, &#39;immunities&#39;: immunities, &#39;unit_type&#39;: &#39;Monster&#39;, &#39;type&#39;: mobTypeString, &#39;id&#39;: unitId, &#39;name&#39;: textTitle, &#39;mode&#39;: mode, &#39;number&#39;: txtFileNo, &#39;super_unique&#39;:isUnique,&#39;boss&#39;:isBoss,&#39;is_corpse&#39;:iscorpse, &#39;interactable&#39;:interactable }
                
                # filter out some stuff and calculate summon count
                if textTitle is not None:
                    if &#39;ClayGolem&#39; in mob[&#39;name&#39;]:
                        if mob[&#39;mode&#39;] != 12:
                            golem_count = &#34;ClayGolem&#34;

                    elif &#39;FireGolem&#39; in mob[&#39;name&#39;]:
                        if mob[&#39;mode&#39;] != 12:
                            golem_count = &#34;FireGolem&#34;

                    elif &#39;BloodGolem&#39; in mob[&#39;name&#39;]:
                        if mob[&#39;mode&#39;] != 12:
                            golem_count = &#34;BloodGolem&#34;

                    elif &#39;IronGolem&#39; in mob[&#39;name&#39;]:
                        if mob[&#39;mode&#39;] != 12:
                            golem_count = &#34;IronGolem&#34;

                    elif &#39;NecroMage&#39; == mob[&#39;name&#39;]:
                        if mob[&#39;mode&#39;] != 12:
                            mage_count +=1

                    elif &#39;NecroSkeleton&#39; == mob[&#39;name&#39;]:
                        if mob[&#39;mode&#39;] != 12:
                            skel_count +=1
                    elif &#39;Rouge&#39; in mob[&#39;name&#39;]:
                        pass
                    elif &#39;Gaurd&#39; in mob[&#39;name&#39;]:
                        pass
                    elif &#39;Alkor&#39; in mob[&#39;name&#39;]:
                        pass
                    elif &#39;a trap&#39; in mob[&#39;name&#39;]:
                        pass
                    elif &#39;IronWolf&#39; in mob[&#39;name&#39;]:
                        pass
                    elif &#39;Malachai&#39; in mob[&#39;name&#39;]:
                        pass
                    elif mob[&#39;name&#39;] == &#39;&#39;:
                        pass
                    elif &#39;?&#39; in mob[&#39;name&#39;]:
                        pass
                    elif &#39;Barricade&#39; in mob[&#39;name&#39;]:
                        pass
                    else:
                        loc_monsters.append(mob)

                        #if dist&lt;5:
                        #    print(mob[&#39;name&#39;])

                        #    print(mob[&#39;id&#39;])
                        #    print(mob[&#39;number&#39;])

            #get next mob
            mobUnit = process.read_longlong(mobUnit + 0x150)
    monsters = loc_monsters
    #botty_data[&#39;monsters&#39;] = loc_monsters
    #if botty_data[&#39;necroSkel&#39;] != skel_count:
    #    botty_data[&#39;necroSkel&#39;]=skel_count
    #if botty_data[&#39;necroMage&#39;] != mage_count:
    #    botty_data[&#39;necroMage&#39;]=mage_count
    #if botty_data[&#39;necroGol&#39;]!=golem_count:
    #    botty_data[&#39;necroGol&#39;] = golem_count</code></pre>
</details>
</dd>
<dt id="d2read.find_objects"><code class="name flex">
<span>def <span class="ident">find_objects</span></span>(<span>file_number: int)</span>
</code></dt>
<dd>
<div class="desc"><p>Summary</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>file_number</code></strong> :&ensp;<code>int</code></dt>
<dd>Description</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>TYPE</code></dt>
<dd>Description</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_objects(file_number:int):
    &#34;&#34;&#34;Summary
    
    Args:
        file_number (int): Description
    
    Returns:
        TYPE: Description
    &#34;&#34;&#34;
    super_chests =[]
    object_offset = starting_offset + (2 * 1024)
    attempts=0


    for i in range(256):
        attempts=i+0
        new_offset = object_offset + (8 * (i-1))
        item_addr = base + new_offset
        object_unit = process.read_longlong(item_addr)

        #print(i)
        while (object_unit&gt;0):
            item_type = process.read_int(object_unit+0x00)
            pRoomnext = process.read_ulonglong(object_unit+0x158)
            #pRoomEx = process.read_ulonglong (pRoomnext+0x18)
            if(item_type==2):
                file_no = process.read_int(object_unit+0x04)
                if file_no == file_number:
                    print (&#34;Object found&#34;)
                    p_unit_data = process.read_ulonglong(object_unit + 0x10)
                    mode = process.read_uint (object_unit + 0x0C)
                    #pObjectTxt = process.read_ulonglong(p_unit_data)
                    #print(str(pObjectTxt))
                    #sObjectTxt = process.read_string(p_unit_data, 16)
                    #shrineTxt = process.read_string(p_unit_data + 0x0c, 16)
                    pPath = process.read_ulonglong(object_unit + 0x38)  
                    objectx = process.read_ushort(pPath + 0x10)
                    objecty = process.read_ushort(pPath + 0x14)
                    x_pos = process.read_ushort(path_addr+0x02)
                    y_pos = process.read_ushort(path_addr+0x06)
                    odist = math.dist([objectx,objecty],[x_pos,y_pos])
                    #print(y_pos)
                    #print(x_pos)
                    print(txt_obj_name[file_no-1] + &#34;&#34;+ str(str(file_no)))    
                    print(&#39;dist -&gt; &#39;+ str(odist))
                    obj = Object (objectx, objecty, mode)
                    return obj



            object_unit = process.read_longlong(object_unit + 0x150)</code></pre>
</details>
</dd>
<dt id="d2read.game_tick"><code class="name flex">
<span>def <span class="ident">game_tick</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def game_tick():
    global running

    current_level = -1
    local_tick = -1
    #global offsets
    populate_offsets()
    
    
    while running:

        get_in_game_flag()
        get_tick()

        #this should sync us to the current game clock, to prevent acessing things during loading times
        if game_state.tick &gt;0 and game_state.tick != local_tick:

            if game_state.new_session==1 and game_state.in_game ==1:
                #in game offsets
                
                log = (&#34;In Game!&#34;)
                log_color(log,fg_color=important_color)
                populate_punit()
                get_current_level()

                get_map_json(str(game_state.map_seed), game_state.level)
                #_cluster_map_data(game_state.botty_data[&#34;map&#34;])
                #read_loot_cfg()
                game_state.new_session=0
                current_level = game_state.level
                game_state.loaded = 1

            if game_state.in_game == 1 and game_state.loaded==1:

                try:
                    get_current_level()
                except Exception as err:
                    print(err)

                if current_level != game_state.level:
                    log = (&#34;New Map!&#34;)
                    log_color(log,fg_color=important_color)
                    #self.d2.botty_data[&#34;clusters&#34;] =  None
                    #self.d2.botty_data[&#34;features&#34;] =  None
                    game_state.loaded=0
                    get_map_json(str(game_state.map_seed), game_state.level)
                    #self.d2.get_map_json(str(self.d2.map_seed), self.d2.level)
                    game_state._features = None
                    #_cluster_map_data(self.d2.botty_data[&#34;map&#34;])
                    current_level = game_state.level
                    #game_state._current_area = str(self.d2.botty_data[&#39;current_area&#39;])
                    game_state.loaded=1

                try:
                    get_ppos()
                    #find_mobs()
                    #ui_status()
                    get_ui()
                    #print(game_state.player_world_pos)
                    #get_items()
                    #self.d2.botty_data[&#39;menus&#39;] = self.d2.menus
                    #self.d2.get_last_hovered()
                except Exception as err:
                    print(err)
                    pass
            if game_state.in_game == 1:
                events.emit(&#34;game_state_update&#34;)

            if game_state.in_game == 0:
                game_state.new_session=1
                game_state.loaded=0    

        local_tick = game_state.tick    </code></pre>
</details>
</dd>
<dt id="d2read.get_addr_test"><code class="name flex">
<span>def <span class="ident">get_addr_test</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Summary - for debug</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_addr_test():
    &#34;&#34;&#34;Summary - for debug
    &#34;&#34;&#34;
    global game_info_state

    offset = game_info_offset
    game_info_addr = base + offset

    result = process.read_bytes(game_info_addr+0x2a+24+6,14)
    off = 0x2a
    off = 0x6d
    off = 0xb4
    #result = process.read_bytes(game_info_addr+off+24+6,4)
    &#39;&#39;&#39;
    for i in range(-128,128):
        result = process.read_ulonglong(game_info_addr+off+24+6+i)
        try:
            result_2 = process.read_bytes(result,32)
            #result_3 = process.read_uint(result)
            #r = int.from_bytes(result,&#34;little&#34;)
            print(result_2,i)
        except:
            pass
    &#39;&#39;&#39;
    result = process.read_ulonglong(game_info_addr+off+24+6+38)
    result_2 = process.read_bytes(result+4+2+2-2,11)

    result_2 = process.read_bytes(result+4+2+2-2+10,1)

    #print(hex(result-base))

    #ret = unpack(&#39;&lt;Q&#39;, result_2)
    #result_3 = int.from_bytes(result_2,&#39;little&#39;)
    #result_4 = process.read_ulong(result+8)
    #print(result_2)
    return result_2</code></pre>
</details>
</dd>
<dt id="d2read.get_current_level"><code class="name flex">
<span>def <span class="ident">get_current_level</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Summary</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_current_level():
    &#34;&#34;&#34;Summary
    &#34;&#34;&#34;
    startingAddress = base + player_unit
    playerUnit = process.read_ulonglong(startingAddress)
    pUnitData = playerUnit + 0x10
    #get the level number
    pPathAddress = playerUnit + 0x38
    pPath = process.read_ulonglong(pPathAddress)
    pRoom1 = pPath + 0x20
    pRoom1Address = process.read_ulonglong(pRoom1)
    pRoom2 = pRoom1Address + 0x18
    pRoom2Address = process.read_ulonglong(pRoom2)
    pLevel = pRoom2Address + 0x90
    pLevelAddress = process.read_ulonglong(pLevel)
    dwLevelNo = pLevelAddress + 0x1F8
    levelNo = process.read_uint(dwLevelNo)
    level_addr = dwLevelNo
    game_state.level = levelNo</code></pre>
</details>
</dd>
<dt id="d2read.get_cursor_item"><code class="name flex">
<span>def <span class="ident">get_cursor_item</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_cursor_item():
    #pUnit-&gt;inventory_0x60-&gt;unitdata_0x20-&gt;itemdata0x14-&gt;itemLvl_0x2C
    items = []
    item_offset = starting_offset + (4*1024)

    for i in range(256):


        new_offset = item_offset +(8 *(i))
        item_addr = base + new_offset
        item_unit = process.read_longlong(item_addr)

        while (item_unit&gt;0):
            item_type = process.read_uint(item_unit+0x00)
            if item_type == 4:
                txt_file_no = process.read_uint(item_unit+0x04)
                item_loc = process.read_uint(item_unit+0x0C)

                # item loc 0 = inventory, 1 = equipped, 2 in belt, 3 on ground, 4 cursor, 5 dropping ,6 socketed
                if item_loc == 4:
                    #print(&#34;item on ground&#34;)
                    print(&#34;item on cursor&#34;)
                    p_unit_data = process.read_longlong(item_unit + 0x10)
                    #itemQuality - 5 is set, 7 is unique (6 rare, 4, magic)
                    item_quality = process.read_uint(p_unit_data)
                    p_path = process.read_longlong(item_unit+0x38)
                    item_x = process.read_ushort(p_path+0x10)
                    item_y = process.read_ushort(p_path+0x14)


                    p_stat_list_ex = process.read_longlong(item_unit + 0x88)
                    stat_ptr = process.read_longlong(p_stat_list_ex + 0x30)
                    stat_count = process.read_longlong(p_stat_list_ex + 0x38)
                    num_sockets = 0

                    for j in range(stat_count):
                        #print(&#34;checking for sockets&#34;)
                        stat_offset = (j)*8
                        stat_enum = process.read_ushort(stat_ptr+0x2+stat_offset)
                        #print(stat_enum)

                        if stat_enum == 73:
                            s_73 = process.read_uint(stat_ptr+0x4+stat_offset)
                            #print(&#39;number of sockets -&gt;&#39;+str(num_sockets))
                            #print(s_73)

                        if stat_enum == 72:
                            s_72 = process.read_uint(stat_ptr+0x4+stat_offset)
                            #print(&#39;number of sockets -&gt;&#39;+str(num_sockets))
                            #print(s_72)

                        if stat_enum == 22:
                            s_22 = process.read_uint(stat_ptr+0x4+stat_offset)
                            #print(s_22)
                            #print(&#39;number of sockets -&gt;&#39;+str(num_sockets))

                        if stat_enum == 21:
                            s_21 = process.read_uint(stat_ptr+0x4+stat_offset)
                            #print(s_21)
                            #print(&#39;number of sockets -&gt;&#39;+str(num_sockets))

                        if stat_enum == 194:
                            num_sockets = process.read_uint(stat_ptr+0x4+stat_offset)
                            #print(&#39;number of sockets -&gt;&#39;+str(num_sockets))


                    flags = process.read_uint(p_unit_data+0x18)

                    identified = False
                    if(0x00000010 &amp; flags):
                        identified = True
                        #print(&#34;id&#39;d&#34;)
                    ethereal = False
                    if(0x00400000 &amp; flags):
                        ethereal = True

                    quality=&#39;Any&#39;
                    if item_quality == 1:
                        quality = &#39;Inferior&#39;
                    if item_quality == 2:
                        quality = &#39;Normal&#39;
                    if item_quality == 3:
                        quality = &#39;Superior&#39;
                    if item_quality == 4:
                        quality = &#39;Magic&#39;
                    if item_quality == 5:
                        quality = &#39;Set&#39;
                    if item_quality == 6:
                        quality = &#39;Rare&#39;
                    if item_quality == 7:
                        quality = &#39;Unique&#39;
                    if item_quality == 8:
                        quality = &#39;Crafted&#39;
                    if item_quality == 9:
                        quality = &#39;Tempered&#39;

                    #print(txt_file_no)
                    if txt_file_no &gt;= 557 and txt_file_no &lt;= 586 or txt_file_no&gt;= 597 and txt_file_no&lt;= 601:
                        quality = &#39;Gem&#39;
                    if txt_file_no &gt;= 610 and txt_file_no &lt;= 642:
                        quality = &#39;Rune&#39;

                    item = (txt_file_no,quality,item_name[txt_file_no],item_quality,item_loc,item_x,item_y,num_sockets)



                    print(item_name[txt_file_no],item)


            item_unit = process.read_longlong(item_unit + 0x150)</code></pre>
</details>
</dd>
<dt id="d2read.get_exp_offset"><code class="name flex">
<span>def <span class="ident">get_exp_offset</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Summary</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>TYPE</code></dt>
<dd>Description</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_exp_offset():
    &#34;&#34;&#34;Summary
    
    Returns:
        TYPE: Description
    &#34;&#34;&#34;
    #expansion offset
    pat = b&#39;\xC7\x05........\x48\x85\xC0\x0F\x84....\x83\x78\x5C.\x0F\x84....\x33\xD2\x41&#39;
    #this works fine, shorter pattern
    global exp_offset
    pat = b&#39;\xC7\x05........\x48\x85\xC0\x0F\x84....&#39;
    pat_addr = pymem.pattern.pattern_scan_module(handle, module, pat)
    offset_buffer = process.read_int(pat_addr-4)
    exp_offset = ((pat_addr - base) + offset_buffer)
    log = (&#34;Found exp offset        -&gt;&#34;)
    log_color(log,target=hex(exp_offset),fg_color=mem_color,fg2_color=offset_color)</code></pre>
</details>
</dd>
<dt id="d2read.get_game_info_offset"><code class="name flex">
<span>def <span class="ident">get_game_info_offset</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Summary</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>TYPE</code></dt>
<dd>Description</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_game_info_offset():
    &#34;&#34;&#34;Summary
    
    Returns:
        TYPE: Description
    &#34;&#34;&#34;
    #get game info offset
    global game_info_offset
    pat = b&#39;\xE8....\x48\x8D\x0D....\x44\x88\x2D....&#39;
    pat_addr = pymem.pattern.pattern_scan_module(handle, module, pat)
    offset_buffer = process.read_int(pat_addr+8)
    game_info_offset = ((pat_addr - base)  + 7 -256 + 5 + offset_buffer)
    log = (&#34;Found game info offset  -&gt;&#34;)
    log_color(log,target=hex(game_info_offset),fg_color=mem_color,fg2_color=offset_color)</code></pre>
</details>
</dd>
<dt id="d2read.get_game_ip"><code class="name flex">
<span>def <span class="ident">get_game_ip</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Summary - update the game data globals</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_game_ip():
    &#34;&#34;&#34;Summary - update the game data globals
    &#34;&#34;&#34;

    offset = game_info_offset
    game_info_addr = base + offset
    #bytes_read = process.read_bytes(game_info_addr+0x1D0,31)
    #ret = unpack(&#39;??????xx???????xxxx?x?xx????x??&#39;, bytes_read)    
    ip = process.read_string(game_info_addr+0X1D0,16)</code></pre>
</details>
</dd>
<dt id="d2read.get_game_name"><code class="name flex">
<span>def <span class="ident">get_game_name</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Summary - update the game data globals with the current game name</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_game_name():
    &#34;&#34;&#34;Summary - update the game data globals with the current game name
    &#34;&#34;&#34;
    offset = game_info_offset
    game_info_addr = base + offset
    read_game_name = process.read_string(game_info_addr+72,16)
    game_state.game_name = read_game_name</code></pre>
</details>
</dd>
<dt id="d2read.get_game_pass"><code class="name flex">
<span>def <span class="ident">get_game_pass</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Summary - update the game data globals with the current game password</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_game_pass():
    &#34;&#34;&#34;Summary - update the game data globals with the current game password
    &#34;&#34;&#34;
    global game_info_state

    offset = game_info_offset
    game_info_addr = base + offset

    read_game_pass = process.read_string(game_info_addr+120,16)
    game_state.game_pass = read_game_pass</code></pre>
</details>
</dd>
<dt id="d2read.get_hover_object_offset"><code class="name flex">
<span>def <span class="ident">get_hover_object_offset</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Summary</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>TYPE</code></dt>
<dd>Description</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_hover_object_offset():
    &#34;&#34;&#34;Summary
    
    Returns:
        TYPE: Description
    &#34;&#34;&#34;
    global hover_offset
    pat = b&#39;\xc6\x84\xc2.....\x48\x8b\x74.&#39;
    pat_addr = pymem.pattern.pattern_scan_module(handle, module, pat, return_multiple=False)
    offset_buffer = process.read_bytes(pat_addr+3,4)
    offset_buffer_int = int.from_bytes(offset_buffer,&#39;little&#39;)
    hover_offset = (offset_buffer_int)-1
    log = (&#34;Found hover offset      -&gt;&#34;)
    log_color(log,target=hex(hover_offset),fg_color=mem_color,fg2_color=offset_color)</code></pre>
</details>
</dd>
<dt id="d2read.get_in_game_flag"><code class="name flex">
<span>def <span class="ident">get_in_game_flag</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Summary</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>TYPE</code></dt>
<dd>Description</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_in_game_flag():
    &#34;&#34;&#34;Summary
    
    Returns:
        TYPE: Description
    &#34;&#34;&#34;
    #get game info offset
    ui = base + ui_settings_offset
    igo =0x08
    in_game_ptr = process.read_bytes(ui+igo,1)
    game_state.in_game = int.from_bytes(in_game_ptr ,&#34;little&#34;)        </code></pre>
</details>
</dd>
<dt id="d2read.get_items"><code class="name flex">
<span>def <span class="ident">get_items</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Summary</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_items():
    &#34;&#34;&#34;Summary
    &#34;&#34;&#34;
    items=[]
    item_offset = starting_offset + (4*1024)

    for i in range(256):


        new_offset = item_offset +(8 *(i))
        item_addr = base + new_offset
        item_unit = process.read_longlong(item_addr)

        while (item_unit&gt;0):
            item_type = process.read_uint(item_unit+0x00)

            if item_type == 4:
                txt_file_no = process.read_uint(item_unit+0x04)
                item_loc = process.read_uint(item_unit+0x0C)

                # item loc 0 = inventory, 1 = equipped, 2 in belt, 3 on ground, 4 cursor, 5 dropping ,6 socketed
                if item_loc == 0 or 1:
                    #print(&#34;item on ground&#34;)
                    p_unit_data = process.read_longlong(item_unit + 0x10)
                    #itemQuality - 5 is set, 7 is unique (6 rare, 4, magic)
                    item_quality = process.read_uint(p_unit_data)
                    p_path = process.read_longlong(item_unit+0x38)
                    item_x = process.read_ushort(p_path+0x10)
                    item_y = process.read_ushort(p_path+0x14)

                    p_stat_list_ex = process.read_longlong(item_unit + 0x88)
                    stat_ptr = process.read_longlong(p_stat_list_ex + 0x30)
                    stat_count = process.read_longlong(p_stat_list_ex + 0x38)
                    num_sockets = 0

                    for j in range(stat_count):
                        #print(&#34;checking for sockets&#34;)
                        stat_offset = (j)*8
                        stat_enum = process.read_ushort(stat_ptr+0x2+stat_offset)
                        if stat_enum == 194:
                            num_sockets = process.read_uint(stat_ptr+0x4+stat_offset)
                            #print(&#39;number of sockets -&gt;&#39;+str(num_sockets))
                            break

                    flags = process.read_uint(p_unit_data+0x18)


                    identified = False
                    if(0x00000010 &amp; flags):
                        identified = True
                        #print(&#34;id&#39;d&#34;)
                    ethereal = False
                    if(0x00400000 &amp; flags):
                        ethereal = True

                    quality=&#39;Any&#39;
                    if item_quality == 1:
                        quality = &#39;Inferior&#39;
                    if item_quality == 2:
                        quality = &#39;Normal&#39;
                    if item_quality == 3:
                        quality = &#39;Superior&#39;
                    if item_quality == 4:
                        quality = &#39;Magic&#39;
                    if item_quality == 5:
                        quality = &#39;Set&#39;
                    if item_quality == 6:
                        quality = &#39;Rare&#39;
                    if item_quality == 7:
                        quality = &#39;Unique&#39;
                    if item_quality == 8:
                        quality = &#39;Crafted&#39;
                    if item_quality == 9:
                        quality = &#39;Tempered&#39;

                    #print(txt_file_no)
                    if txt_file_no &gt;= 557 and txt_file_no &lt;= 586 or txt_file_no&gt;= 597 and txt_file_no&lt;= 601:
                        quality = &#39;Gem&#39;
                    if txt_file_no &gt;= 610 and txt_file_no &lt;= 642:
                        quality = &#39;Rune&#39;


                    body_loc = process.read_uchar(p_unit_data+0x54)
                    inventory_page = process.read_uchar(p_unit_data+0x0c)
                    inventory_ptr = process.read_ulonglong(p_unit_data+0x70)

                    node = process.read_uchar(p_unit_data+0x88)
                    nodeOther = process.read_uchar(p_unit_data+0x89)
                    
                    item = (txt_file_no,quality,item_name[txt_file_no],item_quality,item_loc,item_x,item_y,num_sockets,inventory_page,inventory_ptr,body_loc)


                    items.append(item)

                    &#39;&#39;&#39;
                    for category in _loot_data:
                        q_match = 0
                        i_match = 0
                        loot_check = 0

                        data = _loot_data.get(category)
                        quality_match = [&#39;Any&#39;]
                        item_match = [&#39;Any&#39;]
                        try:
                            quality_match = data[&#39;quality&#39;]
                        except:
                            quality_match = [&#39;Inferior&#39;,&#39;Normal&#39;,&#39;Superior&#39;,&#39;Magic&#39;,&#39;Set&#39;,&#39;Rare&#39;,&#39;Unique&#39;,&#39;Crafted&#39;,&#39;Tempered&#39;,&#39;Gem&#39;,&#39;Rune&#39;]
                            pass
                        try:
                            item_match = data[&#39;items&#39;]
                        except:
                            item_match = [&#39;Any&#39;]
                            pass

                        for q in quality_match:
                            if quality in q:
                                q_match=1

                        for i in item_match:
                            item_to_check = str(item_name[txt_file_no])
                            if num_sockets&gt;0:
                                item_to_check = str(item_name[txt_file_no])+&#39;,&#39;+str(num_sockets)
                            if item_to_check in i or item_match[0] is &#39;Any&#39;:
                                i_match=1

                        if q_match and i_match:
                            loot_check =1

                        try:
                            if data[&#39;ignoreidentified&#39;] is True and identified:
                                loot_check=0
                        except:
                            pass

                        if loot_check:
                            print(&#34;good to loot&#34;)
                            #_move_to_mem(item_x,item_y)
                            print(item_name[txt_file_no])
                    &#39;&#39;&#39;
        
                    

            item_unit = process.read_longlong(item_unit + 0x150)

    game_state.items=items</code></pre>
</details>
</dd>
<dt id="d2read.get_last_hovered"><code class="name flex">
<span>def <span class="ident">get_last_hovered</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Summary</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_last_hovered():
    &#34;&#34;&#34;Summary
    &#34;&#34;&#34;
    global hover_offset

    offset = hover_offset
    is_hovered = process.read_int(offset+base+0x00)
    is_tooltip = process.read_int(offset+base+0x01)
    hovered_unit_type = process.read_int(offset+base+0x03)
    hid =process.read_uint(offset+base+0x08)

    #print(hovered_unit_type)

    #print(hid)

    #print(is_tooltip)

    if is_hovered:
        
        game_state.hover_obj = hid
        #print(hid)
        if hovered_unit_type == 1024:
            for item in game_state.items:
                #print(len(game_state.items))
                try:
                    pass
                    #print(game_state.items[hid-1])
                except:
                    pass
                break


        if hovered_unit_type == 256:
            if monsters is not None:
                for m in monsters:
                    #print(m)
                    if hid == m[&#39;id&#39;] and is_hovered:
                        #print(m[&#39;name&#39;])
                        pass
                        break</code></pre>
</details>
</dd>
<dt id="d2read.get_map_json"><code class="name flex">
<span>def <span class="ident">get_map_json</span></span>(<span>seed, mapid: int, objectIDs: list = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Summary</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>seed</code></strong> :&ensp;<code>TYPE</code></dt>
<dd>current map seed read from memory</dd>
<dt><strong><code>mapid</code></strong> :&ensp;<code>int</code></dt>
<dd>current in game map number</dd>
<dt><strong><code>objectIDs</code></strong> :&ensp;<code>list</code>, optional</dt>
<dd>Description</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>TYPE</code></dt>
<dd>Description</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_map_json(seed, mapid:int, objectIDs:list=None):
    &#34;&#34;&#34;Summary
    
    Args:
        seed (TYPE): current map seed read from memory
        mapid (int): current in game map number
        objectIDs (list, optional): Description
    
    Returns:
        TYPE: Description
    &#34;&#34;&#34;

    #url for map api
    base_url=&#39;http://34.69.54.92:8000&#39;    
    url=base_url+&#39;/&#39;+str(seed)+f&#39;/2/{str(mapid)}/1&#39;

    log = (&#34;Got data from           -&gt; {}&#34;.format(url))
    log_color(log,fg_color=mem_color)
    resp = requests.get(url=url)
    j = resp.json()

    obj = j[&#39;objects&#39;]
    if objectIDs is not None:
        for objectID in objectIDs:
            responseList.append (obj[objectID])
    map_offset_x = j[&#39;offset&#39;][&#39;x&#39;]
    map_offset_y = j[&#39;offset&#39;][&#39;y&#39;]

    map_offset =np.array([map_offset_x,map_offset_y])


    map_offset = map_offset
    row = []
    for point in j[&#39;mapData&#39;]:
        if point != -1:
            row.append (point)
        else:
            game_state.grid.append (row)
            row = []              
    
    

    def split(a, sep):
        &#34;&#34;&#34;Summary segment up map data for the correct formatting for collisions/path finding
        
        Args:
            a (TYPE): data
            sep (TYPE): delimiter
        
        Yields:
            TYPE: Chop up our map xx
        &#34;&#34;&#34;
        pos = i = 0
        while i &lt;len(a):
            if a[i:i+len(sep)] == sep:
                yield a[pos:i]
                pos = i = i+len(sep)
            else:
                i += 1
        yield a[pos:i]


    if j != None:
        map_crop = j[&#39;crop&#39;]
        obj_str = &#34;|&#34;
        poi_str = &#34;|&#34;
        #these are mostly garbage and not useful, its map decorator stuff
        for key in j[&#39;objects&#39;]:
            value = j[&#39;objects&#39;][key]
            name = objects[int(key)]
            obj_str+=name+&#34;|&#34;
            #print(int(key),name)
            for instance in value:
                offset_x =instance[&#39;x&#39;]
                offset_y=instance[&#39;y&#39;]
                pos =np.array([offset_x,offset_y])
                pos_area = pos-map_offset
                flag = 0
                new_obj = {&#34;position&#34;:pos,&#34;flag&#34;:1,&#34;name&#34;:name,&#34;pos_area&#34;:pos_area}
                game_state.map_objects.append(new_obj)
                break

        #filter ut way points from the objects list
        for key in j[&#39;objects&#39;]:
            value = j[&#39;objects&#39;][key]
            name = objects[int(key)]
            if &#39;waypoint&#39; in name or &#39;Waypoint&#39; in name:
                poi_str+=name+&#34;|&#34;
                #print(int(key),name)
                for instance in value:
                    offset_x =instance[&#39;x&#39;]
                    offset_y=instance[&#39;y&#39;]
                    pos =np.array([offset_x,offset_y])
                    pos_area = pos-map_offset
                    flag = 0
                    new_obj = {&#34;position&#34;:pos,&#34;flag&#34;:1,&#34;label&#34;:name,&#34;pos_area&#34;:pos_area}
                    game_state.points_of_interest.append(new_obj)
                    break

        #convert exits to a uniform format in poi
        if j[&#39;exits&#39;] is not None:
            for key in j[&#39;exits&#39;]:
                value = j[&#39;exits&#39;][key]
                name = areas[int(key)]
                poi_str+=name+&#34;|&#34;
                is_portal = value[&#39;isPortal&#39;]
                offset_x = value[&#39;offsets&#39;][0][&#39;x&#39;]
                offset_y = value[&#39;offsets&#39;][0][&#39;y&#39;]
                pos =np.array([offset_x,offset_y])
                pos_area = pos-map_offset
                new_poi = {&#34;position&#34;:pos,&#34;type&#34;:1,&#34;label&#34;:name,&#34;pos_area&#34;:pos_area}
                game_state.points_of_interest.append(new_poi)
        #convert npcs to a uniform format
        if j[&#39;npcs&#39;] is not None:
            for key in j[&#39;npcs&#39;]:
                if int(key)&lt;738:
                    value = j[&#39;npcs&#39;][key]
                    name = get_mob_name[int(key)]
                    poi_str+=name+&#34;|&#34;
                    is_portal=False
                    is_npc=True
                    offset_x = value[0][&#39;x&#39;]
                    offset_y = value[0][&#39;y&#39;]
                    pos = np.array([offset_x,offset_y])
                    pos_area = pos-map_offset
                    new_poi = {&#34;position&#34;:pos,&#34;type&#34;:1,&#34;label&#34;:name,&#34;pos_area&#34;:pos_area}
                    game_state.points_of_interest.append(new_poi)

        map_id = j[&#39;id&#39;]
        map_data = j[&#39;mapData&#39;]
        map_size = j[&#39;size&#39;]
        map_decode = list(split(map_data,sep=[-1]))

        area_origin = map_offset
        nodes = []
        col_grid = []

        collision_grid = np.empty([int(map_size[&#39;height&#39;]),int(map_size[&#39;width&#39;])], dtype=np.uint8)
        
        if map_data != None:
            mini_map_w=int(map_size[&#39;width&#39;])
            mini_map_h=int(map_size[&#39;height&#39;])
            walkable = True
            y = 0
            for ele in map_decode:
                x = 0
                row = []
                for i in range(len(ele)):
                    if walkable:
                        for j in range(ele[i]):
                            nodes.append([x,y,walkable])
                            row.append(0)
                            collision_grid[y][x] = 0
                            x+=1
                    if not walkable:
                        for j in range(ele[i]):
                            nodes.append([x,y,walkable])
                            row.append(-1)
                            collision_grid[y][x] = -1
                            x+=1

                    walkable = not walkable
                y+=1
                col_grid.append(row)
                x=0
                walkable = True
        

        new_map = {&#34;crop&#34;: map_crop,&#34;id&#34;: map_id,&#39;poi&#39;: game_state.points_of_interest,&#34;objects&#34;: game_state.map_objects,&#34;size&#34;: map_size,&#34;nodes&#34;:nodes,&#34;data&#34;:col_grid}

        log = (&#34;Loaded map              -&gt; {}&#34;.format(area_list[new_map[&#39;id&#39;]]))
        current_area=area_list[new_map[&#39;id&#39;]]

        log_color(log,fg_color=mem_color)
        log = (&#34;Number of POI           -&gt; {}&#34;.format(len(game_state.points_of_interest)))
        log_color(log,fg_color=mem_color)
        log = (&#34;{}&#34;.format(poi_str))
        log_color(log,fg_color=mem_color)
        log = (&#34;Number of OBJ           -&gt; {}&#34;.format(len(game_state.map_objects)))
        log_color(log,fg_color=mem_color)
        log = (&#34;{}&#34;.format(obj_str))
        log_color(log,fg_color=mem_color)

        game_state.maps.append(new_map)</code></pre>
</details>
</dd>
<dt id="d2read.get_menu_data_offset"><code class="name flex">
<span>def <span class="ident">get_menu_data_offset</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Summary</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>TYPE</code></dt>
<dd>Description</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_menu_data_offset():
    &#34;&#34;&#34;Summary
    
    Returns:
        TYPE: Description
    &#34;&#34;&#34;
    #unit table offset
    global ui_offset
    pat = b&#34;\x41\x0f\xb6\xac\x3f....&#34;
    pat_addr = pymem.pattern.pattern_scan_module(handle, module, pat)
    offset_buffer = process.read_int(pat_addr-5)
    ui_offset = ((pat_addr - base) + offset_buffer)
    log = (&#34;Found menu data offset  -&gt;&#34;)
    log_color(log,target=hex(ui_offset),fg_color=mem_color,fg2_color=offset_color)
    #ui_offset =  0x21F89AA</code></pre>
</details>
</dd>
<dt id="d2read.get_menu_vis_offset"><code class="name flex">
<span>def <span class="ident">get_menu_vis_offset</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Summary</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>TYPE</code></dt>
<dd>Description</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_menu_vis_offset():
    &#34;&#34;&#34;Summary
    
    Returns:
        TYPE: Description
    &#34;&#34;&#34;
    #menu vis offset
    #pat = b&#39;\x8B\x05....\x89\x44\x24\x20\x74\x07&#39;
    #?? search less direct matches?
    global menu_offset
    pat = b&#39;\x8B\x05....\x89\x44.\x20\x74\x07&#39;
    pat_addr = pymem.pattern.pattern_scan_module(handle, module, pat)
    offset_buffer = process.read_int(pat_addr+2)
    #maybe dont need +6 here?
    menu_offset = ((pat_addr - base) + 6 + offset_buffer)
    log = (&#34;Found menu offset       -&gt;&#34;)
    log_color(log,target=hex(menu_offset),fg_color=mem_color,fg2_color=offset_color)</code></pre>
</details>
</dd>
<dt id="d2read.get_player_offset"><code class="name flex">
<span>def <span class="ident">get_player_offset</span></span>(<span>loops=128)</span>
</code></dt>
<dd>
<div class="desc"><p>Summary - scan for player unit as a starting point for all relevant memory offsets</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>loops</code></strong> :&ensp;<code>TYPE</code></dt>
<dd>iterations </dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>TYPE</code></dt>
<dd>sets the global player unit offset</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_player_offset(loops=128):
    &#34;&#34;&#34;Summary - scan for player unit as a starting point for all relevant memory offsets
    
    Args:
        loops (TYPE): iterations 
    
    Returns:
        TYPE: sets the global player unit offset
    &#34;&#34;&#34;
    found = False

    attempts=0
    name = &#34;&#34;
    new_offset=0

    global player_unit
    global path_addr

    for i in range(loops):
        attempts=i+0

        new_offset = (starting_offset)+(attempts-1)*8

        start_addr = base + new_offset

        player_unit = process.read_longlong(start_addr)

        while player_unit&gt;0:
            p_inventory = player_unit+0x90
            inventory = process.read_longlong(p_inventory)
            if(inventory):

                exp_char = process.read_ushort(base+exp_offset)
                base_check = process.read_ushort(inventory+0x30) !=1


                if(exp_char):
                    base_check = process.read_ushort(inventory+0x70) !=0

            if(base_check):
                
                log = (&#34;Found inventory offset  -&gt;&#34;)
                log_color(log,target=hex(base-inventory),fg_color=mem_color,fg2_color=offset_color)

                if(exp_char):
                    log = (&#34;Char Type               -&gt;&#34;)
                    log_color(log,target=&#34;Expansion&#34;,fg_color=mem_color,fg2_color=offset_color)
                else:
                    log = (&#34;Char Type               -&gt;&#34;)
                    log_color(log,target=&#34;Classic&#34;,fg_color=mem_color,fg2_color=offset_color)

                p_act = player_unit+0x20
                act_addr = process.read_ulonglong(p_act)
                map_seed_addr = act_addr +0x14
                map_seed = process.read_uint(map_seed_addr)
                game_state.map_seed = map_seed

                #print(map_seed)
                p_path = player_unit+0x38
                path_addr = process.read_longlong(p_path)

                x_pos = process.read_ushort(path_addr+0x02)
                #print (x_pos)
                y_pos = process.read_ushort(path_addr+0x06)
                #print (y_pos)
                p_unit_data = player_unit +0x10
                try:
                    player_name_addr = process.read_longlong(p_unit_data)
                except:
                    pass
                p_name = &#34;&#34;
                #
                for i in range(16):
                    name = name + str(chr(process.read_uchar(player_name_addr+i-1)))

                if(x_pos&gt; 0 and y_pos &gt;0 and len(str(map_seed))&gt;6):
                    if loops &gt; 1:
                        log = (&#34;Found player name       -&gt;&#34;)
                        log_color(log,target=name,fg_color=mem_color,fg2_color=important_color)
                        
                        log = (&#34;Found map seed          -&gt;&#34;)
                        log_color(log,target=str(map_seed),fg_color=mem_color,fg2_color=important_color)
                    new_offset = new_offset+0
                    found = True
                    player_unit = new_offset
                    path_addr = path_addr
                    return True

            new_offset = (player_unit+0x150)-base
            try:
                player_unit = process.read_longlong(player_unit +0x150)
            except:
                pass</code></pre>
</details>
</dd>
<dt id="d2read.get_ppos"><code class="name flex">
<span>def <span class="ident">get_ppos</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Summary - update the player positon game state globals</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_ppos():
    &#34;&#34;&#34;Summary - update the player positon game state globals
    &#34;&#34;&#34;
    global path_addr
    #global player_world_pos
    bytes_read = process.read_bytes(path_addr,8)
    x,y = unpack(&#39;xHxxH&#39;, bytes_read)
    game_state.player_world_pos = np.array([x,y])
    #log_color(&#34;Player pos            -&gt; {}&#34;.format(player_world_pos),fg_color=mem_color)</code></pre>
</details>
</dd>
<dt id="d2read.get_tick"><code class="name flex">
<span>def <span class="ident">get_tick</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Summary - for debug, gets the 3D graphics ticks based on frame rate cap</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_tick():
    &#34;&#34;&#34;Summary - for debug, gets the 3D graphics ticks based on frame rate cap
    &#34;&#34;&#34;
    global game_info_state

    offset = game_info_offset
    game_info_addr = base + offset

    off = 0xb4+68
    result = process.read_ulonglong(game_info_addr+off)
    result_2 = process.read_bytes(result+16,1)

    tick = result_2
    game_state.tick = int.from_bytes(tick,&#39;little&#39;)</code></pre>
</details>
</dd>
<dt id="d2read.get_ui"><code class="name flex">
<span>def <span class="ident">get_ui</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Summary - update the global UI state</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_ui():
    &#34;&#34;&#34;Summary - update the global UI state
    &#34;&#34;&#34;

    offset = ui_settings_offset
    ui = base + offset    
    bytes_read = process.read_bytes(ui-10,31)
    ret = unpack(&#39;??????xx???????xxxx?x?xx????x??&#39;, bytes_read)    
    game_state.ui_state = game_state.UI(*ret)</code></pre>
</details>
</dd>
<dt id="d2read.get_ui_settings_offset"><code class="name flex">
<span>def <span class="ident">get_ui_settings_offset</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Summary</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>TYPE</code></dt>
<dd>Description</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_ui_settings_offset():
    &#34;&#34;&#34;Summary
    
    Returns:
        TYPE: Description
    &#34;&#34;&#34;
    #unit table offset
    global ui_settings_offset
    pat = b&#34;\x40\x84\xed\x0f\x94\x05&#34;
    pat_addr = pymem.pattern.pattern_scan_module(handle, module, pat)
    offset_buffer = process.read_int(pat_addr+6)
    ui_settings_offset = ((pat_addr - base) + 10 + offset_buffer)
    log = (&#34;Found ui offset         -&gt;&#34;)
    log_color(log,target=hex(ui_settings_offset),fg_color=mem_color,fg2_color=offset_color)
    #ui_offset =  0x21F89AA</code></pre>
</details>
</dd>
<dt id="d2read.get_unit_offset"><code class="name flex">
<span>def <span class="ident">get_unit_offset</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>doc string</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>TYPE</code></dt>
<dd>Description</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_unit_offset():
    &#39;&#39;&#39;doc string
    
    Returns:
        TYPE: Description
    &#39;&#39;&#39;
    #unit table offset
    global starting_offset
    global player_offset
    pat = b&#34;\x48\x8d.....\x8b\xd1&#34;
    pat_addr = pymem.pattern.pattern_scan_module(handle, module, pat)
    offset_buffer = process.read_int(pat_addr+3)
    player_offset = ((pat_addr - base) + 7 + offset_buffer)
    log = (&#34;Found player offset     -&gt;&#34;)
    log_color(log,target=hex(player_offset),fg_color=mem_color,fg2_color=offset_color)
    starting_offset = player_offset</code></pre>
</details>
</dd>
<dt id="d2read.populate_offsets"><code class="name flex">
<span>def <span class="ident">populate_offsets</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def populate_offsets():
    get_exp_offset()
    get_unit_offset()
    get_game_info_offset()
    get_ui_settings_offset()
    get_menu_vis_offset()
    get_menu_data_offset()
    get_hover_object_offset()</code></pre>
</details>
</dd>
<dt id="d2read.populate_punit"><code class="name flex">
<span>def <span class="ident">populate_punit</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def populate_punit():
    get_player_offset(128)
    find_info()
    get_ppos()</code></pre>
</details>
</dd>
<dt id="d2read.read_loot_cfg"><code class="name flex">
<span>def <span class="ident">read_loot_cfg</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_loot_cfg():
    with open(&#34;Z:/botty-r-latest/src/read_mem/item_filter.yaml&#34;, &#34;r&#34;) as stream:
        try:
            loot_filter = yaml.safe_load(stream)
            #print(loot_filter)
            &#39;&#39;&#39;
            for category in loot_filter:
                print(str(category))
                #for item in loot_filter.get(category):
                print(loot_filter.get(category))
            &#39;&#39;&#39;
                #for value in key:
                #   print(str(value))
            loot_data = loot_filter
        except yaml.YAMLError as exc:
            print(exc)</code></pre>
</details>
</dd>
<dt id="d2read.scan_around_16"><code class="name flex">
<span>def <span class="ident">scan_around_16</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Summary - for debug</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scan_around_16():
    &#34;&#34;&#34;Summary - for debug
    &#34;&#34;&#34;
    global game_info_state

    offset = game_info_offset
    game_info_addr = base + offset

    i=0
    while i &lt; (72*4):
        bytes_read = process.read_bytes(game_info_addr+i,16)
        ret = unpack(&#39;cccccccccccccccc&#39;, bytes_read)
        #name = process.read_string(game_info_addr,10)
        #print(ret, i)
        out = b&#39;&#39;
        for b in ret:
            out+=b
        print(out, i)
        i+=16</code></pre>
</details>
</dd>
<dt id="d2read.shutdown"><code class="name flex">
<span>def <span class="ident">shutdown</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def shutdown():
    global running

    running = False

    log = (&#34;API THREAD SHUTDOWN&#34;)
    log_color(log)</code></pre>
</details>
</dd>
<dt id="d2read.start"><code class="name flex">
<span>def <span class="ident">start</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start():

    global running
    global api_thread
    
    if running == False:
        running = True
        api_thread = threading.Thread(target=game_tick, daemon=True, args=())
        log = (&#34;API THREAD STARTED&#34;)
        log_color(log,fg_color=note_color)
        api_thread.start()</code></pre>
</details>
</dd>
<dt id="d2read.world_to_abs"><code class="name flex">
<span>def <span class="ident">world_to_abs</span></span>(<span>dest, player)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def world_to_abs(dest, player):
    w = 1280
    h = 720
    screen_center = (w/2.0, h/2.0)
    delta = delta_in_world_to_minimap_delta(dest-player, math.sqrt(w*w+h*h), 68.5,30)
    
    x = np.clip(delta[0]-9.5, -638, 638)
    y = np.clip(delta[1]-39.5, -350, 235)

    screen_coords = (x,y)

    return screen_coords</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<div id="dark-mode-toggle" onclick="toggleDarkMode()">
<svg class="dm-icon-off" viewBox="0 0 16 16">
<path d="M7 0h2v2H7zM12.88 1.637l1.414 1.415-1.415 1.413-1.414-1.414zM14 7h2v2h-2zM12.95 14.433l-1.415-1.414 1.414-1.414 1.415 1.413zM7 14h2v2H7zM2.98 14.363L1.566 12.95l1.415-1.414 1.414 1.415zM0 7h2v2H0zM3.05 1.707L4.465 3.12 3.05 4.535 1.636 3.121z" />
<path d="M8 4C5.8 4 4 5.8 4 8s1.8 4 4 4 4-1.8 4-4-1.8-4-4-4z" />
</svg>
<svg class="dm-icon-on" viewBox="0 0 16 16">
<path d="M6,0C2.5,0.9,0,4.1,0,7.9C0,12.4,3.6,16,8.1,16c3.8,0,6.9-2.5,7.9-6C9.9,11.7,4.3,6.1,6,0z"></path>
</svg>
</div>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="d2read.enums" href="enums.html">d2read.enums</a></code></li>
<li><code><a title="d2read.event" href="event.html">d2read.event</a></code></li>
<li><code><a title="d2read.game_state" href="game_state.html">d2read.game_state</a></code></li>
<li><code><a title="d2read.mem" href="mem.html">d2read.mem</a></code></li>
<li><code><a title="d2read.proc" href="proc.html">d2read.proc</a></code></li>
<li><code><a title="d2read.utils" href="utils.html">d2read.utils</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="d2read.delta_in_world_to_minimap_delta" href="#d2read.delta_in_world_to_minimap_delta">delta_in_world_to_minimap_delta</a></code></li>
<li><code><a title="d2read.find_info" href="#d2read.find_info">find_info</a></code></li>
<li><code><a title="d2read.find_mobs" href="#d2read.find_mobs">find_mobs</a></code></li>
<li><code><a title="d2read.find_objects" href="#d2read.find_objects">find_objects</a></code></li>
<li><code><a title="d2read.game_tick" href="#d2read.game_tick">game_tick</a></code></li>
<li><code><a title="d2read.get_addr_test" href="#d2read.get_addr_test">get_addr_test</a></code></li>
<li><code><a title="d2read.get_current_level" href="#d2read.get_current_level">get_current_level</a></code></li>
<li><code><a title="d2read.get_cursor_item" href="#d2read.get_cursor_item">get_cursor_item</a></code></li>
<li><code><a title="d2read.get_exp_offset" href="#d2read.get_exp_offset">get_exp_offset</a></code></li>
<li><code><a title="d2read.get_game_info_offset" href="#d2read.get_game_info_offset">get_game_info_offset</a></code></li>
<li><code><a title="d2read.get_game_ip" href="#d2read.get_game_ip">get_game_ip</a></code></li>
<li><code><a title="d2read.get_game_name" href="#d2read.get_game_name">get_game_name</a></code></li>
<li><code><a title="d2read.get_game_pass" href="#d2read.get_game_pass">get_game_pass</a></code></li>
<li><code><a title="d2read.get_hover_object_offset" href="#d2read.get_hover_object_offset">get_hover_object_offset</a></code></li>
<li><code><a title="d2read.get_in_game_flag" href="#d2read.get_in_game_flag">get_in_game_flag</a></code></li>
<li><code><a title="d2read.get_items" href="#d2read.get_items">get_items</a></code></li>
<li><code><a title="d2read.get_last_hovered" href="#d2read.get_last_hovered">get_last_hovered</a></code></li>
<li><code><a title="d2read.get_map_json" href="#d2read.get_map_json">get_map_json</a></code></li>
<li><code><a title="d2read.get_menu_data_offset" href="#d2read.get_menu_data_offset">get_menu_data_offset</a></code></li>
<li><code><a title="d2read.get_menu_vis_offset" href="#d2read.get_menu_vis_offset">get_menu_vis_offset</a></code></li>
<li><code><a title="d2read.get_player_offset" href="#d2read.get_player_offset">get_player_offset</a></code></li>
<li><code><a title="d2read.get_ppos" href="#d2read.get_ppos">get_ppos</a></code></li>
<li><code><a title="d2read.get_tick" href="#d2read.get_tick">get_tick</a></code></li>
<li><code><a title="d2read.get_ui" href="#d2read.get_ui">get_ui</a></code></li>
<li><code><a title="d2read.get_ui_settings_offset" href="#d2read.get_ui_settings_offset">get_ui_settings_offset</a></code></li>
<li><code><a title="d2read.get_unit_offset" href="#d2read.get_unit_offset">get_unit_offset</a></code></li>
<li><code><a title="d2read.populate_offsets" href="#d2read.populate_offsets">populate_offsets</a></code></li>
<li><code><a title="d2read.populate_punit" href="#d2read.populate_punit">populate_punit</a></code></li>
<li><code><a title="d2read.read_loot_cfg" href="#d2read.read_loot_cfg">read_loot_cfg</a></code></li>
<li><code><a title="d2read.scan_around_16" href="#d2read.scan_around_16">scan_around_16</a></code></li>
<li><code><a title="d2read.shutdown" href="#d2read.shutdown">shutdown</a></code></li>
<li><code><a title="d2read.start" href="#d2read.start">start</a></code></li>
<li><code><a title="d2read.world_to_abs" href="#d2read.world_to_abs">world_to_abs</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>